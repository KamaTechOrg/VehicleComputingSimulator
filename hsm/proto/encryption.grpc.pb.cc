// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: proto/encryption.proto

#include "encryption.pb.h"
#include "encryption.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace crypto {

static const char* CryptoService_method_names[] = {
  "/crypto.CryptoService/bootSystem",
  "/crypto.CryptoService/addProccess",
  "/crypto.CryptoService/configure",
  "/crypto.CryptoService/generateAESKey",
  "/crypto.CryptoService/generateRSAKeyPair",
  "/crypto.CryptoService/generateECCKeyPair",
  "/crypto.CryptoService/getSignedDataLength",
  "/crypto.CryptoService/getECCencryptedLength",
  "/crypto.CryptoService/getECCDecryptedLength",
  "/crypto.CryptoService/getRSAencryptedLength",
  "/crypto.CryptoService/getRSAdecryptedLength",
  "/crypto.CryptoService/getAESencryptedLength",
  "/crypto.CryptoService/getAESdecryptedLength",
  "/crypto.CryptoService/getEncryptedLen",
  "/crypto.CryptoService/getDecryptedLen",
  "/crypto.CryptoService/sign",
  "/crypto.CryptoService/verify",
  "/crypto.CryptoService/getPublicECCKeyByUserId",
  "/crypto.CryptoService/getPublicRSAKeyByUserId",
  "/crypto.CryptoService/ECCencrypt",
  "/crypto.CryptoService/ECCdecrypt",
  "/crypto.CryptoService/RSAencrypt",
  "/crypto.CryptoService/RSAdecrypt",
  "/crypto.CryptoService/AESencrypt",
  "/crypto.CryptoService/AESdecrypt",
  "/crypto.CryptoService/encrypt",
  "/crypto.CryptoService/decrypt",
  "/crypto.CryptoService/signUpdate",
  "/crypto.CryptoService/signFinalize",
  "/crypto.CryptoService/verifyUpdate",
  "/crypto.CryptoService/verifyFinalize",
};

std::unique_ptr< CryptoService::Stub> CryptoService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< CryptoService::Stub> stub(new CryptoService::Stub(channel, options));
  return stub;
}

CryptoService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_bootSystem_(CryptoService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_addProccess_(CryptoService_method_names[1], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_configure_(CryptoService_method_names[2], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_generateAESKey_(CryptoService_method_names[3], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_generateRSAKeyPair_(CryptoService_method_names[4], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_generateECCKeyPair_(CryptoService_method_names[5], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getSignedDataLength_(CryptoService_method_names[6], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getECCencryptedLength_(CryptoService_method_names[7], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getECCDecryptedLength_(CryptoService_method_names[8], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getRSAencryptedLength_(CryptoService_method_names[9], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getRSAdecryptedLength_(CryptoService_method_names[10], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getAESencryptedLength_(CryptoService_method_names[11], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getAESdecryptedLength_(CryptoService_method_names[12], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getEncryptedLen_(CryptoService_method_names[13], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getDecryptedLen_(CryptoService_method_names[14], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_sign_(CryptoService_method_names[15], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_verify_(CryptoService_method_names[16], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getPublicECCKeyByUserId_(CryptoService_method_names[17], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_getPublicRSAKeyByUserId_(CryptoService_method_names[18], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ECCencrypt_(CryptoService_method_names[19], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ECCdecrypt_(CryptoService_method_names[20], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_RSAencrypt_(CryptoService_method_names[21], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_RSAdecrypt_(CryptoService_method_names[22], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_AESencrypt_(CryptoService_method_names[23], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_AESdecrypt_(CryptoService_method_names[24], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_encrypt_(CryptoService_method_names[25], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_decrypt_(CryptoService_method_names[26], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_signUpdate_(CryptoService_method_names[27], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_signFinalize_(CryptoService_method_names[28], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_verifyUpdate_(CryptoService_method_names[29], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_verifyFinalize_(CryptoService_method_names[30], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status CryptoService::Stub::bootSystem(::grpc::ClientContext* context, const ::crypto::BootSystemRequest& request, ::crypto::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::BootSystemRequest, ::crypto::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_bootSystem_, context, request, response);
}

void CryptoService::Stub::async::bootSystem(::grpc::ClientContext* context, const ::crypto::BootSystemRequest* request, ::crypto::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::BootSystemRequest, ::crypto::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_bootSystem_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::bootSystem(::grpc::ClientContext* context, const ::crypto::BootSystemRequest* request, ::crypto::Empty* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_bootSystem_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::Empty>* CryptoService::Stub::PrepareAsyncbootSystemRaw(::grpc::ClientContext* context, const ::crypto::BootSystemRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::Empty, ::crypto::BootSystemRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_bootSystem_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::Empty>* CryptoService::Stub::AsyncbootSystemRaw(::grpc::ClientContext* context, const ::crypto::BootSystemRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncbootSystemRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::addProccess(::grpc::ClientContext* context, const ::crypto::AddProcessRequest& request, ::crypto::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::AddProcessRequest, ::crypto::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_addProccess_, context, request, response);
}

void CryptoService::Stub::async::addProccess(::grpc::ClientContext* context, const ::crypto::AddProcessRequest* request, ::crypto::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::AddProcessRequest, ::crypto::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_addProccess_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::addProccess(::grpc::ClientContext* context, const ::crypto::AddProcessRequest* request, ::crypto::Empty* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_addProccess_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::Empty>* CryptoService::Stub::PrepareAsyncaddProccessRaw(::grpc::ClientContext* context, const ::crypto::AddProcessRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::Empty, ::crypto::AddProcessRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_addProccess_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::Empty>* CryptoService::Stub::AsyncaddProccessRaw(::grpc::ClientContext* context, const ::crypto::AddProcessRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncaddProccessRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::configure(::grpc::ClientContext* context, const ::crypto::ConfigureRequest& request, ::crypto::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::ConfigureRequest, ::crypto::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_configure_, context, request, response);
}

void CryptoService::Stub::async::configure(::grpc::ClientContext* context, const ::crypto::ConfigureRequest* request, ::crypto::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::ConfigureRequest, ::crypto::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_configure_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::configure(::grpc::ClientContext* context, const ::crypto::ConfigureRequest* request, ::crypto::Empty* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_configure_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::Empty>* CryptoService::Stub::PrepareAsyncconfigureRaw(::grpc::ClientContext* context, const ::crypto::ConfigureRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::Empty, ::crypto::ConfigureRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_configure_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::Empty>* CryptoService::Stub::AsyncconfigureRaw(::grpc::ClientContext* context, const ::crypto::ConfigureRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncconfigureRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::generateAESKey(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest& request, ::crypto::GenerateAESKeyResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::GenerateAESKeyRequest, ::crypto::GenerateAESKeyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_generateAESKey_, context, request, response);
}

void CryptoService::Stub::async::generateAESKey(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest* request, ::crypto::GenerateAESKeyResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::GenerateAESKeyRequest, ::crypto::GenerateAESKeyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_generateAESKey_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::generateAESKey(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest* request, ::crypto::GenerateAESKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_generateAESKey_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::GenerateAESKeyResponse>* CryptoService::Stub::PrepareAsyncgenerateAESKeyRaw(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::GenerateAESKeyResponse, ::crypto::GenerateAESKeyRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_generateAESKey_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::GenerateAESKeyResponse>* CryptoService::Stub::AsyncgenerateAESKeyRaw(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgenerateAESKeyRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::generateRSAKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::crypto::GenerateKeyPairResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_generateRSAKeyPair_, context, request, response);
}

void CryptoService::Stub::async::generateRSAKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_generateRSAKeyPair_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::generateRSAKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_generateRSAKeyPair_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>* CryptoService::Stub::PrepareAsyncgenerateRSAKeyPairRaw(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::GenerateKeyPairResponse, ::crypto::GenerateKeyPairRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_generateRSAKeyPair_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>* CryptoService::Stub::AsyncgenerateRSAKeyPairRaw(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgenerateRSAKeyPairRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::generateECCKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::crypto::GenerateKeyPairResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_generateECCKeyPair_, context, request, response);
}

void CryptoService::Stub::async::generateECCKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_generateECCKeyPair_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::generateECCKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_generateECCKeyPair_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>* CryptoService::Stub::PrepareAsyncgenerateECCKeyPairRaw(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::GenerateKeyPairResponse, ::crypto::GenerateKeyPairRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_generateECCKeyPair_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>* CryptoService::Stub::AsyncgenerateECCKeyPairRaw(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgenerateECCKeyPairRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::getSignedDataLength(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest& request, ::crypto::GetLengthResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::GetHashLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getSignedDataLength_, context, request, response);
}

void CryptoService::Stub::async::getSignedDataLength(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::GetHashLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getSignedDataLength_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::getSignedDataLength(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getSignedDataLength_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::PrepareAsyncgetSignedDataLengthRaw(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::GetLengthResponse, ::crypto::GetHashLengthRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getSignedDataLength_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::AsyncgetSignedDataLengthRaw(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetSignedDataLengthRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::getECCencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::crypto::GetLengthResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getECCencryptedLength_, context, request, response);
}

void CryptoService::Stub::async::getECCencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getECCencryptedLength_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::getECCencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getECCencryptedLength_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::PrepareAsyncgetECCencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::GetLengthResponse, ::crypto::GetLengthRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getECCencryptedLength_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::AsyncgetECCencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetECCencryptedLengthRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::getECCDecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::crypto::GetLengthResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getECCDecryptedLength_, context, request, response);
}

void CryptoService::Stub::async::getECCDecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getECCDecryptedLength_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::getECCDecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getECCDecryptedLength_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::PrepareAsyncgetECCDecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::GetLengthResponse, ::crypto::GetLengthRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getECCDecryptedLength_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::AsyncgetECCDecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetECCDecryptedLengthRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::getRSAencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::crypto::GetLengthResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getRSAencryptedLength_, context, request, response);
}

void CryptoService::Stub::async::getRSAencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getRSAencryptedLength_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::getRSAencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getRSAencryptedLength_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::PrepareAsyncgetRSAencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::GetLengthResponse, ::crypto::GetLengthRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getRSAencryptedLength_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::AsyncgetRSAencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetRSAencryptedLengthRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::getRSAdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::crypto::GetLengthResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getRSAdecryptedLength_, context, request, response);
}

void CryptoService::Stub::async::getRSAdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getRSAdecryptedLength_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::getRSAdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getRSAdecryptedLength_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::PrepareAsyncgetRSAdecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::GetLengthResponse, ::crypto::GetLengthRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getRSAdecryptedLength_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::AsyncgetRSAdecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetRSAdecryptedLengthRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::getAESencryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::crypto::GetLengthResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getAESencryptedLength_, context, request, response);
}

void CryptoService::Stub::async::getAESencryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getAESencryptedLength_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::getAESencryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getAESencryptedLength_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::PrepareAsyncgetAESencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::GetLengthResponse, ::crypto::GetAESLengthRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getAESencryptedLength_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::AsyncgetAESencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetAESencryptedLengthRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::getAESdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::crypto::GetLengthResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getAESdecryptedLength_, context, request, response);
}

void CryptoService::Stub::async::getAESdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getAESdecryptedLength_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::getAESdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getAESdecryptedLength_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::PrepareAsyncgetAESdecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::GetLengthResponse, ::crypto::GetAESLengthRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getAESdecryptedLength_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::AsyncgetAESdecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetAESdecryptedLengthRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::getEncryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::crypto::GetLengthResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::GetWholeLength, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getEncryptedLen_, context, request, response);
}

void CryptoService::Stub::async::getEncryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::GetWholeLength, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getEncryptedLen_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::getEncryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getEncryptedLen_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::PrepareAsyncgetEncryptedLenRaw(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::GetLengthResponse, ::crypto::GetWholeLength, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getEncryptedLen_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::AsyncgetEncryptedLenRaw(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetEncryptedLenRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::getDecryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::crypto::GetLengthResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::GetWholeLength, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getDecryptedLen_, context, request, response);
}

void CryptoService::Stub::async::getDecryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::GetWholeLength, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getDecryptedLen_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::getDecryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getDecryptedLen_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::PrepareAsyncgetDecryptedLenRaw(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::GetLengthResponse, ::crypto::GetWholeLength, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getDecryptedLen_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* CryptoService::Stub::AsyncgetDecryptedLenRaw(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetDecryptedLenRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::sign(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::crypto::SignResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::SignRequest, ::crypto::SignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_sign_, context, request, response);
}

void CryptoService::Stub::async::sign(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::SignRequest, ::crypto::SignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_sign_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::sign(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_sign_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>* CryptoService::Stub::PrepareAsyncsignRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::SignResponse, ::crypto::SignRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_sign_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>* CryptoService::Stub::AsyncsignRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncsignRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::verify(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::crypto::VerifyResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::VerifyRequest, ::crypto::VerifyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_verify_, context, request, response);
}

void CryptoService::Stub::async::verify(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::VerifyRequest, ::crypto::VerifyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_verify_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::verify(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_verify_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>* CryptoService::Stub::PrepareAsyncverifyRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::VerifyResponse, ::crypto::VerifyRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_verify_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>* CryptoService::Stub::AsyncverifyRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncverifyRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::getPublicECCKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::crypto::KeyResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::KeyRequest, ::crypto::KeyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getPublicECCKeyByUserId_, context, request, response);
}

void CryptoService::Stub::async::getPublicECCKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::KeyRequest, ::crypto::KeyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getPublicECCKeyByUserId_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::getPublicECCKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getPublicECCKeyByUserId_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>* CryptoService::Stub::PrepareAsyncgetPublicECCKeyByUserIdRaw(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::KeyResponse, ::crypto::KeyRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getPublicECCKeyByUserId_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>* CryptoService::Stub::AsyncgetPublicECCKeyByUserIdRaw(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetPublicECCKeyByUserIdRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::getPublicRSAKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::crypto::KeyResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::KeyRequest, ::crypto::KeyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_getPublicRSAKeyByUserId_, context, request, response);
}

void CryptoService::Stub::async::getPublicRSAKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::KeyRequest, ::crypto::KeyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getPublicRSAKeyByUserId_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::getPublicRSAKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_getPublicRSAKeyByUserId_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>* CryptoService::Stub::PrepareAsyncgetPublicRSAKeyByUserIdRaw(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::KeyResponse, ::crypto::KeyRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_getPublicRSAKeyByUserId_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>* CryptoService::Stub::AsyncgetPublicRSAKeyByUserIdRaw(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncgetPublicRSAKeyByUserIdRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::ECCencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::crypto::AsymetricEncryptResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ECCencrypt_, context, request, response);
}

void CryptoService::Stub::async::ECCencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ECCencrypt_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::ECCencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ECCencrypt_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>* CryptoService::Stub::PrepareAsyncECCencryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::AsymetricEncryptResponse, ::crypto::AsymetricEncryptRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ECCencrypt_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>* CryptoService::Stub::AsyncECCencryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncECCencryptRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::ECCdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::crypto::AsymetricDecryptResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_ECCdecrypt_, context, request, response);
}

void CryptoService::Stub::async::ECCdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ECCdecrypt_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::ECCdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_ECCdecrypt_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>* CryptoService::Stub::PrepareAsyncECCdecryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::AsymetricDecryptResponse, ::crypto::AsymetricDecryptRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_ECCdecrypt_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>* CryptoService::Stub::AsyncECCdecryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncECCdecryptRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::RSAencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::crypto::AsymetricEncryptResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_RSAencrypt_, context, request, response);
}

void CryptoService::Stub::async::RSAencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_RSAencrypt_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::RSAencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_RSAencrypt_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>* CryptoService::Stub::PrepareAsyncRSAencryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::AsymetricEncryptResponse, ::crypto::AsymetricEncryptRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_RSAencrypt_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>* CryptoService::Stub::AsyncRSAencryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncRSAencryptRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::RSAdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::crypto::AsymetricDecryptResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_RSAdecrypt_, context, request, response);
}

void CryptoService::Stub::async::RSAdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_RSAdecrypt_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::RSAdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_RSAdecrypt_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>* CryptoService::Stub::PrepareAsyncRSAdecryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::AsymetricDecryptResponse, ::crypto::AsymetricDecryptRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_RSAdecrypt_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>* CryptoService::Stub::AsyncRSAdecryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncRSAdecryptRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::AESencrypt(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest& request, ::crypto::AESEncryptResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::AESEncryptRequest, ::crypto::AESEncryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_AESencrypt_, context, request, response);
}

void CryptoService::Stub::async::AESencrypt(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest* request, ::crypto::AESEncryptResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::AESEncryptRequest, ::crypto::AESEncryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AESencrypt_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::AESencrypt(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest* request, ::crypto::AESEncryptResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AESencrypt_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::AESEncryptResponse>* CryptoService::Stub::PrepareAsyncAESencryptRaw(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::AESEncryptResponse, ::crypto::AESEncryptRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_AESencrypt_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::AESEncryptResponse>* CryptoService::Stub::AsyncAESencryptRaw(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncAESencryptRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::AESdecrypt(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest& request, ::crypto::AESDecryptResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::AESDecryptRequest, ::crypto::AESDecryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_AESdecrypt_, context, request, response);
}

void CryptoService::Stub::async::AESdecrypt(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest* request, ::crypto::AESDecryptResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::AESDecryptRequest, ::crypto::AESDecryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AESdecrypt_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::AESdecrypt(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest* request, ::crypto::AESDecryptResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AESdecrypt_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::AESDecryptResponse>* CryptoService::Stub::PrepareAsyncAESdecryptRaw(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::AESDecryptResponse, ::crypto::AESDecryptRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_AESdecrypt_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::AESDecryptResponse>* CryptoService::Stub::AsyncAESdecryptRaw(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncAESdecryptRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::encrypt(::grpc::ClientContext* context, const ::crypto::EncryptRequest& request, ::crypto::EncryptResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::EncryptRequest, ::crypto::EncryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_encrypt_, context, request, response);
}

void CryptoService::Stub::async::encrypt(::grpc::ClientContext* context, const ::crypto::EncryptRequest* request, ::crypto::EncryptResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::EncryptRequest, ::crypto::EncryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_encrypt_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::encrypt(::grpc::ClientContext* context, const ::crypto::EncryptRequest* request, ::crypto::EncryptResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_encrypt_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::EncryptResponse>* CryptoService::Stub::PrepareAsyncencryptRaw(::grpc::ClientContext* context, const ::crypto::EncryptRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::EncryptResponse, ::crypto::EncryptRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_encrypt_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::EncryptResponse>* CryptoService::Stub::AsyncencryptRaw(::grpc::ClientContext* context, const ::crypto::EncryptRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncencryptRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::decrypt(::grpc::ClientContext* context, const ::crypto::DecryptRequest& request, ::crypto::DecryptResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::DecryptRequest, ::crypto::DecryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_decrypt_, context, request, response);
}

void CryptoService::Stub::async::decrypt(::grpc::ClientContext* context, const ::crypto::DecryptRequest* request, ::crypto::DecryptResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::DecryptRequest, ::crypto::DecryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_decrypt_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::decrypt(::grpc::ClientContext* context, const ::crypto::DecryptRequest* request, ::crypto::DecryptResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_decrypt_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::DecryptResponse>* CryptoService::Stub::PrepareAsyncdecryptRaw(::grpc::ClientContext* context, const ::crypto::DecryptRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::DecryptResponse, ::crypto::DecryptRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_decrypt_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::DecryptResponse>* CryptoService::Stub::AsyncdecryptRaw(::grpc::ClientContext* context, const ::crypto::DecryptRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncdecryptRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::signUpdate(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::crypto::SignResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::SignRequest, ::crypto::SignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_signUpdate_, context, request, response);
}

void CryptoService::Stub::async::signUpdate(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::SignRequest, ::crypto::SignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_signUpdate_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::signUpdate(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_signUpdate_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>* CryptoService::Stub::PrepareAsyncsignUpdateRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::SignResponse, ::crypto::SignRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_signUpdate_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>* CryptoService::Stub::AsyncsignUpdateRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncsignUpdateRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::signFinalize(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::crypto::SignResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::SignRequest, ::crypto::SignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_signFinalize_, context, request, response);
}

void CryptoService::Stub::async::signFinalize(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::SignRequest, ::crypto::SignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_signFinalize_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::signFinalize(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_signFinalize_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>* CryptoService::Stub::PrepareAsyncsignFinalizeRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::SignResponse, ::crypto::SignRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_signFinalize_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>* CryptoService::Stub::AsyncsignFinalizeRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncsignFinalizeRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::verifyUpdate(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::crypto::VerifyResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::VerifyRequest, ::crypto::VerifyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_verifyUpdate_, context, request, response);
}

void CryptoService::Stub::async::verifyUpdate(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::VerifyRequest, ::crypto::VerifyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_verifyUpdate_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::verifyUpdate(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_verifyUpdate_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>* CryptoService::Stub::PrepareAsyncverifyUpdateRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::VerifyResponse, ::crypto::VerifyRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_verifyUpdate_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>* CryptoService::Stub::AsyncverifyUpdateRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncverifyUpdateRaw(context, request, cq);
  result->StartCall();
  return result;
}

::grpc::Status CryptoService::Stub::verifyFinalize(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::crypto::VerifyResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::crypto::VerifyRequest, ::crypto::VerifyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_verifyFinalize_, context, request, response);
}

void CryptoService::Stub::async::verifyFinalize(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::crypto::VerifyRequest, ::crypto::VerifyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_verifyFinalize_, context, request, response, std::move(f));
}

void CryptoService::Stub::async::verifyFinalize(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_verifyFinalize_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>* CryptoService::Stub::PrepareAsyncverifyFinalizeRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::crypto::VerifyResponse, ::crypto::VerifyRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_verifyFinalize_, context, request);
}

::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>* CryptoService::Stub::AsyncverifyFinalizeRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncverifyFinalizeRaw(context, request, cq);
  result->StartCall();
  return result;
}

CryptoService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::BootSystemRequest, ::crypto::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::BootSystemRequest* req,
             ::crypto::Empty* resp) {
               return service->bootSystem(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::AddProcessRequest, ::crypto::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::AddProcessRequest* req,
             ::crypto::Empty* resp) {
               return service->addProccess(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::ConfigureRequest, ::crypto::Empty, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::ConfigureRequest* req,
             ::crypto::Empty* resp) {
               return service->configure(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::GenerateAESKeyRequest, ::crypto::GenerateAESKeyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::GenerateAESKeyRequest* req,
             ::crypto::GenerateAESKeyResponse* resp) {
               return service->generateAESKey(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::GenerateKeyPairRequest* req,
             ::crypto::GenerateKeyPairResponse* resp) {
               return service->generateRSAKeyPair(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::GenerateKeyPairRequest* req,
             ::crypto::GenerateKeyPairResponse* resp) {
               return service->generateECCKeyPair(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::GetHashLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::GetHashLengthRequest* req,
             ::crypto::GetLengthResponse* resp) {
               return service->getSignedDataLength(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::GetLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::GetLengthRequest* req,
             ::crypto::GetLengthResponse* resp) {
               return service->getECCencryptedLength(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::GetLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::GetLengthRequest* req,
             ::crypto::GetLengthResponse* resp) {
               return service->getECCDecryptedLength(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::GetLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::GetLengthRequest* req,
             ::crypto::GetLengthResponse* resp) {
               return service->getRSAencryptedLength(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::GetLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::GetLengthRequest* req,
             ::crypto::GetLengthResponse* resp) {
               return service->getRSAdecryptedLength(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::GetAESLengthRequest* req,
             ::crypto::GetLengthResponse* resp) {
               return service->getAESencryptedLength(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::GetAESLengthRequest* req,
             ::crypto::GetLengthResponse* resp) {
               return service->getAESdecryptedLength(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[13],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::GetWholeLength, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::GetWholeLength* req,
             ::crypto::GetLengthResponse* resp) {
               return service->getEncryptedLen(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[14],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::GetWholeLength, ::crypto::GetLengthResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::GetWholeLength* req,
             ::crypto::GetLengthResponse* resp) {
               return service->getDecryptedLen(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[15],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::SignRequest, ::crypto::SignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::SignRequest* req,
             ::crypto::SignResponse* resp) {
               return service->sign(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[16],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::VerifyRequest, ::crypto::VerifyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::VerifyRequest* req,
             ::crypto::VerifyResponse* resp) {
               return service->verify(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[17],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::KeyRequest, ::crypto::KeyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::KeyRequest* req,
             ::crypto::KeyResponse* resp) {
               return service->getPublicECCKeyByUserId(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[18],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::KeyRequest, ::crypto::KeyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::KeyRequest* req,
             ::crypto::KeyResponse* resp) {
               return service->getPublicRSAKeyByUserId(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[19],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::AsymetricEncryptRequest* req,
             ::crypto::AsymetricEncryptResponse* resp) {
               return service->ECCencrypt(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[20],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::AsymetricDecryptRequest* req,
             ::crypto::AsymetricDecryptResponse* resp) {
               return service->ECCdecrypt(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[21],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::AsymetricEncryptRequest* req,
             ::crypto::AsymetricEncryptResponse* resp) {
               return service->RSAencrypt(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[22],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::AsymetricDecryptRequest* req,
             ::crypto::AsymetricDecryptResponse* resp) {
               return service->RSAdecrypt(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[23],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::AESEncryptRequest, ::crypto::AESEncryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::AESEncryptRequest* req,
             ::crypto::AESEncryptResponse* resp) {
               return service->AESencrypt(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[24],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::AESDecryptRequest, ::crypto::AESDecryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::AESDecryptRequest* req,
             ::crypto::AESDecryptResponse* resp) {
               return service->AESdecrypt(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[25],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::EncryptRequest, ::crypto::EncryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::EncryptRequest* req,
             ::crypto::EncryptResponse* resp) {
               return service->encrypt(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[26],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::DecryptRequest, ::crypto::DecryptResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::DecryptRequest* req,
             ::crypto::DecryptResponse* resp) {
               return service->decrypt(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[27],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::SignRequest, ::crypto::SignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::SignRequest* req,
             ::crypto::SignResponse* resp) {
               return service->signUpdate(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[28],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::SignRequest, ::crypto::SignResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::SignRequest* req,
             ::crypto::SignResponse* resp) {
               return service->signFinalize(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[29],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::VerifyRequest, ::crypto::VerifyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::VerifyRequest* req,
             ::crypto::VerifyResponse* resp) {
               return service->verifyUpdate(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CryptoService_method_names[30],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CryptoService::Service, ::crypto::VerifyRequest, ::crypto::VerifyResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](CryptoService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::crypto::VerifyRequest* req,
             ::crypto::VerifyResponse* resp) {
               return service->verifyFinalize(ctx, req, resp);
             }, this)));
}

CryptoService::Service::~Service() {
}

::grpc::Status CryptoService::Service::bootSystem(::grpc::ServerContext* context, const ::crypto::BootSystemRequest* request, ::crypto::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::addProccess(::grpc::ServerContext* context, const ::crypto::AddProcessRequest* request, ::crypto::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::configure(::grpc::ServerContext* context, const ::crypto::ConfigureRequest* request, ::crypto::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::generateAESKey(::grpc::ServerContext* context, const ::crypto::GenerateAESKeyRequest* request, ::crypto::GenerateAESKeyResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::generateRSAKeyPair(::grpc::ServerContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::generateECCKeyPair(::grpc::ServerContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::getSignedDataLength(::grpc::ServerContext* context, const ::crypto::GetHashLengthRequest* request, ::crypto::GetLengthResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::getECCencryptedLength(::grpc::ServerContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::getECCDecryptedLength(::grpc::ServerContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::getRSAencryptedLength(::grpc::ServerContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::getRSAdecryptedLength(::grpc::ServerContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::getAESencryptedLength(::grpc::ServerContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::getAESdecryptedLength(::grpc::ServerContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::getEncryptedLen(::grpc::ServerContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::getDecryptedLen(::grpc::ServerContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::sign(::grpc::ServerContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::verify(::grpc::ServerContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::getPublicECCKeyByUserId(::grpc::ServerContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::getPublicRSAKeyByUserId(::grpc::ServerContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::ECCencrypt(::grpc::ServerContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::ECCdecrypt(::grpc::ServerContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::RSAencrypt(::grpc::ServerContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::RSAdecrypt(::grpc::ServerContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::AESencrypt(::grpc::ServerContext* context, const ::crypto::AESEncryptRequest* request, ::crypto::AESEncryptResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::AESdecrypt(::grpc::ServerContext* context, const ::crypto::AESDecryptRequest* request, ::crypto::AESDecryptResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::encrypt(::grpc::ServerContext* context, const ::crypto::EncryptRequest* request, ::crypto::EncryptResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::decrypt(::grpc::ServerContext* context, const ::crypto::DecryptRequest* request, ::crypto::DecryptResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::signUpdate(::grpc::ServerContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::signFinalize(::grpc::ServerContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::verifyUpdate(::grpc::ServerContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CryptoService::Service::verifyFinalize(::grpc::ServerContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace crypto

