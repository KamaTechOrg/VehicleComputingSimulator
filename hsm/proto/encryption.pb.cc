// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/encryption.proto

#include "encryption.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace crypto {
constexpr AsymetricEncryptRequest::AsymetricEncryptRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : keyid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0){}
struct AsymetricEncryptRequestDefaultTypeInternal {
  constexpr AsymetricEncryptRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AsymetricEncryptRequestDefaultTypeInternal() {}
  union {
    AsymetricEncryptRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AsymetricEncryptRequestDefaultTypeInternal _AsymetricEncryptRequest_default_instance_;
constexpr AsymetricEncryptResponse::AsymetricEncryptResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : encrypted_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AsymetricEncryptResponseDefaultTypeInternal {
  constexpr AsymetricEncryptResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AsymetricEncryptResponseDefaultTypeInternal() {}
  union {
    AsymetricEncryptResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AsymetricEncryptResponseDefaultTypeInternal _AsymetricEncryptResponse_default_instance_;
constexpr AsymetricDecryptRequest::AsymetricDecryptRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : keyid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , receiverid_(0){}
struct AsymetricDecryptRequestDefaultTypeInternal {
  constexpr AsymetricDecryptRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AsymetricDecryptRequestDefaultTypeInternal() {}
  union {
    AsymetricDecryptRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AsymetricDecryptRequestDefaultTypeInternal _AsymetricDecryptRequest_default_instance_;
constexpr GetHashLengthRequest::GetHashLengthRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : func_(0)

  , datalen_(0){}
struct GetHashLengthRequestDefaultTypeInternal {
  constexpr GetHashLengthRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetHashLengthRequestDefaultTypeInternal() {}
  union {
    GetHashLengthRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetHashLengthRequestDefaultTypeInternal _GetHashLengthRequest_default_instance_;
constexpr GetAESLengthRequest::GetAESLengthRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : datalen_(0)
  , isfirst_(false)
  , chainingmode_(0)
{}
struct GetAESLengthRequestDefaultTypeInternal {
  constexpr GetAESLengthRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetAESLengthRequestDefaultTypeInternal() {}
  union {
    GetAESLengthRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetAESLengthRequestDefaultTypeInternal _GetAESLengthRequest_default_instance_;
constexpr AsymetricDecryptResponse::AsymetricDecryptResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : decrypted_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AsymetricDecryptResponseDefaultTypeInternal {
  constexpr AsymetricDecryptResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AsymetricDecryptResponseDefaultTypeInternal() {}
  union {
    AsymetricDecryptResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AsymetricDecryptResponseDefaultTypeInternal _AsymetricDecryptResponse_default_instance_;
constexpr GetLengthRequest::GetLengthRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : in_len_(0){}
struct GetLengthRequestDefaultTypeInternal {
  constexpr GetLengthRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetLengthRequestDefaultTypeInternal() {}
  union {
    GetLengthRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetLengthRequestDefaultTypeInternal _GetLengthRequest_default_instance_;
constexpr GetLengthResponse::GetLengthResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : len_(0){}
struct GetLengthResponseDefaultTypeInternal {
  constexpr GetLengthResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetLengthResponseDefaultTypeInternal() {}
  union {
    GetLengthResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetLengthResponseDefaultTypeInternal _GetLengthResponse_default_instance_;
constexpr GetWholeLength::GetWholeLength(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : senderid_(0)
  , inlen_(0)
  , isfirst_(false){}
struct GetWholeLengthDefaultTypeInternal {
  constexpr GetWholeLengthDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetWholeLengthDefaultTypeInternal() {}
  union {
    GetWholeLength _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetWholeLengthDefaultTypeInternal _GetWholeLength_default_instance_;
constexpr GenerateAESKeyRequest::GenerateAESKeyRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : permissions_()
  , _permissions_cached_byte_size_(0)
  , user_id_(0)
  , keylength_(0)

  , destuserid_(0){}
struct GenerateAESKeyRequestDefaultTypeInternal {
  constexpr GenerateAESKeyRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GenerateAESKeyRequestDefaultTypeInternal() {}
  union {
    GenerateAESKeyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GenerateAESKeyRequestDefaultTypeInternal _GenerateAESKeyRequest_default_instance_;
constexpr GenerateAESKeyResponse::GenerateAESKeyResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : aes_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct GenerateAESKeyResponseDefaultTypeInternal {
  constexpr GenerateAESKeyResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GenerateAESKeyResponseDefaultTypeInternal() {}
  union {
    GenerateAESKeyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GenerateAESKeyResponseDefaultTypeInternal _GenerateAESKeyResponse_default_instance_;
constexpr GenerateKeyPairRequest::GenerateKeyPairRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : permissions_()
  , _permissions_cached_byte_size_(0)
  , user_id_(0){}
struct GenerateKeyPairRequestDefaultTypeInternal {
  constexpr GenerateKeyPairRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GenerateKeyPairRequestDefaultTypeInternal() {}
  union {
    GenerateKeyPairRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GenerateKeyPairRequestDefaultTypeInternal _GenerateKeyPairRequest_default_instance_;
constexpr GenerateKeyPairResponse::GenerateKeyPairResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : public_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , private_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct GenerateKeyPairResponseDefaultTypeInternal {
  constexpr GenerateKeyPairResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GenerateKeyPairResponseDefaultTypeInternal() {}
  union {
    GenerateKeyPairResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GenerateKeyPairResponseDefaultTypeInternal _GenerateKeyPairResponse_default_instance_;
constexpr SignRequest::SignRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , key_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sender_id_(0)
  , hash_func_(0)

  , counter_(int64_t{0}){}
struct SignRequestDefaultTypeInternal {
  constexpr SignRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SignRequestDefaultTypeInternal() {}
  union {
    SignRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SignRequestDefaultTypeInternal _SignRequest_default_instance_;
constexpr SignResponse::SignResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct SignResponseDefaultTypeInternal {
  constexpr SignResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SignResponseDefaultTypeInternal() {}
  union {
    SignResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SignResponseDefaultTypeInternal _SignResponse_default_instance_;
constexpr VerifyRequest::VerifyRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , key_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sender_id_(0)
  , receiver_id_(0)
  , hash_func_(0)

  , counter_(0){}
struct VerifyRequestDefaultTypeInternal {
  constexpr VerifyRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VerifyRequestDefaultTypeInternal() {}
  union {
    VerifyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VerifyRequestDefaultTypeInternal _VerifyRequest_default_instance_;
constexpr VerifyResponse::VerifyResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : out_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , valid_(false){}
struct VerifyResponseDefaultTypeInternal {
  constexpr VerifyResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VerifyResponseDefaultTypeInternal() {}
  union {
    VerifyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VerifyResponseDefaultTypeInternal _VerifyResponse_default_instance_;
constexpr KeyRequest::KeyRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_id_(0){}
struct KeyRequestDefaultTypeInternal {
  constexpr KeyRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeyRequestDefaultTypeInternal() {}
  union {
    KeyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeyRequestDefaultTypeInternal _KeyRequest_default_instance_;
constexpr KeyResponse::KeyResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct KeyResponseDefaultTypeInternal {
  constexpr KeyResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeyResponseDefaultTypeInternal() {}
  union {
    KeyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeyResponseDefaultTypeInternal _KeyResponse_default_instance_;
constexpr UserKeyPermissions::UserKeyPermissions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : permissions_()
  , _permissions_cached_byte_size_(0)
  , userid_(0){}
struct UserKeyPermissionsDefaultTypeInternal {
  constexpr UserKeyPermissionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UserKeyPermissionsDefaultTypeInternal() {}
  union {
    UserKeyPermissions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UserKeyPermissionsDefaultTypeInternal _UserKeyPermissions_default_instance_;
constexpr BootSystemRequest::BootSystemRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : usersidspermissions_(){}
struct BootSystemRequestDefaultTypeInternal {
  constexpr BootSystemRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BootSystemRequestDefaultTypeInternal() {}
  union {
    BootSystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BootSystemRequestDefaultTypeInternal _BootSystemRequest_default_instance_;
constexpr Empty::Empty(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct EmptyDefaultTypeInternal {
  constexpr EmptyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EmptyDefaultTypeInternal() {}
  union {
    Empty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EmptyDefaultTypeInternal _Empty_default_instance_;
constexpr CryptoConfig::CryptoConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : hashfunction_(0)

  , aeskeylength_(0)

  , aeschainingmode_(0)

  , asymmetricfunction_(0)
{}
struct CryptoConfigDefaultTypeInternal {
  constexpr CryptoConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CryptoConfigDefaultTypeInternal() {}
  union {
    CryptoConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CryptoConfigDefaultTypeInternal _CryptoConfig_default_instance_;
constexpr ConfigureRequest::ConfigureRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : config_(nullptr)
  , userid_(0){}
struct ConfigureRequestDefaultTypeInternal {
  constexpr ConfigureRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConfigureRequestDefaultTypeInternal() {}
  union {
    ConfigureRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConfigureRequestDefaultTypeInternal _ConfigureRequest_default_instance_;
constexpr AddProcessRequest::AddProcessRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : permissions_()
  , _permissions_cached_byte_size_(0)
  , userid_(0){}
struct AddProcessRequestDefaultTypeInternal {
  constexpr AddProcessRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AddProcessRequestDefaultTypeInternal() {}
  union {
    AddProcessRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AddProcessRequestDefaultTypeInternal _AddProcessRequest_default_instance_;
constexpr EncryptRequest::EncryptRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sender_id_(0)
  , receiver_id_(0)
  , counter_(int64_t{0})
  , isfirst_(false){}
struct EncryptRequestDefaultTypeInternal {
  constexpr EncryptRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EncryptRequestDefaultTypeInternal() {}
  union {
    EncryptRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EncryptRequestDefaultTypeInternal _EncryptRequest_default_instance_;
constexpr EncryptResponse::EncryptResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : encrypted_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct EncryptResponseDefaultTypeInternal {
  constexpr EncryptResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EncryptResponseDefaultTypeInternal() {}
  union {
    EncryptResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EncryptResponseDefaultTypeInternal _EncryptResponse_default_instance_;
constexpr DecryptRequest::DecryptRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : encrypted_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sender_id_(0)
  , receiver_id_(0)
  , counter_(int64_t{0})
  , isfirst_(false){}
struct DecryptRequestDefaultTypeInternal {
  constexpr DecryptRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DecryptRequestDefaultTypeInternal() {}
  union {
    DecryptRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DecryptRequestDefaultTypeInternal _DecryptRequest_default_instance_;
constexpr DecryptResponse::DecryptResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : decrypted_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct DecryptResponseDefaultTypeInternal {
  constexpr DecryptResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DecryptResponseDefaultTypeInternal() {}
  union {
    DecryptResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DecryptResponseDefaultTypeInternal _DecryptResponse_default_instance_;
constexpr AESEncryptRequest::AESEncryptRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , key_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sender_id_(0)
  , receiver_id_(0)
  , counter_(int64_t{0})
  , func_(0)

  , key_length_(0)

  , chainingmode_(0)

  , isfirst_(false){}
struct AESEncryptRequestDefaultTypeInternal {
  constexpr AESEncryptRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AESEncryptRequestDefaultTypeInternal() {}
  union {
    AESEncryptRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AESEncryptRequestDefaultTypeInternal _AESEncryptRequest_default_instance_;
constexpr AESEncryptResponse::AESEncryptResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : encrypted_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AESEncryptResponseDefaultTypeInternal {
  constexpr AESEncryptResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AESEncryptResponseDefaultTypeInternal() {}
  union {
    AESEncryptResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AESEncryptResponseDefaultTypeInternal _AESEncryptResponse_default_instance_;
constexpr AESDecryptRequest::AESDecryptRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_in_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , data_out_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , key_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sender_id_(0)
  , receiver_id_(0)
  , in_len_(0)
  , func_(0)

  , key_length_(0)

  , chainingmode_(0)

  , counter_(int64_t{0})
  , isfirst_(false){}
struct AESDecryptRequestDefaultTypeInternal {
  constexpr AESDecryptRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AESDecryptRequestDefaultTypeInternal() {}
  union {
    AESDecryptRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AESDecryptRequestDefaultTypeInternal _AESDecryptRequest_default_instance_;
constexpr AESDecryptResponse::AESDecryptResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : decrypted_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AESDecryptResponseDefaultTypeInternal {
  constexpr AESDecryptResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AESDecryptResponseDefaultTypeInternal() {}
  union {
    AESDecryptResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AESDecryptResponseDefaultTypeInternal _AESDecryptResponse_default_instance_;
}  // namespace crypto
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_proto_2fencryption_2eproto[33];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_proto_2fencryption_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_proto_2fencryption_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_proto_2fencryption_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricEncryptRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricEncryptRequest, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricEncryptRequest, keyid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricEncryptRequest, data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricEncryptResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricEncryptResponse, encrypted_data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptRequest, receiverid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptRequest, keyid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptRequest, data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GetHashLengthRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GetHashLengthRequest, func_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetHashLengthRequest, datalen_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GetAESLengthRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GetAESLengthRequest, datalen_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetAESLengthRequest, isfirst_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetAESLengthRequest, chainingmode_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptResponse, decrypted_data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GetLengthRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GetLengthRequest, in_len_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GetLengthResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GetLengthResponse, len_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GetWholeLength, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GetWholeLength, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetWholeLength, inlen_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetWholeLength, isfirst_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyRequest, permissions_),
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyRequest, keylength_),
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyRequest, destuserid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyResponse, aes_key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateKeyPairRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateKeyPairRequest, user_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateKeyPairRequest, permissions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateKeyPairResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateKeyPairResponse, public_key_),
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateKeyPairResponse, private_key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::SignRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::SignRequest, sender_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::SignRequest, data_),
  PROTOBUF_FIELD_OFFSET(::crypto::SignRequest, hash_func_),
  PROTOBUF_FIELD_OFFSET(::crypto::SignRequest, counter_),
  PROTOBUF_FIELD_OFFSET(::crypto::SignRequest, key_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::SignResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::SignResponse, signature_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, sender_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, receiver_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, data_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, signature_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, hash_func_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, key_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, counter_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyResponse, valid_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyResponse, out_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::KeyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::KeyRequest, user_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::KeyResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::KeyResponse, key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::UserKeyPermissions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::UserKeyPermissions, userid_),
  PROTOBUF_FIELD_OFFSET(::crypto::UserKeyPermissions, permissions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::BootSystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::BootSystemRequest, usersidspermissions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::Empty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::CryptoConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::CryptoConfig, hashfunction_),
  PROTOBUF_FIELD_OFFSET(::crypto::CryptoConfig, aeskeylength_),
  PROTOBUF_FIELD_OFFSET(::crypto::CryptoConfig, aeschainingmode_),
  PROTOBUF_FIELD_OFFSET(::crypto::CryptoConfig, asymmetricfunction_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::ConfigureRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::ConfigureRequest, userid_),
  PROTOBUF_FIELD_OFFSET(::crypto::ConfigureRequest, config_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AddProcessRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AddProcessRequest, userid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AddProcessRequest, permissions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptRequest, sender_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptRequest, receiver_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptRequest, data_),
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptRequest, counter_),
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptRequest, isfirst_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptResponse, encrypted_data_),
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptResponse, signature_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, sender_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, receiver_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, encrypted_data_),
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, counter_),
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, signature_),
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, isfirst_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptResponse, decrypted_data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, sender_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, receiver_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, data_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, func_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, counter_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, key_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, key_length_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, chainingmode_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, isfirst_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptResponse, encrypted_data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, sender_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, receiver_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, data_in_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, in_len_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, data_out_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, func_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, key_length_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, chainingmode_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, counter_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, key_id_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, isfirst_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptResponse, decrypted_data_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::crypto::AsymetricEncryptRequest)},
  { 9, -1, -1, sizeof(::crypto::AsymetricEncryptResponse)},
  { 16, -1, -1, sizeof(::crypto::AsymetricDecryptRequest)},
  { 25, -1, -1, sizeof(::crypto::GetHashLengthRequest)},
  { 33, -1, -1, sizeof(::crypto::GetAESLengthRequest)},
  { 42, -1, -1, sizeof(::crypto::AsymetricDecryptResponse)},
  { 49, -1, -1, sizeof(::crypto::GetLengthRequest)},
  { 56, -1, -1, sizeof(::crypto::GetLengthResponse)},
  { 63, -1, -1, sizeof(::crypto::GetWholeLength)},
  { 72, -1, -1, sizeof(::crypto::GenerateAESKeyRequest)},
  { 82, -1, -1, sizeof(::crypto::GenerateAESKeyResponse)},
  { 89, -1, -1, sizeof(::crypto::GenerateKeyPairRequest)},
  { 97, -1, -1, sizeof(::crypto::GenerateKeyPairResponse)},
  { 105, -1, -1, sizeof(::crypto::SignRequest)},
  { 116, -1, -1, sizeof(::crypto::SignResponse)},
  { 123, -1, -1, sizeof(::crypto::VerifyRequest)},
  { 136, -1, -1, sizeof(::crypto::VerifyResponse)},
  { 144, -1, -1, sizeof(::crypto::KeyRequest)},
  { 151, -1, -1, sizeof(::crypto::KeyResponse)},
  { 158, -1, -1, sizeof(::crypto::UserKeyPermissions)},
  { 166, -1, -1, sizeof(::crypto::BootSystemRequest)},
  { 173, -1, -1, sizeof(::crypto::Empty)},
  { 179, -1, -1, sizeof(::crypto::CryptoConfig)},
  { 189, -1, -1, sizeof(::crypto::ConfigureRequest)},
  { 197, -1, -1, sizeof(::crypto::AddProcessRequest)},
  { 205, -1, -1, sizeof(::crypto::EncryptRequest)},
  { 216, -1, -1, sizeof(::crypto::EncryptResponse)},
  { 224, -1, -1, sizeof(::crypto::DecryptRequest)},
  { 236, -1, -1, sizeof(::crypto::DecryptResponse)},
  { 243, -1, -1, sizeof(::crypto::AESEncryptRequest)},
  { 258, -1, -1, sizeof(::crypto::AESEncryptResponse)},
  { 265, -1, -1, sizeof(::crypto::AESDecryptRequest)},
  { 282, -1, -1, sizeof(::crypto::AESDecryptResponse)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AsymetricEncryptRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AsymetricEncryptResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AsymetricDecryptRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GetHashLengthRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GetAESLengthRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AsymetricDecryptResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GetLengthRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GetLengthResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GetWholeLength_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GenerateAESKeyRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GenerateAESKeyResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GenerateKeyPairRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GenerateKeyPairResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_SignRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_SignResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_VerifyRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_VerifyResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_KeyRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_KeyResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_UserKeyPermissions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_BootSystemRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_Empty_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_CryptoConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_ConfigureRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AddProcessRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_EncryptRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_EncryptResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_DecryptRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_DecryptResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AESEncryptRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AESEncryptResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AESDecryptRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AESDecryptResponse_default_instance_),
};

const char descriptor_table_protodef_proto_2fencryption_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\026proto/encryption.proto\022\006crypto\"H\n\027Asym"
  "etricEncryptRequest\022\020\n\010senderId\030\001 \001(\005\022\r\n"
  "\005keyId\030\002 \001(\t\022\014\n\004data\030\003 \001(\014\"2\n\030AsymetricE"
  "ncryptResponse\022\026\n\016encrypted_data\030\001 \001(\014\"J"
  "\n\027AsymetricDecryptRequest\022\022\n\nreceiverId\030"
  "\001 \001(\005\022\r\n\005keyId\030\002 \001(\t\022\014\n\004data\030\003 \001(\014\"K\n\024Ge"
  "tHashLengthRequest\022\"\n\004func\030\001 \001(\0162\024.crypt"
  "o.SHAAlgorithm\022\017\n\007dataLen\030\002 \001(\005\"f\n\023GetAE"
  "SLengthRequest\022\017\n\007dataLen\030\001 \001(\005\022\017\n\007isFir"
  "st\030\002 \001(\010\022-\n\014chainingMode\030\003 \001(\0162\027.crypto."
  "AESChainingMode\"2\n\030AsymetricDecryptRespo"
  "nse\022\026\n\016decrypted_data\030\001 \001(\014\"\"\n\020GetLength"
  "Request\022\016\n\006in_len\030\001 \001(\005\" \n\021GetLengthResp"
  "onse\022\013\n\003len\030\001 \001(\005\"B\n\016GetWholeLength\022\020\n\010s"
  "enderId\030\001 \001(\005\022\r\n\005inLen\030\002 \001(\005\022\017\n\007isFirst\030"
  "\003 \001(\010\"\221\001\n\025GenerateAESKeyRequest\022\017\n\007user_"
  "id\030\001 \001(\005\022*\n\013permissions\030\002 \003(\0162\025.crypto.K"
  "eyPermission\022\'\n\tkeyLength\030\003 \001(\0162\024.crypto"
  ".AESKeyLength\022\022\n\ndestUserId\030\004 \001(\005\")\n\026Gen"
  "erateAESKeyResponse\022\017\n\007aes_key\030\001 \001(\t\"U\n\026"
  "GenerateKeyPairRequest\022\017\n\007user_id\030\001 \001(\005\022"
  "*\n\013permissions\030\002 \003(\0162\025.crypto.KeyPermiss"
  "ion\"B\n\027GenerateKeyPairResponse\022\022\n\npublic"
  "_key\030\001 \001(\t\022\023\n\013private_key\030\002 \001(\t\"x\n\013SignR"
  "equest\022\021\n\tsender_id\030\001 \001(\005\022\014\n\004data\030\002 \001(\014\022"
  "\'\n\thash_func\030\003 \001(\0162\024.crypto.SHAAlgorithm"
  "\022\017\n\007counter\030\005 \001(\003\022\016\n\006key_id\030\006 \001(\t\"!\n\014Sig"
  "nResponse\022\021\n\tsignature\030\001 \001(\014\"\242\001\n\rVerifyR"
  "equest\022\021\n\tsender_id\030\001 \001(\005\022\023\n\013receiver_id"
  "\030\002 \001(\005\022\014\n\004data\030\003 \001(\014\022\021\n\tsignature\030\004 \001(\014\022"
  "\'\n\thash_func\030\005 \001(\0162\024.crypto.SHAAlgorithm"
  "\022\016\n\006key_id\030\006 \001(\t\022\017\n\007counter\030\007 \001(\005\",\n\016Ver"
  "ifyResponse\022\r\n\005valid\030\001 \001(\010\022\013\n\003out\030\002 \001(\014\""
  "\035\n\nKeyRequest\022\017\n\007user_id\030\001 \001(\005\"\032\n\013KeyRes"
  "ponse\022\013\n\003key\030\001 \001(\t\"P\n\022UserKeyPermissions"
  "\022\016\n\006userId\030\001 \001(\005\022*\n\013permissions\030\002 \003(\0162\025."
  "crypto.KeyPermission\"L\n\021BootSystemReques"
  "t\0227\n\023usersIdsPermissions\030\001 \003(\0132\032.crypto."
  "UserKeyPermissions\"\007\n\005Empty\"\320\001\n\014CryptoCo"
  "nfig\022*\n\014hashFunction\030\001 \001(\0162\024.crypto.SHAA"
  "lgorithm\022*\n\014aesKeyLength\030\002 \001(\0162\024.crypto."
  "AESKeyLength\0220\n\017aesChainingMode\030\003 \001(\0162\027."
  "crypto.AESChainingMode\0226\n\022asymmetricFunc"
  "tion\030\004 \001(\0162\032.crypto.AsymmetricFunction\"H"
  "\n\020ConfigureRequest\022\016\n\006userId\030\001 \001(\005\022$\n\006co"
  "nfig\030\002 \001(\0132\024.crypto.CryptoConfig\"O\n\021AddP"
  "rocessRequest\022\016\n\006userId\030\001 \001(\005\022*\n\013permiss"
  "ions\030\002 \003(\0162\025.crypto.KeyPermission\"h\n\016Enc"
  "ryptRequest\022\021\n\tsender_id\030\001 \001(\005\022\023\n\013receiv"
  "er_id\030\002 \001(\005\022\014\n\004data\030\003 \001(\014\022\017\n\007counter\030\004 \001"
  "(\003\022\017\n\007isFirst\030\005 \001(\010\"<\n\017EncryptResponse\022\026"
  "\n\016encrypted_data\030\001 \001(\014\022\021\n\tsignature\030\002 \001("
  "\014\"\205\001\n\016DecryptRequest\022\021\n\tsender_id\030\001 \001(\005\022"
  "\023\n\013receiver_id\030\002 \001(\005\022\026\n\016encrypted_data\030\003"
  " \001(\014\022\017\n\007counter\030\004 \001(\003\022\021\n\tsignature\030\005 \001(\014"
  "\022\017\n\007isFirst\030\006 \001(\010\")\n\017DecryptResponse\022\026\n\016"
  "decrypted_data\030\001 \001(\014\"\376\001\n\021AESEncryptReque"
  "st\022\021\n\tsender_id\030\001 \001(\005\022\023\n\013receiver_id\030\002 \001"
  "(\005\022\014\n\004data\030\003 \001(\014\022(\n\004func\030\004 \001(\0162\032.crypto."
  "AsymmetricFunction\022\017\n\007counter\030\005 \001(\003\022\016\n\006k"
  "ey_id\030\006 \001(\t\022(\n\nkey_length\030\007 \001(\0162\024.crypto"
  ".AESKeyLength\022-\n\014chainingMode\030\010 \001(\0162\027.cr"
  "ypto.AESChainingMode\022\017\n\007isFirst\030\t \001(\010\",\n"
  "\022AESEncryptResponse\022\026\n\016encrypted_data\030\001 "
  "\001(\014\"\243\002\n\021AESDecryptRequest\022\021\n\tsender_id\030\001"
  " \001(\005\022\023\n\013receiver_id\030\002 \001(\005\022\017\n\007data_in\030\003 \001"
  "(\014\022\016\n\006in_len\030\004 \001(\005\022\020\n\010data_out\030\005 \001(\014\022(\n\004"
  "func\030\006 \001(\0162\032.crypto.AsymmetricFunction\022("
  "\n\nkey_length\030\007 \001(\0162\024.crypto.AESKeyLength"
  "\022-\n\014chainingMode\030\010 \001(\0162\027.crypto.AESChain"
  "ingMode\022\017\n\007counter\030\t \001(\003\022\016\n\006key_id\030\n \001(\t"
  "\022\017\n\007isFirst\030\013 \001(\010\",\n\022AESDecryptResponse\022"
  "\026\n\016decrypted_data\030\001 \001(\014*O\n\rKeyPermission"
  "\022\n\n\006VERIFY\020\000\022\010\n\004SIGN\020\001\022\013\n\007ENCRYPT\020\002\022\013\n\007D"
  "ECRYPT\020\003\022\016\n\nEXPORTABLE\020\004*>\n\017AESChainingM"
  "ode\022\007\n\003ECB\020\000\022\007\n\003CBC\020\001\022\007\n\003CFB\020\002\022\007\n\003OFB\020\003\022"
  "\007\n\003CTR\020\004*&\n\022AsymmetricFunction\022\007\n\003RSA\020\000\022"
  "\007\n\003ECC\020\001*(\n\014SHAAlgorithm\022\n\n\006SHA256\020\000\022\014\n\010"
  "SHA3_512\020\001*5\n\014AESKeyLength\022\013\n\007AES_128\020\000\022"
  "\013\n\007AES_192\020\001\022\013\n\007AES_256\020\0022\231\021\n\rCryptoServ"
  "ice\0226\n\nbootSystem\022\031.crypto.BootSystemReq"
  "uest\032\r.crypto.Empty\0227\n\013addProccess\022\031.cry"
  "pto.AddProcessRequest\032\r.crypto.Empty\0224\n\t"
  "configure\022\030.crypto.ConfigureRequest\032\r.cr"
  "ypto.Empty\022O\n\016generateAESKey\022\035.crypto.Ge"
  "nerateAESKeyRequest\032\036.crypto.GenerateAES"
  "KeyResponse\022U\n\022generateRSAKeyPair\022\036.cryp"
  "to.GenerateKeyPairRequest\032\037.crypto.Gener"
  "ateKeyPairResponse\022U\n\022generateECCKeyPair"
  "\022\036.crypto.GenerateKeyPairRequest\032\037.crypt"
  "o.GenerateKeyPairResponse\022N\n\023getSignedDa"
  "taLength\022\034.crypto.GetHashLengthRequest\032\031"
  ".crypto.GetLengthResponse\022L\n\025getECCencry"
  "ptedLength\022\030.crypto.GetLengthRequest\032\031.c"
  "rypto.GetLengthResponse\022L\n\025getECCDecrypt"
  "edLength\022\030.crypto.GetLengthRequest\032\031.cry"
  "pto.GetLengthResponse\022L\n\025getRSAencrypted"
  "Length\022\030.crypto.GetLengthRequest\032\031.crypt"
  "o.GetLengthResponse\022L\n\025getRSAdecryptedLe"
  "ngth\022\030.crypto.GetLengthRequest\032\031.crypto."
  "GetLengthResponse\022O\n\025getAESencryptedLeng"
  "th\022\033.crypto.GetAESLengthRequest\032\031.crypto"
  ".GetLengthResponse\022O\n\025getAESdecryptedLen"
  "gth\022\033.crypto.GetAESLengthRequest\032\031.crypt"
  "o.GetLengthResponse\022D\n\017getEncryptedLen\022\026"
  ".crypto.GetWholeLength\032\031.crypto.GetLengt"
  "hResponse\022D\n\017getDecryptedLen\022\026.crypto.Ge"
  "tWholeLength\032\031.crypto.GetLengthResponse\022"
  "1\n\004sign\022\023.crypto.SignRequest\032\024.crypto.Si"
  "gnResponse\0227\n\006verify\022\025.crypto.VerifyRequ"
  "est\032\026.crypto.VerifyResponse\022B\n\027getPublic"
  "ECCKeyByUserId\022\022.crypto.KeyRequest\032\023.cry"
  "pto.KeyResponse\022B\n\027getPublicRSAKeyByUser"
  "Id\022\022.crypto.KeyRequest\032\023.crypto.KeyRespo"
  "nse\022O\n\nECCencrypt\022\037.crypto.AsymetricEncr"
  "yptRequest\032 .crypto.AsymetricEncryptResp"
  "onse\022O\n\nECCdecrypt\022\037.crypto.AsymetricDec"
  "ryptRequest\032 .crypto.AsymetricDecryptRes"
  "ponse\022O\n\nRSAencrypt\022\037.crypto.AsymetricEn"
  "cryptRequest\032 .crypto.AsymetricEncryptRe"
  "sponse\022O\n\nRSAdecrypt\022\037.crypto.AsymetricD"
  "ecryptRequest\032 .crypto.AsymetricDecryptR"
  "esponse\022C\n\nAESencrypt\022\031.crypto.AESEncryp"
  "tRequest\032\032.crypto.AESEncryptResponse\022C\n\n"
  "AESdecrypt\022\031.crypto.AESDecryptRequest\032\032."
  "crypto.AESDecryptResponse\022:\n\007encrypt\022\026.c"
  "rypto.EncryptRequest\032\027.crypto.EncryptRes"
  "ponse\022:\n\007decrypt\022\026.crypto.DecryptRequest"
  "\032\027.crypto.DecryptResponse\0227\n\nsignUpdate\022"
  "\023.crypto.SignRequest\032\024.crypto.SignRespon"
  "se\0229\n\014signFinalize\022\023.crypto.SignRequest\032"
  "\024.crypto.SignResponse\022=\n\014verifyUpdate\022\025."
  "crypto.VerifyRequest\032\026.crypto.VerifyResp"
  "onse\022\?\n\016verifyFinalize\022\025.crypto.VerifyRe"
  "quest\032\026.crypto.VerifyResponseb\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_proto_2fencryption_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fencryption_2eproto = {
  false, false, 5397, descriptor_table_protodef_proto_2fencryption_2eproto, "proto/encryption.proto", 
  &descriptor_table_proto_2fencryption_2eproto_once, nullptr, 0, 33,
  schemas, file_default_instances, TableStruct_proto_2fencryption_2eproto::offsets,
  file_level_metadata_proto_2fencryption_2eproto, file_level_enum_descriptors_proto_2fencryption_2eproto, file_level_service_descriptors_proto_2fencryption_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_proto_2fencryption_2eproto_getter() {
  return &descriptor_table_proto_2fencryption_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_proto_2fencryption_2eproto(&descriptor_table_proto_2fencryption_2eproto);
namespace crypto {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyPermission_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fencryption_2eproto);
  return file_level_enum_descriptors_proto_2fencryption_2eproto[0];
}
bool KeyPermission_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AESChainingMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fencryption_2eproto);
  return file_level_enum_descriptors_proto_2fencryption_2eproto[1];
}
bool AESChainingMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsymmetricFunction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fencryption_2eproto);
  return file_level_enum_descriptors_proto_2fencryption_2eproto[2];
}
bool AsymmetricFunction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SHAAlgorithm_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fencryption_2eproto);
  return file_level_enum_descriptors_proto_2fencryption_2eproto[3];
}
bool SHAAlgorithm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AESKeyLength_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fencryption_2eproto);
  return file_level_enum_descriptors_proto_2fencryption_2eproto[4];
}
bool AESKeyLength_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class AsymetricEncryptRequest::_Internal {
 public:
};

AsymetricEncryptRequest::AsymetricEncryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AsymetricEncryptRequest)
}
AsymetricEncryptRequest::AsymetricEncryptRequest(const AsymetricEncryptRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_keyid().empty()) {
    keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_keyid(), 
      GetArenaForAllocation());
  }
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data().empty()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  senderid_ = from.senderid_;
  // @@protoc_insertion_point(copy_constructor:crypto.AsymetricEncryptRequest)
}

void AsymetricEncryptRequest::SharedCtor() {
keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
senderid_ = 0;
}

AsymetricEncryptRequest::~AsymetricEncryptRequest() {
  // @@protoc_insertion_point(destructor:crypto.AsymetricEncryptRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AsymetricEncryptRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  keyid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AsymetricEncryptRequest::ArenaDtor(void* object) {
  AsymetricEncryptRequest* _this = reinterpret_cast< AsymetricEncryptRequest* >(object);
  (void)_this;
}
void AsymetricEncryptRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AsymetricEncryptRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AsymetricEncryptRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AsymetricEncryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  keyid_.ClearToEmpty();
  data_.ClearToEmpty();
  senderid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AsymetricEncryptRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string keyId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_keyid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.AsymetricEncryptRequest.keyId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AsymetricEncryptRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AsymetricEncryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // string keyId = 2;
  if (!this->_internal_keyid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_keyid().data(), static_cast<int>(this->_internal_keyid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.AsymetricEncryptRequest.keyId");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_keyid(), target);
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AsymetricEncryptRequest)
  return target;
}

size_t AsymetricEncryptRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AsymetricEncryptRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string keyId = 2;
  if (!this->_internal_keyid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_keyid());
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AsymetricEncryptRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AsymetricEncryptRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AsymetricEncryptRequest::GetClassData() const { return &_class_data_; }

void AsymetricEncryptRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AsymetricEncryptRequest *>(to)->MergeFrom(
      static_cast<const AsymetricEncryptRequest &>(from));
}


void AsymetricEncryptRequest::MergeFrom(const AsymetricEncryptRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AsymetricEncryptRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_keyid().empty()) {
    _internal_set_keyid(from._internal_keyid());
  }
  if (!from._internal_data().empty()) {
    _internal_set_data(from._internal_data());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AsymetricEncryptRequest::CopyFrom(const AsymetricEncryptRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AsymetricEncryptRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymetricEncryptRequest::IsInitialized() const {
  return true;
}

void AsymetricEncryptRequest::InternalSwap(AsymetricEncryptRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &keyid_, lhs_arena,
      &other->keyid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  swap(senderid_, other->senderid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AsymetricEncryptRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[0]);
}

// ===================================================================

class AsymetricEncryptResponse::_Internal {
 public:
};

AsymetricEncryptResponse::AsymetricEncryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AsymetricEncryptResponse)
}
AsymetricEncryptResponse::AsymetricEncryptResponse(const AsymetricEncryptResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  encrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_encrypted_data().empty()) {
    encrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encrypted_data(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.AsymetricEncryptResponse)
}

void AsymetricEncryptResponse::SharedCtor() {
encrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

AsymetricEncryptResponse::~AsymetricEncryptResponse() {
  // @@protoc_insertion_point(destructor:crypto.AsymetricEncryptResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AsymetricEncryptResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encrypted_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AsymetricEncryptResponse::ArenaDtor(void* object) {
  AsymetricEncryptResponse* _this = reinterpret_cast< AsymetricEncryptResponse* >(object);
  (void)_this;
}
void AsymetricEncryptResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AsymetricEncryptResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AsymetricEncryptResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AsymetricEncryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  encrypted_data_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AsymetricEncryptResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes encrypted_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_encrypted_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AsymetricEncryptResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AsymetricEncryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes encrypted_data = 1;
  if (!this->_internal_encrypted_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_encrypted_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AsymetricEncryptResponse)
  return target;
}

size_t AsymetricEncryptResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AsymetricEncryptResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes encrypted_data = 1;
  if (!this->_internal_encrypted_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encrypted_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AsymetricEncryptResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AsymetricEncryptResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AsymetricEncryptResponse::GetClassData() const { return &_class_data_; }

void AsymetricEncryptResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AsymetricEncryptResponse *>(to)->MergeFrom(
      static_cast<const AsymetricEncryptResponse &>(from));
}


void AsymetricEncryptResponse::MergeFrom(const AsymetricEncryptResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AsymetricEncryptResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_encrypted_data().empty()) {
    _internal_set_encrypted_data(from._internal_encrypted_data());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AsymetricEncryptResponse::CopyFrom(const AsymetricEncryptResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AsymetricEncryptResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymetricEncryptResponse::IsInitialized() const {
  return true;
}

void AsymetricEncryptResponse::InternalSwap(AsymetricEncryptResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encrypted_data_, lhs_arena,
      &other->encrypted_data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AsymetricEncryptResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[1]);
}

// ===================================================================

class AsymetricDecryptRequest::_Internal {
 public:
};

AsymetricDecryptRequest::AsymetricDecryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AsymetricDecryptRequest)
}
AsymetricDecryptRequest::AsymetricDecryptRequest(const AsymetricDecryptRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_keyid().empty()) {
    keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_keyid(), 
      GetArenaForAllocation());
  }
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data().empty()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  receiverid_ = from.receiverid_;
  // @@protoc_insertion_point(copy_constructor:crypto.AsymetricDecryptRequest)
}

void AsymetricDecryptRequest::SharedCtor() {
keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
receiverid_ = 0;
}

AsymetricDecryptRequest::~AsymetricDecryptRequest() {
  // @@protoc_insertion_point(destructor:crypto.AsymetricDecryptRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AsymetricDecryptRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  keyid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AsymetricDecryptRequest::ArenaDtor(void* object) {
  AsymetricDecryptRequest* _this = reinterpret_cast< AsymetricDecryptRequest* >(object);
  (void)_this;
}
void AsymetricDecryptRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AsymetricDecryptRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AsymetricDecryptRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AsymetricDecryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  keyid_.ClearToEmpty();
  data_.ClearToEmpty();
  receiverid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AsymetricDecryptRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 receiverId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          receiverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string keyId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_keyid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.AsymetricDecryptRequest.keyId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AsymetricDecryptRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AsymetricDecryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 receiverId = 1;
  if (this->_internal_receiverid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_receiverid(), target);
  }

  // string keyId = 2;
  if (!this->_internal_keyid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_keyid().data(), static_cast<int>(this->_internal_keyid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.AsymetricDecryptRequest.keyId");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_keyid(), target);
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AsymetricDecryptRequest)
  return target;
}

size_t AsymetricDecryptRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AsymetricDecryptRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string keyId = 2;
  if (!this->_internal_keyid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_keyid());
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // int32 receiverId = 1;
  if (this->_internal_receiverid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiverid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AsymetricDecryptRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AsymetricDecryptRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AsymetricDecryptRequest::GetClassData() const { return &_class_data_; }

void AsymetricDecryptRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AsymetricDecryptRequest *>(to)->MergeFrom(
      static_cast<const AsymetricDecryptRequest &>(from));
}


void AsymetricDecryptRequest::MergeFrom(const AsymetricDecryptRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AsymetricDecryptRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_keyid().empty()) {
    _internal_set_keyid(from._internal_keyid());
  }
  if (!from._internal_data().empty()) {
    _internal_set_data(from._internal_data());
  }
  if (from._internal_receiverid() != 0) {
    _internal_set_receiverid(from._internal_receiverid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AsymetricDecryptRequest::CopyFrom(const AsymetricDecryptRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AsymetricDecryptRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymetricDecryptRequest::IsInitialized() const {
  return true;
}

void AsymetricDecryptRequest::InternalSwap(AsymetricDecryptRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &keyid_, lhs_arena,
      &other->keyid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  swap(receiverid_, other->receiverid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AsymetricDecryptRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[2]);
}

// ===================================================================

class GetHashLengthRequest::_Internal {
 public:
};

GetHashLengthRequest::GetHashLengthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GetHashLengthRequest)
}
GetHashLengthRequest::GetHashLengthRequest(const GetHashLengthRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&func_, &from.func_,
    static_cast<size_t>(reinterpret_cast<char*>(&datalen_) -
    reinterpret_cast<char*>(&func_)) + sizeof(datalen_));
  // @@protoc_insertion_point(copy_constructor:crypto.GetHashLengthRequest)
}

void GetHashLengthRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&func_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&datalen_) -
    reinterpret_cast<char*>(&func_)) + sizeof(datalen_));
}

GetHashLengthRequest::~GetHashLengthRequest() {
  // @@protoc_insertion_point(destructor:crypto.GetHashLengthRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetHashLengthRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetHashLengthRequest::ArenaDtor(void* object) {
  GetHashLengthRequest* _this = reinterpret_cast< GetHashLengthRequest* >(object);
  (void)_this;
}
void GetHashLengthRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetHashLengthRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetHashLengthRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GetHashLengthRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&func_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&datalen_) -
      reinterpret_cast<char*>(&func_)) + sizeof(datalen_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetHashLengthRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .crypto.SHAAlgorithm func = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_func(static_cast<::crypto::SHAAlgorithm>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 dataLen = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          datalen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetHashLengthRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GetHashLengthRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .crypto.SHAAlgorithm func = 1;
  if (this->_internal_func() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_func(), target);
  }

  // int32 dataLen = 2;
  if (this->_internal_datalen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_datalen(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GetHashLengthRequest)
  return target;
}

size_t GetHashLengthRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GetHashLengthRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .crypto.SHAAlgorithm func = 1;
  if (this->_internal_func() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_func());
  }

  // int32 dataLen = 2;
  if (this->_internal_datalen() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_datalen());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetHashLengthRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetHashLengthRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetHashLengthRequest::GetClassData() const { return &_class_data_; }

void GetHashLengthRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetHashLengthRequest *>(to)->MergeFrom(
      static_cast<const GetHashLengthRequest &>(from));
}


void GetHashLengthRequest::MergeFrom(const GetHashLengthRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GetHashLengthRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_func() != 0) {
    _internal_set_func(from._internal_func());
  }
  if (from._internal_datalen() != 0) {
    _internal_set_datalen(from._internal_datalen());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetHashLengthRequest::CopyFrom(const GetHashLengthRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GetHashLengthRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetHashLengthRequest::IsInitialized() const {
  return true;
}

void GetHashLengthRequest::InternalSwap(GetHashLengthRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetHashLengthRequest, datalen_)
      + sizeof(GetHashLengthRequest::datalen_)
      - PROTOBUF_FIELD_OFFSET(GetHashLengthRequest, func_)>(
          reinterpret_cast<char*>(&func_),
          reinterpret_cast<char*>(&other->func_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetHashLengthRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[3]);
}

// ===================================================================

class GetAESLengthRequest::_Internal {
 public:
};

GetAESLengthRequest::GetAESLengthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GetAESLengthRequest)
}
GetAESLengthRequest::GetAESLengthRequest(const GetAESLengthRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&datalen_, &from.datalen_,
    static_cast<size_t>(reinterpret_cast<char*>(&chainingmode_) -
    reinterpret_cast<char*>(&datalen_)) + sizeof(chainingmode_));
  // @@protoc_insertion_point(copy_constructor:crypto.GetAESLengthRequest)
}

void GetAESLengthRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&datalen_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&chainingmode_) -
    reinterpret_cast<char*>(&datalen_)) + sizeof(chainingmode_));
}

GetAESLengthRequest::~GetAESLengthRequest() {
  // @@protoc_insertion_point(destructor:crypto.GetAESLengthRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetAESLengthRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetAESLengthRequest::ArenaDtor(void* object) {
  GetAESLengthRequest* _this = reinterpret_cast< GetAESLengthRequest* >(object);
  (void)_this;
}
void GetAESLengthRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetAESLengthRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetAESLengthRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GetAESLengthRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&datalen_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&chainingmode_) -
      reinterpret_cast<char*>(&datalen_)) + sizeof(chainingmode_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetAESLengthRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 dataLen = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          datalen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isFirst = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          isfirst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESChainingMode chainingMode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_chainingmode(static_cast<::crypto::AESChainingMode>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetAESLengthRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GetAESLengthRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 dataLen = 1;
  if (this->_internal_datalen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_datalen(), target);
  }

  // bool isFirst = 2;
  if (this->_internal_isfirst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_isfirst(), target);
  }

  // .crypto.AESChainingMode chainingMode = 3;
  if (this->_internal_chainingmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_chainingmode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GetAESLengthRequest)
  return target;
}

size_t GetAESLengthRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GetAESLengthRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 dataLen = 1;
  if (this->_internal_datalen() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_datalen());
  }

  // bool isFirst = 2;
  if (this->_internal_isfirst() != 0) {
    total_size += 1 + 1;
  }

  // .crypto.AESChainingMode chainingMode = 3;
  if (this->_internal_chainingmode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_chainingmode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetAESLengthRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetAESLengthRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetAESLengthRequest::GetClassData() const { return &_class_data_; }

void GetAESLengthRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetAESLengthRequest *>(to)->MergeFrom(
      static_cast<const GetAESLengthRequest &>(from));
}


void GetAESLengthRequest::MergeFrom(const GetAESLengthRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GetAESLengthRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_datalen() != 0) {
    _internal_set_datalen(from._internal_datalen());
  }
  if (from._internal_isfirst() != 0) {
    _internal_set_isfirst(from._internal_isfirst());
  }
  if (from._internal_chainingmode() != 0) {
    _internal_set_chainingmode(from._internal_chainingmode());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetAESLengthRequest::CopyFrom(const GetAESLengthRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GetAESLengthRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAESLengthRequest::IsInitialized() const {
  return true;
}

void GetAESLengthRequest::InternalSwap(GetAESLengthRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetAESLengthRequest, chainingmode_)
      + sizeof(GetAESLengthRequest::chainingmode_)
      - PROTOBUF_FIELD_OFFSET(GetAESLengthRequest, datalen_)>(
          reinterpret_cast<char*>(&datalen_),
          reinterpret_cast<char*>(&other->datalen_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetAESLengthRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[4]);
}

// ===================================================================

class AsymetricDecryptResponse::_Internal {
 public:
};

AsymetricDecryptResponse::AsymetricDecryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AsymetricDecryptResponse)
}
AsymetricDecryptResponse::AsymetricDecryptResponse(const AsymetricDecryptResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  decrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_decrypted_data().empty()) {
    decrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_decrypted_data(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.AsymetricDecryptResponse)
}

void AsymetricDecryptResponse::SharedCtor() {
decrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

AsymetricDecryptResponse::~AsymetricDecryptResponse() {
  // @@protoc_insertion_point(destructor:crypto.AsymetricDecryptResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AsymetricDecryptResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  decrypted_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AsymetricDecryptResponse::ArenaDtor(void* object) {
  AsymetricDecryptResponse* _this = reinterpret_cast< AsymetricDecryptResponse* >(object);
  (void)_this;
}
void AsymetricDecryptResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AsymetricDecryptResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AsymetricDecryptResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AsymetricDecryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  decrypted_data_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AsymetricDecryptResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes decrypted_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_decrypted_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AsymetricDecryptResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AsymetricDecryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes decrypted_data = 1;
  if (!this->_internal_decrypted_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_decrypted_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AsymetricDecryptResponse)
  return target;
}

size_t AsymetricDecryptResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AsymetricDecryptResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes decrypted_data = 1;
  if (!this->_internal_decrypted_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_decrypted_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AsymetricDecryptResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AsymetricDecryptResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AsymetricDecryptResponse::GetClassData() const { return &_class_data_; }

void AsymetricDecryptResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AsymetricDecryptResponse *>(to)->MergeFrom(
      static_cast<const AsymetricDecryptResponse &>(from));
}


void AsymetricDecryptResponse::MergeFrom(const AsymetricDecryptResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AsymetricDecryptResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_decrypted_data().empty()) {
    _internal_set_decrypted_data(from._internal_decrypted_data());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AsymetricDecryptResponse::CopyFrom(const AsymetricDecryptResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AsymetricDecryptResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymetricDecryptResponse::IsInitialized() const {
  return true;
}

void AsymetricDecryptResponse::InternalSwap(AsymetricDecryptResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &decrypted_data_, lhs_arena,
      &other->decrypted_data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AsymetricDecryptResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[5]);
}

// ===================================================================

class GetLengthRequest::_Internal {
 public:
};

GetLengthRequest::GetLengthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GetLengthRequest)
}
GetLengthRequest::GetLengthRequest(const GetLengthRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  in_len_ = from.in_len_;
  // @@protoc_insertion_point(copy_constructor:crypto.GetLengthRequest)
}

void GetLengthRequest::SharedCtor() {
in_len_ = 0;
}

GetLengthRequest::~GetLengthRequest() {
  // @@protoc_insertion_point(destructor:crypto.GetLengthRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetLengthRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetLengthRequest::ArenaDtor(void* object) {
  GetLengthRequest* _this = reinterpret_cast< GetLengthRequest* >(object);
  (void)_this;
}
void GetLengthRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetLengthRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetLengthRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GetLengthRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  in_len_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetLengthRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 in_len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          in_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetLengthRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GetLengthRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 in_len = 1;
  if (this->_internal_in_len() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_in_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GetLengthRequest)
  return target;
}

size_t GetLengthRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GetLengthRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 in_len = 1;
  if (this->_internal_in_len() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_in_len());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetLengthRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetLengthRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetLengthRequest::GetClassData() const { return &_class_data_; }

void GetLengthRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetLengthRequest *>(to)->MergeFrom(
      static_cast<const GetLengthRequest &>(from));
}


void GetLengthRequest::MergeFrom(const GetLengthRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GetLengthRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_in_len() != 0) {
    _internal_set_in_len(from._internal_in_len());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetLengthRequest::CopyFrom(const GetLengthRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GetLengthRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetLengthRequest::IsInitialized() const {
  return true;
}

void GetLengthRequest::InternalSwap(GetLengthRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(in_len_, other->in_len_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetLengthRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[6]);
}

// ===================================================================

class GetLengthResponse::_Internal {
 public:
};

GetLengthResponse::GetLengthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GetLengthResponse)
}
GetLengthResponse::GetLengthResponse(const GetLengthResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  len_ = from.len_;
  // @@protoc_insertion_point(copy_constructor:crypto.GetLengthResponse)
}

void GetLengthResponse::SharedCtor() {
len_ = 0;
}

GetLengthResponse::~GetLengthResponse() {
  // @@protoc_insertion_point(destructor:crypto.GetLengthResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetLengthResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetLengthResponse::ArenaDtor(void* object) {
  GetLengthResponse* _this = reinterpret_cast< GetLengthResponse* >(object);
  (void)_this;
}
void GetLengthResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetLengthResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetLengthResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GetLengthResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  len_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetLengthResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 len = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetLengthResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GetLengthResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 len = 1;
  if (this->_internal_len() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_len(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GetLengthResponse)
  return target;
}

size_t GetLengthResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GetLengthResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 len = 1;
  if (this->_internal_len() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_len());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetLengthResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetLengthResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetLengthResponse::GetClassData() const { return &_class_data_; }

void GetLengthResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetLengthResponse *>(to)->MergeFrom(
      static_cast<const GetLengthResponse &>(from));
}


void GetLengthResponse::MergeFrom(const GetLengthResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GetLengthResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_len() != 0) {
    _internal_set_len(from._internal_len());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetLengthResponse::CopyFrom(const GetLengthResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GetLengthResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetLengthResponse::IsInitialized() const {
  return true;
}

void GetLengthResponse::InternalSwap(GetLengthResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(len_, other->len_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetLengthResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[7]);
}

// ===================================================================

class GetWholeLength::_Internal {
 public:
};

GetWholeLength::GetWholeLength(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GetWholeLength)
}
GetWholeLength::GetWholeLength(const GetWholeLength& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&senderid_, &from.senderid_,
    static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(isfirst_));
  // @@protoc_insertion_point(copy_constructor:crypto.GetWholeLength)
}

void GetWholeLength::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&senderid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(isfirst_));
}

GetWholeLength::~GetWholeLength() {
  // @@protoc_insertion_point(destructor:crypto.GetWholeLength)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetWholeLength::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetWholeLength::ArenaDtor(void* object) {
  GetWholeLength* _this = reinterpret_cast< GetWholeLength* >(object);
  (void)_this;
}
void GetWholeLength::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetWholeLength::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetWholeLength::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GetWholeLength)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&senderid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isfirst_) -
      reinterpret_cast<char*>(&senderid_)) + sizeof(isfirst_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetWholeLength::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 inLen = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          inlen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isFirst = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          isfirst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetWholeLength::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GetWholeLength)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // int32 inLen = 2;
  if (this->_internal_inlen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_inlen(), target);
  }

  // bool isFirst = 3;
  if (this->_internal_isfirst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_isfirst(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GetWholeLength)
  return target;
}

size_t GetWholeLength::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GetWholeLength)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  // int32 inLen = 2;
  if (this->_internal_inlen() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_inlen());
  }

  // bool isFirst = 3;
  if (this->_internal_isfirst() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetWholeLength::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetWholeLength::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetWholeLength::GetClassData() const { return &_class_data_; }

void GetWholeLength::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetWholeLength *>(to)->MergeFrom(
      static_cast<const GetWholeLength &>(from));
}


void GetWholeLength::MergeFrom(const GetWholeLength& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GetWholeLength)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  if (from._internal_inlen() != 0) {
    _internal_set_inlen(from._internal_inlen());
  }
  if (from._internal_isfirst() != 0) {
    _internal_set_isfirst(from._internal_isfirst());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetWholeLength::CopyFrom(const GetWholeLength& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GetWholeLength)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetWholeLength::IsInitialized() const {
  return true;
}

void GetWholeLength::InternalSwap(GetWholeLength* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetWholeLength, isfirst_)
      + sizeof(GetWholeLength::isfirst_)
      - PROTOBUF_FIELD_OFFSET(GetWholeLength, senderid_)>(
          reinterpret_cast<char*>(&senderid_),
          reinterpret_cast<char*>(&other->senderid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetWholeLength::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[8]);
}

// ===================================================================

class GenerateAESKeyRequest::_Internal {
 public:
};

GenerateAESKeyRequest::GenerateAESKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  permissions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GenerateAESKeyRequest)
}
GenerateAESKeyRequest::GenerateAESKeyRequest(const GenerateAESKeyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      permissions_(from.permissions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&user_id_, &from.user_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&destuserid_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(destuserid_));
  // @@protoc_insertion_point(copy_constructor:crypto.GenerateAESKeyRequest)
}

void GenerateAESKeyRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&user_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&destuserid_) -
    reinterpret_cast<char*>(&user_id_)) + sizeof(destuserid_));
}

GenerateAESKeyRequest::~GenerateAESKeyRequest() {
  // @@protoc_insertion_point(destructor:crypto.GenerateAESKeyRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GenerateAESKeyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GenerateAESKeyRequest::ArenaDtor(void* object) {
  GenerateAESKeyRequest* _this = reinterpret_cast< GenerateAESKeyRequest* >(object);
  (void)_this;
}
void GenerateAESKeyRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GenerateAESKeyRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenerateAESKeyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GenerateAESKeyRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permissions_.Clear();
  ::memset(&user_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&destuserid_) -
      reinterpret_cast<char*>(&user_id_)) + sizeof(destuserid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GenerateAESKeyRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .crypto.KeyPermission permissions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_permissions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_permissions(static_cast<::crypto::KeyPermission>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESKeyLength keyLength = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_keylength(static_cast<::crypto::AESKeyLength>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 destUserId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          destuserid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GenerateAESKeyRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GenerateAESKeyRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_user_id(), target);
  }

  // repeated .crypto.KeyPermission permissions = 2;
  {
    int byte_size = _permissions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, permissions_, byte_size, target);
    }
  }

  // .crypto.AESKeyLength keyLength = 3;
  if (this->_internal_keylength() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_keylength(), target);
  }

  // int32 destUserId = 4;
  if (this->_internal_destuserid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_destuserid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GenerateAESKeyRequest)
  return target;
}

size_t GenerateAESKeyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GenerateAESKeyRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .crypto.KeyPermission permissions = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_permissions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_permissions(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _permissions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_user_id());
  }

  // .crypto.AESKeyLength keyLength = 3;
  if (this->_internal_keylength() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_keylength());
  }

  // int32 destUserId = 4;
  if (this->_internal_destuserid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_destuserid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GenerateAESKeyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GenerateAESKeyRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GenerateAESKeyRequest::GetClassData() const { return &_class_data_; }

void GenerateAESKeyRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GenerateAESKeyRequest *>(to)->MergeFrom(
      static_cast<const GenerateAESKeyRequest &>(from));
}


void GenerateAESKeyRequest::MergeFrom(const GenerateAESKeyRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GenerateAESKeyRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permissions_.MergeFrom(from.permissions_);
  if (from._internal_user_id() != 0) {
    _internal_set_user_id(from._internal_user_id());
  }
  if (from._internal_keylength() != 0) {
    _internal_set_keylength(from._internal_keylength());
  }
  if (from._internal_destuserid() != 0) {
    _internal_set_destuserid(from._internal_destuserid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GenerateAESKeyRequest::CopyFrom(const GenerateAESKeyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GenerateAESKeyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenerateAESKeyRequest::IsInitialized() const {
  return true;
}

void GenerateAESKeyRequest::InternalSwap(GenerateAESKeyRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  permissions_.InternalSwap(&other->permissions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GenerateAESKeyRequest, destuserid_)
      + sizeof(GenerateAESKeyRequest::destuserid_)
      - PROTOBUF_FIELD_OFFSET(GenerateAESKeyRequest, user_id_)>(
          reinterpret_cast<char*>(&user_id_),
          reinterpret_cast<char*>(&other->user_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GenerateAESKeyRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[9]);
}

// ===================================================================

class GenerateAESKeyResponse::_Internal {
 public:
};

GenerateAESKeyResponse::GenerateAESKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GenerateAESKeyResponse)
}
GenerateAESKeyResponse::GenerateAESKeyResponse(const GenerateAESKeyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  aes_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_aes_key().empty()) {
    aes_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_aes_key(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.GenerateAESKeyResponse)
}

void GenerateAESKeyResponse::SharedCtor() {
aes_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

GenerateAESKeyResponse::~GenerateAESKeyResponse() {
  // @@protoc_insertion_point(destructor:crypto.GenerateAESKeyResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GenerateAESKeyResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  aes_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GenerateAESKeyResponse::ArenaDtor(void* object) {
  GenerateAESKeyResponse* _this = reinterpret_cast< GenerateAESKeyResponse* >(object);
  (void)_this;
}
void GenerateAESKeyResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GenerateAESKeyResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenerateAESKeyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GenerateAESKeyResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  aes_key_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GenerateAESKeyResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string aes_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_aes_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.GenerateAESKeyResponse.aes_key"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GenerateAESKeyResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GenerateAESKeyResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string aes_key = 1;
  if (!this->_internal_aes_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_aes_key().data(), static_cast<int>(this->_internal_aes_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.GenerateAESKeyResponse.aes_key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_aes_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GenerateAESKeyResponse)
  return target;
}

size_t GenerateAESKeyResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GenerateAESKeyResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string aes_key = 1;
  if (!this->_internal_aes_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_aes_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GenerateAESKeyResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GenerateAESKeyResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GenerateAESKeyResponse::GetClassData() const { return &_class_data_; }

void GenerateAESKeyResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GenerateAESKeyResponse *>(to)->MergeFrom(
      static_cast<const GenerateAESKeyResponse &>(from));
}


void GenerateAESKeyResponse::MergeFrom(const GenerateAESKeyResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GenerateAESKeyResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_aes_key().empty()) {
    _internal_set_aes_key(from._internal_aes_key());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GenerateAESKeyResponse::CopyFrom(const GenerateAESKeyResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GenerateAESKeyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenerateAESKeyResponse::IsInitialized() const {
  return true;
}

void GenerateAESKeyResponse::InternalSwap(GenerateAESKeyResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &aes_key_, lhs_arena,
      &other->aes_key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GenerateAESKeyResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[10]);
}

// ===================================================================

class GenerateKeyPairRequest::_Internal {
 public:
};

GenerateKeyPairRequest::GenerateKeyPairRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  permissions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GenerateKeyPairRequest)
}
GenerateKeyPairRequest::GenerateKeyPairRequest(const GenerateKeyPairRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      permissions_(from.permissions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:crypto.GenerateKeyPairRequest)
}

void GenerateKeyPairRequest::SharedCtor() {
user_id_ = 0;
}

GenerateKeyPairRequest::~GenerateKeyPairRequest() {
  // @@protoc_insertion_point(destructor:crypto.GenerateKeyPairRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GenerateKeyPairRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GenerateKeyPairRequest::ArenaDtor(void* object) {
  GenerateKeyPairRequest* _this = reinterpret_cast< GenerateKeyPairRequest* >(object);
  (void)_this;
}
void GenerateKeyPairRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GenerateKeyPairRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenerateKeyPairRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GenerateKeyPairRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permissions_.Clear();
  user_id_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GenerateKeyPairRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .crypto.KeyPermission permissions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_permissions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_permissions(static_cast<::crypto::KeyPermission>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GenerateKeyPairRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GenerateKeyPairRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_user_id(), target);
  }

  // repeated .crypto.KeyPermission permissions = 2;
  {
    int byte_size = _permissions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, permissions_, byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GenerateKeyPairRequest)
  return target;
}

size_t GenerateKeyPairRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GenerateKeyPairRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .crypto.KeyPermission permissions = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_permissions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_permissions(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _permissions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_user_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GenerateKeyPairRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GenerateKeyPairRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GenerateKeyPairRequest::GetClassData() const { return &_class_data_; }

void GenerateKeyPairRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GenerateKeyPairRequest *>(to)->MergeFrom(
      static_cast<const GenerateKeyPairRequest &>(from));
}


void GenerateKeyPairRequest::MergeFrom(const GenerateKeyPairRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GenerateKeyPairRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permissions_.MergeFrom(from.permissions_);
  if (from._internal_user_id() != 0) {
    _internal_set_user_id(from._internal_user_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GenerateKeyPairRequest::CopyFrom(const GenerateKeyPairRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GenerateKeyPairRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenerateKeyPairRequest::IsInitialized() const {
  return true;
}

void GenerateKeyPairRequest::InternalSwap(GenerateKeyPairRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  permissions_.InternalSwap(&other->permissions_);
  swap(user_id_, other->user_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GenerateKeyPairRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[11]);
}

// ===================================================================

class GenerateKeyPairResponse::_Internal {
 public:
};

GenerateKeyPairResponse::GenerateKeyPairResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GenerateKeyPairResponse)
}
GenerateKeyPairResponse::GenerateKeyPairResponse(const GenerateKeyPairResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  public_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_public_key().empty()) {
    public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_public_key(), 
      GetArenaForAllocation());
  }
  private_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_private_key().empty()) {
    private_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_private_key(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.GenerateKeyPairResponse)
}

void GenerateKeyPairResponse::SharedCtor() {
public_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
private_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

GenerateKeyPairResponse::~GenerateKeyPairResponse() {
  // @@protoc_insertion_point(destructor:crypto.GenerateKeyPairResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GenerateKeyPairResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  public_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  private_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GenerateKeyPairResponse::ArenaDtor(void* object) {
  GenerateKeyPairResponse* _this = reinterpret_cast< GenerateKeyPairResponse* >(object);
  (void)_this;
}
void GenerateKeyPairResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GenerateKeyPairResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenerateKeyPairResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GenerateKeyPairResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  public_key_.ClearToEmpty();
  private_key_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GenerateKeyPairResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string public_key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_public_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.GenerateKeyPairResponse.public_key"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string private_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_private_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.GenerateKeyPairResponse.private_key"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GenerateKeyPairResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GenerateKeyPairResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string public_key = 1;
  if (!this->_internal_public_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_public_key().data(), static_cast<int>(this->_internal_public_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.GenerateKeyPairResponse.public_key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_public_key(), target);
  }

  // string private_key = 2;
  if (!this->_internal_private_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_private_key().data(), static_cast<int>(this->_internal_private_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.GenerateKeyPairResponse.private_key");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_private_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GenerateKeyPairResponse)
  return target;
}

size_t GenerateKeyPairResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GenerateKeyPairResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string public_key = 1;
  if (!this->_internal_public_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_public_key());
  }

  // string private_key = 2;
  if (!this->_internal_private_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_private_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GenerateKeyPairResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GenerateKeyPairResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GenerateKeyPairResponse::GetClassData() const { return &_class_data_; }

void GenerateKeyPairResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GenerateKeyPairResponse *>(to)->MergeFrom(
      static_cast<const GenerateKeyPairResponse &>(from));
}


void GenerateKeyPairResponse::MergeFrom(const GenerateKeyPairResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GenerateKeyPairResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_public_key().empty()) {
    _internal_set_public_key(from._internal_public_key());
  }
  if (!from._internal_private_key().empty()) {
    _internal_set_private_key(from._internal_private_key());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GenerateKeyPairResponse::CopyFrom(const GenerateKeyPairResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GenerateKeyPairResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenerateKeyPairResponse::IsInitialized() const {
  return true;
}

void GenerateKeyPairResponse::InternalSwap(GenerateKeyPairResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &public_key_, lhs_arena,
      &other->public_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &private_key_, lhs_arena,
      &other->private_key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GenerateKeyPairResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[12]);
}

// ===================================================================

class SignRequest::_Internal {
 public:
};

SignRequest::SignRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.SignRequest)
}
SignRequest::SignRequest(const SignRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data().empty()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  key_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_key_id().empty()) {
    key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&sender_id_, &from.sender_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&counter_) -
    reinterpret_cast<char*>(&sender_id_)) + sizeof(counter_));
  // @@protoc_insertion_point(copy_constructor:crypto.SignRequest)
}

void SignRequest::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
key_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sender_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&counter_) -
    reinterpret_cast<char*>(&sender_id_)) + sizeof(counter_));
}

SignRequest::~SignRequest() {
  // @@protoc_insertion_point(destructor:crypto.SignRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SignRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SignRequest::ArenaDtor(void* object) {
  SignRequest* _this = reinterpret_cast< SignRequest* >(object);
  (void)_this;
}
void SignRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SignRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SignRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.SignRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.ClearToEmpty();
  key_id_.ClearToEmpty();
  ::memset(&sender_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&counter_) -
      reinterpret_cast<char*>(&sender_id_)) + sizeof(counter_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 sender_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          sender_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.SHAAlgorithm hash_func = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hash_func(static_cast<::crypto::SHAAlgorithm>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 counter = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string key_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_key_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.SignRequest.key_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SignRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.SignRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 sender_id = 1;
  if (this->_internal_sender_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_sender_id(), target);
  }

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  // .crypto.SHAAlgorithm hash_func = 3;
  if (this->_internal_hash_func() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_hash_func(), target);
  }

  // int64 counter = 5;
  if (this->_internal_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_counter(), target);
  }

  // string key_id = 6;
  if (!this->_internal_key_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key_id().data(), static_cast<int>(this->_internal_key_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.SignRequest.key_id");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_key_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.SignRequest)
  return target;
}

size_t SignRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.SignRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // string key_id = 6;
  if (!this->_internal_key_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key_id());
  }

  // int32 sender_id = 1;
  if (this->_internal_sender_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sender_id());
  }

  // .crypto.SHAAlgorithm hash_func = 3;
  if (this->_internal_hash_func() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_hash_func());
  }

  // int64 counter = 5;
  if (this->_internal_counter() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_counter());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SignRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignRequest::GetClassData() const { return &_class_data_; }

void SignRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SignRequest *>(to)->MergeFrom(
      static_cast<const SignRequest &>(from));
}


void SignRequest::MergeFrom(const SignRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.SignRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _internal_set_data(from._internal_data());
  }
  if (!from._internal_key_id().empty()) {
    _internal_set_key_id(from._internal_key_id());
  }
  if (from._internal_sender_id() != 0) {
    _internal_set_sender_id(from._internal_sender_id());
  }
  if (from._internal_hash_func() != 0) {
    _internal_set_hash_func(from._internal_hash_func());
  }
  if (from._internal_counter() != 0) {
    _internal_set_counter(from._internal_counter());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignRequest::CopyFrom(const SignRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.SignRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignRequest::IsInitialized() const {
  return true;
}

void SignRequest::InternalSwap(SignRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_id_, lhs_arena,
      &other->key_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SignRequest, counter_)
      + sizeof(SignRequest::counter_)
      - PROTOBUF_FIELD_OFFSET(SignRequest, sender_id_)>(
          reinterpret_cast<char*>(&sender_id_),
          reinterpret_cast<char*>(&other->sender_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SignRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[13]);
}

// ===================================================================

class SignResponse::_Internal {
 public:
};

SignResponse::SignResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.SignResponse)
}
SignResponse::SignResponse(const SignResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_signature().empty()) {
    signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signature(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.SignResponse)
}

void SignResponse::SharedCtor() {
signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

SignResponse::~SignResponse() {
  // @@protoc_insertion_point(destructor:crypto.SignResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SignResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SignResponse::ArenaDtor(void* object) {
  SignResponse* _this = reinterpret_cast< SignResponse* >(object);
  (void)_this;
}
void SignResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SignResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SignResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.SignResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  signature_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes signature = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SignResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.SignResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes signature = 1;
  if (!this->_internal_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.SignResponse)
  return target;
}

size_t SignResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.SignResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes signature = 1;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SignResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignResponse::GetClassData() const { return &_class_data_; }

void SignResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SignResponse *>(to)->MergeFrom(
      static_cast<const SignResponse &>(from));
}


void SignResponse::MergeFrom(const SignResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.SignResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_signature().empty()) {
    _internal_set_signature(from._internal_signature());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignResponse::CopyFrom(const SignResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.SignResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignResponse::IsInitialized() const {
  return true;
}

void SignResponse::InternalSwap(SignResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SignResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[14]);
}

// ===================================================================

class VerifyRequest::_Internal {
 public:
};

VerifyRequest::VerifyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.VerifyRequest)
}
VerifyRequest::VerifyRequest(const VerifyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data().empty()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_signature().empty()) {
    signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signature(), 
      GetArenaForAllocation());
  }
  key_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_key_id().empty()) {
    key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&sender_id_, &from.sender_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&counter_) -
    reinterpret_cast<char*>(&sender_id_)) + sizeof(counter_));
  // @@protoc_insertion_point(copy_constructor:crypto.VerifyRequest)
}

void VerifyRequest::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
key_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sender_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&counter_) -
    reinterpret_cast<char*>(&sender_id_)) + sizeof(counter_));
}

VerifyRequest::~VerifyRequest() {
  // @@protoc_insertion_point(destructor:crypto.VerifyRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VerifyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void VerifyRequest::ArenaDtor(void* object) {
  VerifyRequest* _this = reinterpret_cast< VerifyRequest* >(object);
  (void)_this;
}
void VerifyRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VerifyRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VerifyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.VerifyRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.ClearToEmpty();
  signature_.ClearToEmpty();
  key_id_.ClearToEmpty();
  ::memset(&sender_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&counter_) -
      reinterpret_cast<char*>(&sender_id_)) + sizeof(counter_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerifyRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 sender_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          sender_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 receiver_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          receiver_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes signature = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.SHAAlgorithm hash_func = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hash_func(static_cast<::crypto::SHAAlgorithm>(val));
        } else
          goto handle_unusual;
        continue;
      // string key_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_key_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.VerifyRequest.key_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 counter = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* VerifyRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.VerifyRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 sender_id = 1;
  if (this->_internal_sender_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_sender_id(), target);
  }

  // int32 receiver_id = 2;
  if (this->_internal_receiver_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_receiver_id(), target);
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // bytes signature = 4;
  if (!this->_internal_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_signature(), target);
  }

  // .crypto.SHAAlgorithm hash_func = 5;
  if (this->_internal_hash_func() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_hash_func(), target);
  }

  // string key_id = 6;
  if (!this->_internal_key_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key_id().data(), static_cast<int>(this->_internal_key_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.VerifyRequest.key_id");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_key_id(), target);
  }

  // int32 counter = 7;
  if (this->_internal_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_counter(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.VerifyRequest)
  return target;
}

size_t VerifyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.VerifyRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // bytes signature = 4;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  // string key_id = 6;
  if (!this->_internal_key_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key_id());
  }

  // int32 sender_id = 1;
  if (this->_internal_sender_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sender_id());
  }

  // int32 receiver_id = 2;
  if (this->_internal_receiver_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiver_id());
  }

  // .crypto.SHAAlgorithm hash_func = 5;
  if (this->_internal_hash_func() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_hash_func());
  }

  // int32 counter = 7;
  if (this->_internal_counter() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_counter());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerifyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VerifyRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerifyRequest::GetClassData() const { return &_class_data_; }

void VerifyRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VerifyRequest *>(to)->MergeFrom(
      static_cast<const VerifyRequest &>(from));
}


void VerifyRequest::MergeFrom(const VerifyRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.VerifyRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _internal_set_data(from._internal_data());
  }
  if (!from._internal_signature().empty()) {
    _internal_set_signature(from._internal_signature());
  }
  if (!from._internal_key_id().empty()) {
    _internal_set_key_id(from._internal_key_id());
  }
  if (from._internal_sender_id() != 0) {
    _internal_set_sender_id(from._internal_sender_id());
  }
  if (from._internal_receiver_id() != 0) {
    _internal_set_receiver_id(from._internal_receiver_id());
  }
  if (from._internal_hash_func() != 0) {
    _internal_set_hash_func(from._internal_hash_func());
  }
  if (from._internal_counter() != 0) {
    _internal_set_counter(from._internal_counter());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerifyRequest::CopyFrom(const VerifyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.VerifyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerifyRequest::IsInitialized() const {
  return true;
}

void VerifyRequest::InternalSwap(VerifyRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_id_, lhs_arena,
      &other->key_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerifyRequest, counter_)
      + sizeof(VerifyRequest::counter_)
      - PROTOBUF_FIELD_OFFSET(VerifyRequest, sender_id_)>(
          reinterpret_cast<char*>(&sender_id_),
          reinterpret_cast<char*>(&other->sender_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VerifyRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[15]);
}

// ===================================================================

class VerifyResponse::_Internal {
 public:
};

VerifyResponse::VerifyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.VerifyResponse)
}
VerifyResponse::VerifyResponse(const VerifyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  out_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_out().empty()) {
    out_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_out(), 
      GetArenaForAllocation());
  }
  valid_ = from.valid_;
  // @@protoc_insertion_point(copy_constructor:crypto.VerifyResponse)
}

void VerifyResponse::SharedCtor() {
out_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
valid_ = false;
}

VerifyResponse::~VerifyResponse() {
  // @@protoc_insertion_point(destructor:crypto.VerifyResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VerifyResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  out_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void VerifyResponse::ArenaDtor(void* object) {
  VerifyResponse* _this = reinterpret_cast< VerifyResponse* >(object);
  (void)_this;
}
void VerifyResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VerifyResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VerifyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.VerifyResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  out_.ClearToEmpty();
  valid_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerifyResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool valid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes out = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_out();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* VerifyResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.VerifyResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool valid = 1;
  if (this->_internal_valid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_valid(), target);
  }

  // bytes out = 2;
  if (!this->_internal_out().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_out(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.VerifyResponse)
  return target;
}

size_t VerifyResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.VerifyResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes out = 2;
  if (!this->_internal_out().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_out());
  }

  // bool valid = 1;
  if (this->_internal_valid() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerifyResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VerifyResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerifyResponse::GetClassData() const { return &_class_data_; }

void VerifyResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VerifyResponse *>(to)->MergeFrom(
      static_cast<const VerifyResponse &>(from));
}


void VerifyResponse::MergeFrom(const VerifyResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.VerifyResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_out().empty()) {
    _internal_set_out(from._internal_out());
  }
  if (from._internal_valid() != 0) {
    _internal_set_valid(from._internal_valid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerifyResponse::CopyFrom(const VerifyResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.VerifyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerifyResponse::IsInitialized() const {
  return true;
}

void VerifyResponse::InternalSwap(VerifyResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &out_, lhs_arena,
      &other->out_, rhs_arena
  );
  swap(valid_, other->valid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerifyResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[16]);
}

// ===================================================================

class KeyRequest::_Internal {
 public:
};

KeyRequest::KeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.KeyRequest)
}
KeyRequest::KeyRequest(const KeyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_id_ = from.user_id_;
  // @@protoc_insertion_point(copy_constructor:crypto.KeyRequest)
}

void KeyRequest::SharedCtor() {
user_id_ = 0;
}

KeyRequest::~KeyRequest() {
  // @@protoc_insertion_point(destructor:crypto.KeyRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KeyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void KeyRequest::ArenaDtor(void* object) {
  KeyRequest* _this = reinterpret_cast< KeyRequest* >(object);
  (void)_this;
}
void KeyRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeyRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.KeyRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_id_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 user_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          user_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* KeyRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.KeyRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_user_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.KeyRequest)
  return target;
}

size_t KeyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.KeyRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 user_id = 1;
  if (this->_internal_user_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_user_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KeyRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyRequest::GetClassData() const { return &_class_data_; }

void KeyRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KeyRequest *>(to)->MergeFrom(
      static_cast<const KeyRequest &>(from));
}


void KeyRequest::MergeFrom(const KeyRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.KeyRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_user_id() != 0) {
    _internal_set_user_id(from._internal_user_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyRequest::CopyFrom(const KeyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.KeyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyRequest::IsInitialized() const {
  return true;
}

void KeyRequest::InternalSwap(KeyRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(user_id_, other->user_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[17]);
}

// ===================================================================

class KeyResponse::_Internal {
 public:
};

KeyResponse::KeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.KeyResponse)
}
KeyResponse::KeyResponse(const KeyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_key().empty()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.KeyResponse)
}

void KeyResponse::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

KeyResponse::~KeyResponse() {
  // @@protoc_insertion_point(destructor:crypto.KeyResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KeyResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void KeyResponse::ArenaDtor(void* object) {
  KeyResponse* _this = reinterpret_cast< KeyResponse* >(object);
  (void)_this;
}
void KeyResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeyResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.KeyResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  key_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.KeyResponse.key"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* KeyResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.KeyResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.KeyResponse.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.KeyResponse)
  return target;
}

size_t KeyResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.KeyResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KeyResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyResponse::GetClassData() const { return &_class_data_; }

void KeyResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KeyResponse *>(to)->MergeFrom(
      static_cast<const KeyResponse &>(from));
}


void KeyResponse::MergeFrom(const KeyResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.KeyResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _internal_set_key(from._internal_key());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyResponse::CopyFrom(const KeyResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.KeyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyResponse::IsInitialized() const {
  return true;
}

void KeyResponse::InternalSwap(KeyResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[18]);
}

// ===================================================================

class UserKeyPermissions::_Internal {
 public:
};

UserKeyPermissions::UserKeyPermissions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  permissions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.UserKeyPermissions)
}
UserKeyPermissions::UserKeyPermissions(const UserKeyPermissions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      permissions_(from.permissions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  userid_ = from.userid_;
  // @@protoc_insertion_point(copy_constructor:crypto.UserKeyPermissions)
}

void UserKeyPermissions::SharedCtor() {
userid_ = 0;
}

UserKeyPermissions::~UserKeyPermissions() {
  // @@protoc_insertion_point(destructor:crypto.UserKeyPermissions)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UserKeyPermissions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserKeyPermissions::ArenaDtor(void* object) {
  UserKeyPermissions* _this = reinterpret_cast< UserKeyPermissions* >(object);
  (void)_this;
}
void UserKeyPermissions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UserKeyPermissions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserKeyPermissions::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.UserKeyPermissions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permissions_.Clear();
  userid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserKeyPermissions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          userid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .crypto.KeyPermission permissions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_permissions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_permissions(static_cast<::crypto::KeyPermission>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UserKeyPermissions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.UserKeyPermissions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_userid(), target);
  }

  // repeated .crypto.KeyPermission permissions = 2;
  {
    int byte_size = _permissions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, permissions_, byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.UserKeyPermissions)
  return target;
}

size_t UserKeyPermissions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.UserKeyPermissions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .crypto.KeyPermission permissions = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_permissions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_permissions(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _permissions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserKeyPermissions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UserKeyPermissions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserKeyPermissions::GetClassData() const { return &_class_data_; }

void UserKeyPermissions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UserKeyPermissions *>(to)->MergeFrom(
      static_cast<const UserKeyPermissions &>(from));
}


void UserKeyPermissions::MergeFrom(const UserKeyPermissions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.UserKeyPermissions)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permissions_.MergeFrom(from.permissions_);
  if (from._internal_userid() != 0) {
    _internal_set_userid(from._internal_userid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserKeyPermissions::CopyFrom(const UserKeyPermissions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.UserKeyPermissions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserKeyPermissions::IsInitialized() const {
  return true;
}

void UserKeyPermissions::InternalSwap(UserKeyPermissions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  permissions_.InternalSwap(&other->permissions_);
  swap(userid_, other->userid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UserKeyPermissions::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[19]);
}

// ===================================================================

class BootSystemRequest::_Internal {
 public:
};

BootSystemRequest::BootSystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  usersidspermissions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.BootSystemRequest)
}
BootSystemRequest::BootSystemRequest(const BootSystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      usersidspermissions_(from.usersidspermissions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:crypto.BootSystemRequest)
}

void BootSystemRequest::SharedCtor() {
}

BootSystemRequest::~BootSystemRequest() {
  // @@protoc_insertion_point(destructor:crypto.BootSystemRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BootSystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BootSystemRequest::ArenaDtor(void* object) {
  BootSystemRequest* _this = reinterpret_cast< BootSystemRequest* >(object);
  (void)_this;
}
void BootSystemRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BootSystemRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BootSystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.BootSystemRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  usersidspermissions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BootSystemRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .crypto.UserKeyPermissions usersIdsPermissions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_usersidspermissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BootSystemRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.BootSystemRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .crypto.UserKeyPermissions usersIdsPermissions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_usersidspermissions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_usersidspermissions(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.BootSystemRequest)
  return target;
}

size_t BootSystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.BootSystemRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .crypto.UserKeyPermissions usersIdsPermissions = 1;
  total_size += 1UL * this->_internal_usersidspermissions_size();
  for (const auto& msg : this->usersidspermissions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BootSystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BootSystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BootSystemRequest::GetClassData() const { return &_class_data_; }

void BootSystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BootSystemRequest *>(to)->MergeFrom(
      static_cast<const BootSystemRequest &>(from));
}


void BootSystemRequest::MergeFrom(const BootSystemRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.BootSystemRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  usersidspermissions_.MergeFrom(from.usersidspermissions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BootSystemRequest::CopyFrom(const BootSystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.BootSystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BootSystemRequest::IsInitialized() const {
  return true;
}

void BootSystemRequest::InternalSwap(BootSystemRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  usersidspermissions_.InternalSwap(&other->usersidspermissions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BootSystemRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[20]);
}

// ===================================================================

class Empty::_Internal {
 public:
};

Empty::Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:crypto.Empty)
}
Empty::Empty(const Empty& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:crypto.Empty)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Empty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Empty::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Empty::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[21]);
}

// ===================================================================

class CryptoConfig::_Internal {
 public:
};

CryptoConfig::CryptoConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.CryptoConfig)
}
CryptoConfig::CryptoConfig(const CryptoConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&hashfunction_, &from.hashfunction_,
    static_cast<size_t>(reinterpret_cast<char*>(&asymmetricfunction_) -
    reinterpret_cast<char*>(&hashfunction_)) + sizeof(asymmetricfunction_));
  // @@protoc_insertion_point(copy_constructor:crypto.CryptoConfig)
}

void CryptoConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&hashfunction_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&asymmetricfunction_) -
    reinterpret_cast<char*>(&hashfunction_)) + sizeof(asymmetricfunction_));
}

CryptoConfig::~CryptoConfig() {
  // @@protoc_insertion_point(destructor:crypto.CryptoConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CryptoConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CryptoConfig::ArenaDtor(void* object) {
  CryptoConfig* _this = reinterpret_cast< CryptoConfig* >(object);
  (void)_this;
}
void CryptoConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CryptoConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CryptoConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.CryptoConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&hashfunction_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&asymmetricfunction_) -
      reinterpret_cast<char*>(&hashfunction_)) + sizeof(asymmetricfunction_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CryptoConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .crypto.SHAAlgorithm hashFunction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hashfunction(static_cast<::crypto::SHAAlgorithm>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESKeyLength aesKeyLength = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_aeskeylength(static_cast<::crypto::AESKeyLength>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESChainingMode aesChainingMode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_aeschainingmode(static_cast<::crypto::AESChainingMode>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AsymmetricFunction asymmetricFunction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_asymmetricfunction(static_cast<::crypto::AsymmetricFunction>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CryptoConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.CryptoConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .crypto.SHAAlgorithm hashFunction = 1;
  if (this->_internal_hashfunction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_hashfunction(), target);
  }

  // .crypto.AESKeyLength aesKeyLength = 2;
  if (this->_internal_aeskeylength() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_aeskeylength(), target);
  }

  // .crypto.AESChainingMode aesChainingMode = 3;
  if (this->_internal_aeschainingmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_aeschainingmode(), target);
  }

  // .crypto.AsymmetricFunction asymmetricFunction = 4;
  if (this->_internal_asymmetricfunction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_asymmetricfunction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.CryptoConfig)
  return target;
}

size_t CryptoConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.CryptoConfig)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .crypto.SHAAlgorithm hashFunction = 1;
  if (this->_internal_hashfunction() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_hashfunction());
  }

  // .crypto.AESKeyLength aesKeyLength = 2;
  if (this->_internal_aeskeylength() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_aeskeylength());
  }

  // .crypto.AESChainingMode aesChainingMode = 3;
  if (this->_internal_aeschainingmode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_aeschainingmode());
  }

  // .crypto.AsymmetricFunction asymmetricFunction = 4;
  if (this->_internal_asymmetricfunction() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_asymmetricfunction());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CryptoConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CryptoConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CryptoConfig::GetClassData() const { return &_class_data_; }

void CryptoConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CryptoConfig *>(to)->MergeFrom(
      static_cast<const CryptoConfig &>(from));
}


void CryptoConfig::MergeFrom(const CryptoConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.CryptoConfig)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_hashfunction() != 0) {
    _internal_set_hashfunction(from._internal_hashfunction());
  }
  if (from._internal_aeskeylength() != 0) {
    _internal_set_aeskeylength(from._internal_aeskeylength());
  }
  if (from._internal_aeschainingmode() != 0) {
    _internal_set_aeschainingmode(from._internal_aeschainingmode());
  }
  if (from._internal_asymmetricfunction() != 0) {
    _internal_set_asymmetricfunction(from._internal_asymmetricfunction());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CryptoConfig::CopyFrom(const CryptoConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.CryptoConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CryptoConfig::IsInitialized() const {
  return true;
}

void CryptoConfig::InternalSwap(CryptoConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CryptoConfig, asymmetricfunction_)
      + sizeof(CryptoConfig::asymmetricfunction_)
      - PROTOBUF_FIELD_OFFSET(CryptoConfig, hashfunction_)>(
          reinterpret_cast<char*>(&hashfunction_),
          reinterpret_cast<char*>(&other->hashfunction_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CryptoConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[22]);
}

// ===================================================================

class ConfigureRequest::_Internal {
 public:
  static const ::crypto::CryptoConfig& config(const ConfigureRequest* msg);
};

const ::crypto::CryptoConfig&
ConfigureRequest::_Internal::config(const ConfigureRequest* msg) {
  return *msg->config_;
}
ConfigureRequest::ConfigureRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.ConfigureRequest)
}
ConfigureRequest::ConfigureRequest(const ConfigureRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_config()) {
    config_ = new ::crypto::CryptoConfig(*from.config_);
  } else {
    config_ = nullptr;
  }
  userid_ = from.userid_;
  // @@protoc_insertion_point(copy_constructor:crypto.ConfigureRequest)
}

void ConfigureRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&userid_) -
    reinterpret_cast<char*>(&config_)) + sizeof(userid_));
}

ConfigureRequest::~ConfigureRequest() {
  // @@protoc_insertion_point(destructor:crypto.ConfigureRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ConfigureRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete config_;
}

void ConfigureRequest::ArenaDtor(void* object) {
  ConfigureRequest* _this = reinterpret_cast< ConfigureRequest* >(object);
  (void)_this;
}
void ConfigureRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConfigureRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfigureRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.ConfigureRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
  userid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigureRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          userid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.CryptoConfig config = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ConfigureRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.ConfigureRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_userid(), target);
  }

  // .crypto.CryptoConfig config = 2;
  if (this->_internal_has_config()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::config(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.ConfigureRequest)
  return target;
}

size_t ConfigureRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.ConfigureRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .crypto.CryptoConfig config = 2;
  if (this->_internal_has_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *config_);
  }

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigureRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ConfigureRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigureRequest::GetClassData() const { return &_class_data_; }

void ConfigureRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ConfigureRequest *>(to)->MergeFrom(
      static_cast<const ConfigureRequest &>(from));
}


void ConfigureRequest::MergeFrom(const ConfigureRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.ConfigureRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_config()) {
    _internal_mutable_config()->::crypto::CryptoConfig::MergeFrom(from._internal_config());
  }
  if (from._internal_userid() != 0) {
    _internal_set_userid(from._internal_userid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigureRequest::CopyFrom(const ConfigureRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.ConfigureRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigureRequest::IsInitialized() const {
  return true;
}

void ConfigureRequest::InternalSwap(ConfigureRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigureRequest, userid_)
      + sizeof(ConfigureRequest::userid_)
      - PROTOBUF_FIELD_OFFSET(ConfigureRequest, config_)>(
          reinterpret_cast<char*>(&config_),
          reinterpret_cast<char*>(&other->config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigureRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[23]);
}

// ===================================================================

class AddProcessRequest::_Internal {
 public:
};

AddProcessRequest::AddProcessRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  permissions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AddProcessRequest)
}
AddProcessRequest::AddProcessRequest(const AddProcessRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      permissions_(from.permissions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  userid_ = from.userid_;
  // @@protoc_insertion_point(copy_constructor:crypto.AddProcessRequest)
}

void AddProcessRequest::SharedCtor() {
userid_ = 0;
}

AddProcessRequest::~AddProcessRequest() {
  // @@protoc_insertion_point(destructor:crypto.AddProcessRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AddProcessRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AddProcessRequest::ArenaDtor(void* object) {
  AddProcessRequest* _this = reinterpret_cast< AddProcessRequest* >(object);
  (void)_this;
}
void AddProcessRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AddProcessRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AddProcessRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AddProcessRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permissions_.Clear();
  userid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddProcessRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          userid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .crypto.KeyPermission permissions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_permissions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_permissions(static_cast<::crypto::KeyPermission>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AddProcessRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AddProcessRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_userid(), target);
  }

  // repeated .crypto.KeyPermission permissions = 2;
  {
    int byte_size = _permissions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, permissions_, byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AddProcessRequest)
  return target;
}

size_t AddProcessRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AddProcessRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .crypto.KeyPermission permissions = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_permissions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_permissions(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _permissions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddProcessRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AddProcessRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddProcessRequest::GetClassData() const { return &_class_data_; }

void AddProcessRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AddProcessRequest *>(to)->MergeFrom(
      static_cast<const AddProcessRequest &>(from));
}


void AddProcessRequest::MergeFrom(const AddProcessRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AddProcessRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permissions_.MergeFrom(from.permissions_);
  if (from._internal_userid() != 0) {
    _internal_set_userid(from._internal_userid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddProcessRequest::CopyFrom(const AddProcessRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AddProcessRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddProcessRequest::IsInitialized() const {
  return true;
}

void AddProcessRequest::InternalSwap(AddProcessRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  permissions_.InternalSwap(&other->permissions_);
  swap(userid_, other->userid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AddProcessRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[24]);
}

// ===================================================================

class EncryptRequest::_Internal {
 public:
};

EncryptRequest::EncryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.EncryptRequest)
}
EncryptRequest::EncryptRequest(const EncryptRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data().empty()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&sender_id_, &from.sender_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&sender_id_)) + sizeof(isfirst_));
  // @@protoc_insertion_point(copy_constructor:crypto.EncryptRequest)
}

void EncryptRequest::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sender_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&sender_id_)) + sizeof(isfirst_));
}

EncryptRequest::~EncryptRequest() {
  // @@protoc_insertion_point(destructor:crypto.EncryptRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void EncryptRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void EncryptRequest::ArenaDtor(void* object) {
  EncryptRequest* _this = reinterpret_cast< EncryptRequest* >(object);
  (void)_this;
}
void EncryptRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EncryptRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EncryptRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.EncryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.ClearToEmpty();
  ::memset(&sender_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isfirst_) -
      reinterpret_cast<char*>(&sender_id_)) + sizeof(isfirst_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EncryptRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 sender_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          sender_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 receiver_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          receiver_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 counter = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isFirst = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          isfirst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EncryptRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.EncryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 sender_id = 1;
  if (this->_internal_sender_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_sender_id(), target);
  }

  // int32 receiver_id = 2;
  if (this->_internal_receiver_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_receiver_id(), target);
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // int64 counter = 4;
  if (this->_internal_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_counter(), target);
  }

  // bool isFirst = 5;
  if (this->_internal_isfirst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_isfirst(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.EncryptRequest)
  return target;
}

size_t EncryptRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.EncryptRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // int32 sender_id = 1;
  if (this->_internal_sender_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sender_id());
  }

  // int32 receiver_id = 2;
  if (this->_internal_receiver_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiver_id());
  }

  // int64 counter = 4;
  if (this->_internal_counter() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_counter());
  }

  // bool isFirst = 5;
  if (this->_internal_isfirst() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EncryptRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EncryptRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EncryptRequest::GetClassData() const { return &_class_data_; }

void EncryptRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EncryptRequest *>(to)->MergeFrom(
      static_cast<const EncryptRequest &>(from));
}


void EncryptRequest::MergeFrom(const EncryptRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.EncryptRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _internal_set_data(from._internal_data());
  }
  if (from._internal_sender_id() != 0) {
    _internal_set_sender_id(from._internal_sender_id());
  }
  if (from._internal_receiver_id() != 0) {
    _internal_set_receiver_id(from._internal_receiver_id());
  }
  if (from._internal_counter() != 0) {
    _internal_set_counter(from._internal_counter());
  }
  if (from._internal_isfirst() != 0) {
    _internal_set_isfirst(from._internal_isfirst());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EncryptRequest::CopyFrom(const EncryptRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.EncryptRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncryptRequest::IsInitialized() const {
  return true;
}

void EncryptRequest::InternalSwap(EncryptRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EncryptRequest, isfirst_)
      + sizeof(EncryptRequest::isfirst_)
      - PROTOBUF_FIELD_OFFSET(EncryptRequest, sender_id_)>(
          reinterpret_cast<char*>(&sender_id_),
          reinterpret_cast<char*>(&other->sender_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EncryptRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[25]);
}

// ===================================================================

class EncryptResponse::_Internal {
 public:
};

EncryptResponse::EncryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.EncryptResponse)
}
EncryptResponse::EncryptResponse(const EncryptResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  encrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_encrypted_data().empty()) {
    encrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encrypted_data(), 
      GetArenaForAllocation());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_signature().empty()) {
    signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signature(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.EncryptResponse)
}

void EncryptResponse::SharedCtor() {
encrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

EncryptResponse::~EncryptResponse() {
  // @@protoc_insertion_point(destructor:crypto.EncryptResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void EncryptResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encrypted_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void EncryptResponse::ArenaDtor(void* object) {
  EncryptResponse* _this = reinterpret_cast< EncryptResponse* >(object);
  (void)_this;
}
void EncryptResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EncryptResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EncryptResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.EncryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  encrypted_data_.ClearToEmpty();
  signature_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EncryptResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes encrypted_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_encrypted_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EncryptResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.EncryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes encrypted_data = 1;
  if (!this->_internal_encrypted_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_encrypted_data(), target);
  }

  // bytes signature = 2;
  if (!this->_internal_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.EncryptResponse)
  return target;
}

size_t EncryptResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.EncryptResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes encrypted_data = 1;
  if (!this->_internal_encrypted_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encrypted_data());
  }

  // bytes signature = 2;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EncryptResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EncryptResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EncryptResponse::GetClassData() const { return &_class_data_; }

void EncryptResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EncryptResponse *>(to)->MergeFrom(
      static_cast<const EncryptResponse &>(from));
}


void EncryptResponse::MergeFrom(const EncryptResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.EncryptResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_encrypted_data().empty()) {
    _internal_set_encrypted_data(from._internal_encrypted_data());
  }
  if (!from._internal_signature().empty()) {
    _internal_set_signature(from._internal_signature());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EncryptResponse::CopyFrom(const EncryptResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.EncryptResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncryptResponse::IsInitialized() const {
  return true;
}

void EncryptResponse::InternalSwap(EncryptResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encrypted_data_, lhs_arena,
      &other->encrypted_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata EncryptResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[26]);
}

// ===================================================================

class DecryptRequest::_Internal {
 public:
};

DecryptRequest::DecryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.DecryptRequest)
}
DecryptRequest::DecryptRequest(const DecryptRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  encrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_encrypted_data().empty()) {
    encrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encrypted_data(), 
      GetArenaForAllocation());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_signature().empty()) {
    signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signature(), 
      GetArenaForAllocation());
  }
  ::memcpy(&sender_id_, &from.sender_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&sender_id_)) + sizeof(isfirst_));
  // @@protoc_insertion_point(copy_constructor:crypto.DecryptRequest)
}

void DecryptRequest::SharedCtor() {
encrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sender_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&sender_id_)) + sizeof(isfirst_));
}

DecryptRequest::~DecryptRequest() {
  // @@protoc_insertion_point(destructor:crypto.DecryptRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DecryptRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encrypted_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DecryptRequest::ArenaDtor(void* object) {
  DecryptRequest* _this = reinterpret_cast< DecryptRequest* >(object);
  (void)_this;
}
void DecryptRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DecryptRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DecryptRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.DecryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  encrypted_data_.ClearToEmpty();
  signature_.ClearToEmpty();
  ::memset(&sender_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isfirst_) -
      reinterpret_cast<char*>(&sender_id_)) + sizeof(isfirst_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DecryptRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 sender_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          sender_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 receiver_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          receiver_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes encrypted_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_encrypted_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 counter = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isFirst = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          isfirst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DecryptRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.DecryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 sender_id = 1;
  if (this->_internal_sender_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_sender_id(), target);
  }

  // int32 receiver_id = 2;
  if (this->_internal_receiver_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_receiver_id(), target);
  }

  // bytes encrypted_data = 3;
  if (!this->_internal_encrypted_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_encrypted_data(), target);
  }

  // int64 counter = 4;
  if (this->_internal_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_counter(), target);
  }

  // bytes signature = 5;
  if (!this->_internal_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_signature(), target);
  }

  // bool isFirst = 6;
  if (this->_internal_isfirst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_isfirst(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.DecryptRequest)
  return target;
}

size_t DecryptRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.DecryptRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes encrypted_data = 3;
  if (!this->_internal_encrypted_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encrypted_data());
  }

  // bytes signature = 5;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  // int32 sender_id = 1;
  if (this->_internal_sender_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sender_id());
  }

  // int32 receiver_id = 2;
  if (this->_internal_receiver_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiver_id());
  }

  // int64 counter = 4;
  if (this->_internal_counter() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_counter());
  }

  // bool isFirst = 6;
  if (this->_internal_isfirst() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DecryptRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DecryptRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DecryptRequest::GetClassData() const { return &_class_data_; }

void DecryptRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DecryptRequest *>(to)->MergeFrom(
      static_cast<const DecryptRequest &>(from));
}


void DecryptRequest::MergeFrom(const DecryptRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.DecryptRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_encrypted_data().empty()) {
    _internal_set_encrypted_data(from._internal_encrypted_data());
  }
  if (!from._internal_signature().empty()) {
    _internal_set_signature(from._internal_signature());
  }
  if (from._internal_sender_id() != 0) {
    _internal_set_sender_id(from._internal_sender_id());
  }
  if (from._internal_receiver_id() != 0) {
    _internal_set_receiver_id(from._internal_receiver_id());
  }
  if (from._internal_counter() != 0) {
    _internal_set_counter(from._internal_counter());
  }
  if (from._internal_isfirst() != 0) {
    _internal_set_isfirst(from._internal_isfirst());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DecryptRequest::CopyFrom(const DecryptRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.DecryptRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecryptRequest::IsInitialized() const {
  return true;
}

void DecryptRequest::InternalSwap(DecryptRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encrypted_data_, lhs_arena,
      &other->encrypted_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DecryptRequest, isfirst_)
      + sizeof(DecryptRequest::isfirst_)
      - PROTOBUF_FIELD_OFFSET(DecryptRequest, sender_id_)>(
          reinterpret_cast<char*>(&sender_id_),
          reinterpret_cast<char*>(&other->sender_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DecryptRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[27]);
}

// ===================================================================

class DecryptResponse::_Internal {
 public:
};

DecryptResponse::DecryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.DecryptResponse)
}
DecryptResponse::DecryptResponse(const DecryptResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  decrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_decrypted_data().empty()) {
    decrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_decrypted_data(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.DecryptResponse)
}

void DecryptResponse::SharedCtor() {
decrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

DecryptResponse::~DecryptResponse() {
  // @@protoc_insertion_point(destructor:crypto.DecryptResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DecryptResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  decrypted_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DecryptResponse::ArenaDtor(void* object) {
  DecryptResponse* _this = reinterpret_cast< DecryptResponse* >(object);
  (void)_this;
}
void DecryptResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DecryptResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DecryptResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.DecryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  decrypted_data_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DecryptResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes decrypted_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_decrypted_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DecryptResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.DecryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes decrypted_data = 1;
  if (!this->_internal_decrypted_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_decrypted_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.DecryptResponse)
  return target;
}

size_t DecryptResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.DecryptResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes decrypted_data = 1;
  if (!this->_internal_decrypted_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_decrypted_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DecryptResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DecryptResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DecryptResponse::GetClassData() const { return &_class_data_; }

void DecryptResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DecryptResponse *>(to)->MergeFrom(
      static_cast<const DecryptResponse &>(from));
}


void DecryptResponse::MergeFrom(const DecryptResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.DecryptResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_decrypted_data().empty()) {
    _internal_set_decrypted_data(from._internal_decrypted_data());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DecryptResponse::CopyFrom(const DecryptResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.DecryptResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecryptResponse::IsInitialized() const {
  return true;
}

void DecryptResponse::InternalSwap(DecryptResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &decrypted_data_, lhs_arena,
      &other->decrypted_data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata DecryptResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[28]);
}

// ===================================================================

class AESEncryptRequest::_Internal {
 public:
};

AESEncryptRequest::AESEncryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AESEncryptRequest)
}
AESEncryptRequest::AESEncryptRequest(const AESEncryptRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data().empty()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  key_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_key_id().empty()) {
    key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&sender_id_, &from.sender_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&sender_id_)) + sizeof(isfirst_));
  // @@protoc_insertion_point(copy_constructor:crypto.AESEncryptRequest)
}

void AESEncryptRequest::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
key_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sender_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&sender_id_)) + sizeof(isfirst_));
}

AESEncryptRequest::~AESEncryptRequest() {
  // @@protoc_insertion_point(destructor:crypto.AESEncryptRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AESEncryptRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AESEncryptRequest::ArenaDtor(void* object) {
  AESEncryptRequest* _this = reinterpret_cast< AESEncryptRequest* >(object);
  (void)_this;
}
void AESEncryptRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AESEncryptRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AESEncryptRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AESEncryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.ClearToEmpty();
  key_id_.ClearToEmpty();
  ::memset(&sender_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isfirst_) -
      reinterpret_cast<char*>(&sender_id_)) + sizeof(isfirst_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AESEncryptRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 sender_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          sender_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 receiver_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          receiver_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.AsymmetricFunction func = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_func(static_cast<::crypto::AsymmetricFunction>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 counter = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string key_id = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_key_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.AESEncryptRequest.key_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESKeyLength key_length = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_key_length(static_cast<::crypto::AESKeyLength>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESChainingMode chainingMode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_chainingmode(static_cast<::crypto::AESChainingMode>(val));
        } else
          goto handle_unusual;
        continue;
      // bool isFirst = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          isfirst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AESEncryptRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AESEncryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 sender_id = 1;
  if (this->_internal_sender_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_sender_id(), target);
  }

  // int32 receiver_id = 2;
  if (this->_internal_receiver_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_receiver_id(), target);
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // .crypto.AsymmetricFunction func = 4;
  if (this->_internal_func() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_func(), target);
  }

  // int64 counter = 5;
  if (this->_internal_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_counter(), target);
  }

  // string key_id = 6;
  if (!this->_internal_key_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key_id().data(), static_cast<int>(this->_internal_key_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.AESEncryptRequest.key_id");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_key_id(), target);
  }

  // .crypto.AESKeyLength key_length = 7;
  if (this->_internal_key_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_key_length(), target);
  }

  // .crypto.AESChainingMode chainingMode = 8;
  if (this->_internal_chainingmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_chainingmode(), target);
  }

  // bool isFirst = 9;
  if (this->_internal_isfirst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_isfirst(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AESEncryptRequest)
  return target;
}

size_t AESEncryptRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AESEncryptRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // string key_id = 6;
  if (!this->_internal_key_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key_id());
  }

  // int32 sender_id = 1;
  if (this->_internal_sender_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sender_id());
  }

  // int32 receiver_id = 2;
  if (this->_internal_receiver_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiver_id());
  }

  // int64 counter = 5;
  if (this->_internal_counter() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_counter());
  }

  // .crypto.AsymmetricFunction func = 4;
  if (this->_internal_func() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_func());
  }

  // .crypto.AESKeyLength key_length = 7;
  if (this->_internal_key_length() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_key_length());
  }

  // .crypto.AESChainingMode chainingMode = 8;
  if (this->_internal_chainingmode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_chainingmode());
  }

  // bool isFirst = 9;
  if (this->_internal_isfirst() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AESEncryptRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AESEncryptRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AESEncryptRequest::GetClassData() const { return &_class_data_; }

void AESEncryptRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AESEncryptRequest *>(to)->MergeFrom(
      static_cast<const AESEncryptRequest &>(from));
}


void AESEncryptRequest::MergeFrom(const AESEncryptRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AESEncryptRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _internal_set_data(from._internal_data());
  }
  if (!from._internal_key_id().empty()) {
    _internal_set_key_id(from._internal_key_id());
  }
  if (from._internal_sender_id() != 0) {
    _internal_set_sender_id(from._internal_sender_id());
  }
  if (from._internal_receiver_id() != 0) {
    _internal_set_receiver_id(from._internal_receiver_id());
  }
  if (from._internal_counter() != 0) {
    _internal_set_counter(from._internal_counter());
  }
  if (from._internal_func() != 0) {
    _internal_set_func(from._internal_func());
  }
  if (from._internal_key_length() != 0) {
    _internal_set_key_length(from._internal_key_length());
  }
  if (from._internal_chainingmode() != 0) {
    _internal_set_chainingmode(from._internal_chainingmode());
  }
  if (from._internal_isfirst() != 0) {
    _internal_set_isfirst(from._internal_isfirst());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AESEncryptRequest::CopyFrom(const AESEncryptRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AESEncryptRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AESEncryptRequest::IsInitialized() const {
  return true;
}

void AESEncryptRequest::InternalSwap(AESEncryptRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_id_, lhs_arena,
      &other->key_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AESEncryptRequest, isfirst_)
      + sizeof(AESEncryptRequest::isfirst_)
      - PROTOBUF_FIELD_OFFSET(AESEncryptRequest, sender_id_)>(
          reinterpret_cast<char*>(&sender_id_),
          reinterpret_cast<char*>(&other->sender_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AESEncryptRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[29]);
}

// ===================================================================

class AESEncryptResponse::_Internal {
 public:
};

AESEncryptResponse::AESEncryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AESEncryptResponse)
}
AESEncryptResponse::AESEncryptResponse(const AESEncryptResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  encrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_encrypted_data().empty()) {
    encrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encrypted_data(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.AESEncryptResponse)
}

void AESEncryptResponse::SharedCtor() {
encrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

AESEncryptResponse::~AESEncryptResponse() {
  // @@protoc_insertion_point(destructor:crypto.AESEncryptResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AESEncryptResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encrypted_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AESEncryptResponse::ArenaDtor(void* object) {
  AESEncryptResponse* _this = reinterpret_cast< AESEncryptResponse* >(object);
  (void)_this;
}
void AESEncryptResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AESEncryptResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AESEncryptResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AESEncryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  encrypted_data_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AESEncryptResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes encrypted_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_encrypted_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AESEncryptResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AESEncryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes encrypted_data = 1;
  if (!this->_internal_encrypted_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_encrypted_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AESEncryptResponse)
  return target;
}

size_t AESEncryptResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AESEncryptResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes encrypted_data = 1;
  if (!this->_internal_encrypted_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encrypted_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AESEncryptResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AESEncryptResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AESEncryptResponse::GetClassData() const { return &_class_data_; }

void AESEncryptResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AESEncryptResponse *>(to)->MergeFrom(
      static_cast<const AESEncryptResponse &>(from));
}


void AESEncryptResponse::MergeFrom(const AESEncryptResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AESEncryptResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_encrypted_data().empty()) {
    _internal_set_encrypted_data(from._internal_encrypted_data());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AESEncryptResponse::CopyFrom(const AESEncryptResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AESEncryptResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AESEncryptResponse::IsInitialized() const {
  return true;
}

void AESEncryptResponse::InternalSwap(AESEncryptResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encrypted_data_, lhs_arena,
      &other->encrypted_data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AESEncryptResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[30]);
}

// ===================================================================

class AESDecryptRequest::_Internal {
 public:
};

AESDecryptRequest::AESDecryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AESDecryptRequest)
}
AESDecryptRequest::AESDecryptRequest(const AESDecryptRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_in_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data_in().empty()) {
    data_in_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data_in(), 
      GetArenaForAllocation());
  }
  data_out_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data_out().empty()) {
    data_out_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data_out(), 
      GetArenaForAllocation());
  }
  key_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_key_id().empty()) {
    key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&sender_id_, &from.sender_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&sender_id_)) + sizeof(isfirst_));
  // @@protoc_insertion_point(copy_constructor:crypto.AESDecryptRequest)
}

void AESDecryptRequest::SharedCtor() {
data_in_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
data_out_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
key_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sender_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&sender_id_)) + sizeof(isfirst_));
}

AESDecryptRequest::~AESDecryptRequest() {
  // @@protoc_insertion_point(destructor:crypto.AESDecryptRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AESDecryptRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_in_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_out_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  key_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AESDecryptRequest::ArenaDtor(void* object) {
  AESDecryptRequest* _this = reinterpret_cast< AESDecryptRequest* >(object);
  (void)_this;
}
void AESDecryptRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AESDecryptRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AESDecryptRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AESDecryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_in_.ClearToEmpty();
  data_out_.ClearToEmpty();
  key_id_.ClearToEmpty();
  ::memset(&sender_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isfirst_) -
      reinterpret_cast<char*>(&sender_id_)) + sizeof(isfirst_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AESDecryptRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 sender_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          sender_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 receiver_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          receiver_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data_in = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_data_in();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 in_len = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          in_len_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data_out = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_data_out();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.AsymmetricFunction func = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_func(static_cast<::crypto::AsymmetricFunction>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESKeyLength key_length = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_key_length(static_cast<::crypto::AESKeyLength>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESChainingMode chainingMode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_chainingmode(static_cast<::crypto::AESChainingMode>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 counter = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string key_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_key_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.AESDecryptRequest.key_id"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isFirst = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          isfirst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AESDecryptRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AESDecryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 sender_id = 1;
  if (this->_internal_sender_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_sender_id(), target);
  }

  // int32 receiver_id = 2;
  if (this->_internal_receiver_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_receiver_id(), target);
  }

  // bytes data_in = 3;
  if (!this->_internal_data_in().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data_in(), target);
  }

  // int32 in_len = 4;
  if (this->_internal_in_len() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_in_len(), target);
  }

  // bytes data_out = 5;
  if (!this->_internal_data_out().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_data_out(), target);
  }

  // .crypto.AsymmetricFunction func = 6;
  if (this->_internal_func() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_func(), target);
  }

  // .crypto.AESKeyLength key_length = 7;
  if (this->_internal_key_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_key_length(), target);
  }

  // .crypto.AESChainingMode chainingMode = 8;
  if (this->_internal_chainingmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_chainingmode(), target);
  }

  // int64 counter = 9;
  if (this->_internal_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(9, this->_internal_counter(), target);
  }

  // string key_id = 10;
  if (!this->_internal_key_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key_id().data(), static_cast<int>(this->_internal_key_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.AESDecryptRequest.key_id");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_key_id(), target);
  }

  // bool isFirst = 11;
  if (this->_internal_isfirst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_isfirst(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AESDecryptRequest)
  return target;
}

size_t AESDecryptRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AESDecryptRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data_in = 3;
  if (!this->_internal_data_in().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data_in());
  }

  // bytes data_out = 5;
  if (!this->_internal_data_out().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data_out());
  }

  // string key_id = 10;
  if (!this->_internal_key_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key_id());
  }

  // int32 sender_id = 1;
  if (this->_internal_sender_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sender_id());
  }

  // int32 receiver_id = 2;
  if (this->_internal_receiver_id() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiver_id());
  }

  // int32 in_len = 4;
  if (this->_internal_in_len() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_in_len());
  }

  // .crypto.AsymmetricFunction func = 6;
  if (this->_internal_func() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_func());
  }

  // .crypto.AESKeyLength key_length = 7;
  if (this->_internal_key_length() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_key_length());
  }

  // .crypto.AESChainingMode chainingMode = 8;
  if (this->_internal_chainingmode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_chainingmode());
  }

  // int64 counter = 9;
  if (this->_internal_counter() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_counter());
  }

  // bool isFirst = 11;
  if (this->_internal_isfirst() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AESDecryptRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AESDecryptRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AESDecryptRequest::GetClassData() const { return &_class_data_; }

void AESDecryptRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AESDecryptRequest *>(to)->MergeFrom(
      static_cast<const AESDecryptRequest &>(from));
}


void AESDecryptRequest::MergeFrom(const AESDecryptRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AESDecryptRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data_in().empty()) {
    _internal_set_data_in(from._internal_data_in());
  }
  if (!from._internal_data_out().empty()) {
    _internal_set_data_out(from._internal_data_out());
  }
  if (!from._internal_key_id().empty()) {
    _internal_set_key_id(from._internal_key_id());
  }
  if (from._internal_sender_id() != 0) {
    _internal_set_sender_id(from._internal_sender_id());
  }
  if (from._internal_receiver_id() != 0) {
    _internal_set_receiver_id(from._internal_receiver_id());
  }
  if (from._internal_in_len() != 0) {
    _internal_set_in_len(from._internal_in_len());
  }
  if (from._internal_func() != 0) {
    _internal_set_func(from._internal_func());
  }
  if (from._internal_key_length() != 0) {
    _internal_set_key_length(from._internal_key_length());
  }
  if (from._internal_chainingmode() != 0) {
    _internal_set_chainingmode(from._internal_chainingmode());
  }
  if (from._internal_counter() != 0) {
    _internal_set_counter(from._internal_counter());
  }
  if (from._internal_isfirst() != 0) {
    _internal_set_isfirst(from._internal_isfirst());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AESDecryptRequest::CopyFrom(const AESDecryptRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AESDecryptRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AESDecryptRequest::IsInitialized() const {
  return true;
}

void AESDecryptRequest::InternalSwap(AESDecryptRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_in_, lhs_arena,
      &other->data_in_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_out_, lhs_arena,
      &other->data_out_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_id_, lhs_arena,
      &other->key_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AESDecryptRequest, isfirst_)
      + sizeof(AESDecryptRequest::isfirst_)
      - PROTOBUF_FIELD_OFFSET(AESDecryptRequest, sender_id_)>(
          reinterpret_cast<char*>(&sender_id_),
          reinterpret_cast<char*>(&other->sender_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AESDecryptRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[31]);
}

// ===================================================================

class AESDecryptResponse::_Internal {
 public:
};

AESDecryptResponse::AESDecryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AESDecryptResponse)
}
AESDecryptResponse::AESDecryptResponse(const AESDecryptResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  decrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_decrypted_data().empty()) {
    decrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_decrypted_data(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.AESDecryptResponse)
}

void AESDecryptResponse::SharedCtor() {
decrypted_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

AESDecryptResponse::~AESDecryptResponse() {
  // @@protoc_insertion_point(destructor:crypto.AESDecryptResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AESDecryptResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  decrypted_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AESDecryptResponse::ArenaDtor(void* object) {
  AESDecryptResponse* _this = reinterpret_cast< AESDecryptResponse* >(object);
  (void)_this;
}
void AESDecryptResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AESDecryptResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AESDecryptResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AESDecryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  decrypted_data_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AESDecryptResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes decrypted_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_decrypted_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AESDecryptResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AESDecryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes decrypted_data = 1;
  if (!this->_internal_decrypted_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_decrypted_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AESDecryptResponse)
  return target;
}

size_t AESDecryptResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AESDecryptResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes decrypted_data = 1;
  if (!this->_internal_decrypted_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_decrypted_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AESDecryptResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AESDecryptResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AESDecryptResponse::GetClassData() const { return &_class_data_; }

void AESDecryptResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AESDecryptResponse *>(to)->MergeFrom(
      static_cast<const AESDecryptResponse &>(from));
}


void AESDecryptResponse::MergeFrom(const AESDecryptResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AESDecryptResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_decrypted_data().empty()) {
    _internal_set_decrypted_data(from._internal_decrypted_data());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AESDecryptResponse::CopyFrom(const AESDecryptResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AESDecryptResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AESDecryptResponse::IsInitialized() const {
  return true;
}

void AESDecryptResponse::InternalSwap(AESDecryptResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &decrypted_data_, lhs_arena,
      &other->decrypted_data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AESDecryptResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[32]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace crypto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::crypto::AsymetricEncryptRequest* Arena::CreateMaybeMessage< ::crypto::AsymetricEncryptRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AsymetricEncryptRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AsymetricEncryptResponse* Arena::CreateMaybeMessage< ::crypto::AsymetricEncryptResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AsymetricEncryptResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AsymetricDecryptRequest* Arena::CreateMaybeMessage< ::crypto::AsymetricDecryptRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AsymetricDecryptRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GetHashLengthRequest* Arena::CreateMaybeMessage< ::crypto::GetHashLengthRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GetHashLengthRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GetAESLengthRequest* Arena::CreateMaybeMessage< ::crypto::GetAESLengthRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GetAESLengthRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AsymetricDecryptResponse* Arena::CreateMaybeMessage< ::crypto::AsymetricDecryptResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AsymetricDecryptResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GetLengthRequest* Arena::CreateMaybeMessage< ::crypto::GetLengthRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GetLengthRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GetLengthResponse* Arena::CreateMaybeMessage< ::crypto::GetLengthResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GetLengthResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GetWholeLength* Arena::CreateMaybeMessage< ::crypto::GetWholeLength >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GetWholeLength >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GenerateAESKeyRequest* Arena::CreateMaybeMessage< ::crypto::GenerateAESKeyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GenerateAESKeyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GenerateAESKeyResponse* Arena::CreateMaybeMessage< ::crypto::GenerateAESKeyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GenerateAESKeyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GenerateKeyPairRequest* Arena::CreateMaybeMessage< ::crypto::GenerateKeyPairRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GenerateKeyPairRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GenerateKeyPairResponse* Arena::CreateMaybeMessage< ::crypto::GenerateKeyPairResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GenerateKeyPairResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::SignRequest* Arena::CreateMaybeMessage< ::crypto::SignRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::SignRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::SignResponse* Arena::CreateMaybeMessage< ::crypto::SignResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::SignResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::VerifyRequest* Arena::CreateMaybeMessage< ::crypto::VerifyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::VerifyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::VerifyResponse* Arena::CreateMaybeMessage< ::crypto::VerifyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::VerifyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::KeyRequest* Arena::CreateMaybeMessage< ::crypto::KeyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::KeyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::KeyResponse* Arena::CreateMaybeMessage< ::crypto::KeyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::KeyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::UserKeyPermissions* Arena::CreateMaybeMessage< ::crypto::UserKeyPermissions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::UserKeyPermissions >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::BootSystemRequest* Arena::CreateMaybeMessage< ::crypto::BootSystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::BootSystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::Empty* Arena::CreateMaybeMessage< ::crypto::Empty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::Empty >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::CryptoConfig* Arena::CreateMaybeMessage< ::crypto::CryptoConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::CryptoConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::ConfigureRequest* Arena::CreateMaybeMessage< ::crypto::ConfigureRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::ConfigureRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AddProcessRequest* Arena::CreateMaybeMessage< ::crypto::AddProcessRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AddProcessRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::EncryptRequest* Arena::CreateMaybeMessage< ::crypto::EncryptRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::EncryptRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::EncryptResponse* Arena::CreateMaybeMessage< ::crypto::EncryptResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::EncryptResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::DecryptRequest* Arena::CreateMaybeMessage< ::crypto::DecryptRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::DecryptRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::DecryptResponse* Arena::CreateMaybeMessage< ::crypto::DecryptResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::DecryptResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AESEncryptRequest* Arena::CreateMaybeMessage< ::crypto::AESEncryptRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AESEncryptRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AESEncryptResponse* Arena::CreateMaybeMessage< ::crypto::AESEncryptResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AESEncryptResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AESDecryptRequest* Arena::CreateMaybeMessage< ::crypto::AESDecryptRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AESDecryptRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AESDecryptResponse* Arena::CreateMaybeMessage< ::crypto::AESDecryptResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AESDecryptResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
