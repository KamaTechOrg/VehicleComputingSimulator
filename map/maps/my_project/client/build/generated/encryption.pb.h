// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: encryption.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_encryption_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_encryption_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_encryption_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_encryption_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[33]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_encryption_2eproto;
namespace crypto {
class AESDecryptRequest;
struct AESDecryptRequestDefaultTypeInternal;
extern AESDecryptRequestDefaultTypeInternal _AESDecryptRequest_default_instance_;
class AESDecryptResponse;
struct AESDecryptResponseDefaultTypeInternal;
extern AESDecryptResponseDefaultTypeInternal _AESDecryptResponse_default_instance_;
class AESEncryptRequest;
struct AESEncryptRequestDefaultTypeInternal;
extern AESEncryptRequestDefaultTypeInternal _AESEncryptRequest_default_instance_;
class AESEncryptResponse;
struct AESEncryptResponseDefaultTypeInternal;
extern AESEncryptResponseDefaultTypeInternal _AESEncryptResponse_default_instance_;
class AddProcessRequest;
struct AddProcessRequestDefaultTypeInternal;
extern AddProcessRequestDefaultTypeInternal _AddProcessRequest_default_instance_;
class AsymetricDecryptRequest;
struct AsymetricDecryptRequestDefaultTypeInternal;
extern AsymetricDecryptRequestDefaultTypeInternal _AsymetricDecryptRequest_default_instance_;
class AsymetricDecryptResponse;
struct AsymetricDecryptResponseDefaultTypeInternal;
extern AsymetricDecryptResponseDefaultTypeInternal _AsymetricDecryptResponse_default_instance_;
class AsymetricEncryptRequest;
struct AsymetricEncryptRequestDefaultTypeInternal;
extern AsymetricEncryptRequestDefaultTypeInternal _AsymetricEncryptRequest_default_instance_;
class AsymetricEncryptResponse;
struct AsymetricEncryptResponseDefaultTypeInternal;
extern AsymetricEncryptResponseDefaultTypeInternal _AsymetricEncryptResponse_default_instance_;
class BootSystemRequest;
struct BootSystemRequestDefaultTypeInternal;
extern BootSystemRequestDefaultTypeInternal _BootSystemRequest_default_instance_;
class ConfigureRequest;
struct ConfigureRequestDefaultTypeInternal;
extern ConfigureRequestDefaultTypeInternal _ConfigureRequest_default_instance_;
class CryptoConfig;
struct CryptoConfigDefaultTypeInternal;
extern CryptoConfigDefaultTypeInternal _CryptoConfig_default_instance_;
class DecryptRequest;
struct DecryptRequestDefaultTypeInternal;
extern DecryptRequestDefaultTypeInternal _DecryptRequest_default_instance_;
class DecryptResponse;
struct DecryptResponseDefaultTypeInternal;
extern DecryptResponseDefaultTypeInternal _DecryptResponse_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class EncryptRequest;
struct EncryptRequestDefaultTypeInternal;
extern EncryptRequestDefaultTypeInternal _EncryptRequest_default_instance_;
class EncryptResponse;
struct EncryptResponseDefaultTypeInternal;
extern EncryptResponseDefaultTypeInternal _EncryptResponse_default_instance_;
class GenerateAESKeyRequest;
struct GenerateAESKeyRequestDefaultTypeInternal;
extern GenerateAESKeyRequestDefaultTypeInternal _GenerateAESKeyRequest_default_instance_;
class GenerateAESKeyResponse;
struct GenerateAESKeyResponseDefaultTypeInternal;
extern GenerateAESKeyResponseDefaultTypeInternal _GenerateAESKeyResponse_default_instance_;
class GenerateKeyPairRequest;
struct GenerateKeyPairRequestDefaultTypeInternal;
extern GenerateKeyPairRequestDefaultTypeInternal _GenerateKeyPairRequest_default_instance_;
class GenerateKeyPairResponse;
struct GenerateKeyPairResponseDefaultTypeInternal;
extern GenerateKeyPairResponseDefaultTypeInternal _GenerateKeyPairResponse_default_instance_;
class GetAESLengthRequest;
struct GetAESLengthRequestDefaultTypeInternal;
extern GetAESLengthRequestDefaultTypeInternal _GetAESLengthRequest_default_instance_;
class GetHashLengthRequest;
struct GetHashLengthRequestDefaultTypeInternal;
extern GetHashLengthRequestDefaultTypeInternal _GetHashLengthRequest_default_instance_;
class GetLengthRequest;
struct GetLengthRequestDefaultTypeInternal;
extern GetLengthRequestDefaultTypeInternal _GetLengthRequest_default_instance_;
class GetLengthResponse;
struct GetLengthResponseDefaultTypeInternal;
extern GetLengthResponseDefaultTypeInternal _GetLengthResponse_default_instance_;
class GetWholeLength;
struct GetWholeLengthDefaultTypeInternal;
extern GetWholeLengthDefaultTypeInternal _GetWholeLength_default_instance_;
class KeyRequest;
struct KeyRequestDefaultTypeInternal;
extern KeyRequestDefaultTypeInternal _KeyRequest_default_instance_;
class KeyResponse;
struct KeyResponseDefaultTypeInternal;
extern KeyResponseDefaultTypeInternal _KeyResponse_default_instance_;
class SignRequest;
struct SignRequestDefaultTypeInternal;
extern SignRequestDefaultTypeInternal _SignRequest_default_instance_;
class SignResponse;
struct SignResponseDefaultTypeInternal;
extern SignResponseDefaultTypeInternal _SignResponse_default_instance_;
class UserKeyPermissions;
struct UserKeyPermissionsDefaultTypeInternal;
extern UserKeyPermissionsDefaultTypeInternal _UserKeyPermissions_default_instance_;
class VerifyRequest;
struct VerifyRequestDefaultTypeInternal;
extern VerifyRequestDefaultTypeInternal _VerifyRequest_default_instance_;
class VerifyResponse;
struct VerifyResponseDefaultTypeInternal;
extern VerifyResponseDefaultTypeInternal _VerifyResponse_default_instance_;
}  // namespace crypto
PROTOBUF_NAMESPACE_OPEN
template<> ::crypto::AESDecryptRequest* Arena::CreateMaybeMessage<::crypto::AESDecryptRequest>(Arena*);
template<> ::crypto::AESDecryptResponse* Arena::CreateMaybeMessage<::crypto::AESDecryptResponse>(Arena*);
template<> ::crypto::AESEncryptRequest* Arena::CreateMaybeMessage<::crypto::AESEncryptRequest>(Arena*);
template<> ::crypto::AESEncryptResponse* Arena::CreateMaybeMessage<::crypto::AESEncryptResponse>(Arena*);
template<> ::crypto::AddProcessRequest* Arena::CreateMaybeMessage<::crypto::AddProcessRequest>(Arena*);
template<> ::crypto::AsymetricDecryptRequest* Arena::CreateMaybeMessage<::crypto::AsymetricDecryptRequest>(Arena*);
template<> ::crypto::AsymetricDecryptResponse* Arena::CreateMaybeMessage<::crypto::AsymetricDecryptResponse>(Arena*);
template<> ::crypto::AsymetricEncryptRequest* Arena::CreateMaybeMessage<::crypto::AsymetricEncryptRequest>(Arena*);
template<> ::crypto::AsymetricEncryptResponse* Arena::CreateMaybeMessage<::crypto::AsymetricEncryptResponse>(Arena*);
template<> ::crypto::BootSystemRequest* Arena::CreateMaybeMessage<::crypto::BootSystemRequest>(Arena*);
template<> ::crypto::ConfigureRequest* Arena::CreateMaybeMessage<::crypto::ConfigureRequest>(Arena*);
template<> ::crypto::CryptoConfig* Arena::CreateMaybeMessage<::crypto::CryptoConfig>(Arena*);
template<> ::crypto::DecryptRequest* Arena::CreateMaybeMessage<::crypto::DecryptRequest>(Arena*);
template<> ::crypto::DecryptResponse* Arena::CreateMaybeMessage<::crypto::DecryptResponse>(Arena*);
template<> ::crypto::Empty* Arena::CreateMaybeMessage<::crypto::Empty>(Arena*);
template<> ::crypto::EncryptRequest* Arena::CreateMaybeMessage<::crypto::EncryptRequest>(Arena*);
template<> ::crypto::EncryptResponse* Arena::CreateMaybeMessage<::crypto::EncryptResponse>(Arena*);
template<> ::crypto::GenerateAESKeyRequest* Arena::CreateMaybeMessage<::crypto::GenerateAESKeyRequest>(Arena*);
template<> ::crypto::GenerateAESKeyResponse* Arena::CreateMaybeMessage<::crypto::GenerateAESKeyResponse>(Arena*);
template<> ::crypto::GenerateKeyPairRequest* Arena::CreateMaybeMessage<::crypto::GenerateKeyPairRequest>(Arena*);
template<> ::crypto::GenerateKeyPairResponse* Arena::CreateMaybeMessage<::crypto::GenerateKeyPairResponse>(Arena*);
template<> ::crypto::GetAESLengthRequest* Arena::CreateMaybeMessage<::crypto::GetAESLengthRequest>(Arena*);
template<> ::crypto::GetHashLengthRequest* Arena::CreateMaybeMessage<::crypto::GetHashLengthRequest>(Arena*);
template<> ::crypto::GetLengthRequest* Arena::CreateMaybeMessage<::crypto::GetLengthRequest>(Arena*);
template<> ::crypto::GetLengthResponse* Arena::CreateMaybeMessage<::crypto::GetLengthResponse>(Arena*);
template<> ::crypto::GetWholeLength* Arena::CreateMaybeMessage<::crypto::GetWholeLength>(Arena*);
template<> ::crypto::KeyRequest* Arena::CreateMaybeMessage<::crypto::KeyRequest>(Arena*);
template<> ::crypto::KeyResponse* Arena::CreateMaybeMessage<::crypto::KeyResponse>(Arena*);
template<> ::crypto::SignRequest* Arena::CreateMaybeMessage<::crypto::SignRequest>(Arena*);
template<> ::crypto::SignResponse* Arena::CreateMaybeMessage<::crypto::SignResponse>(Arena*);
template<> ::crypto::UserKeyPermissions* Arena::CreateMaybeMessage<::crypto::UserKeyPermissions>(Arena*);
template<> ::crypto::VerifyRequest* Arena::CreateMaybeMessage<::crypto::VerifyRequest>(Arena*);
template<> ::crypto::VerifyResponse* Arena::CreateMaybeMessage<::crypto::VerifyResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace crypto {

enum KeyPermission : int {
  VERIFY = 0,
  SIGN = 1,
  ENCRYPT = 2,
  DECRYPT = 3,
  EXPORTABLE = 4,
  KeyPermission_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  KeyPermission_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool KeyPermission_IsValid(int value);
constexpr KeyPermission KeyPermission_MIN = VERIFY;
constexpr KeyPermission KeyPermission_MAX = EXPORTABLE;
constexpr int KeyPermission_ARRAYSIZE = KeyPermission_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyPermission_descriptor();
template<typename T>
inline const std::string& KeyPermission_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeyPermission>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeyPermission_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeyPermission_descriptor(), enum_t_value);
}
inline bool KeyPermission_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeyPermission* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeyPermission>(
    KeyPermission_descriptor(), name, value);
}
enum AESChainingMode : int {
  ECB = 0,
  CBC = 1,
  CFB = 2,
  OFB = 3,
  CTR = 4,
  AESChainingMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AESChainingMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AESChainingMode_IsValid(int value);
constexpr AESChainingMode AESChainingMode_MIN = ECB;
constexpr AESChainingMode AESChainingMode_MAX = CTR;
constexpr int AESChainingMode_ARRAYSIZE = AESChainingMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AESChainingMode_descriptor();
template<typename T>
inline const std::string& AESChainingMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AESChainingMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AESChainingMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AESChainingMode_descriptor(), enum_t_value);
}
inline bool AESChainingMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AESChainingMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AESChainingMode>(
    AESChainingMode_descriptor(), name, value);
}
enum AsymmetricFunction : int {
  RSA = 0,
  ECC = 1,
  AsymmetricFunction_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AsymmetricFunction_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AsymmetricFunction_IsValid(int value);
constexpr AsymmetricFunction AsymmetricFunction_MIN = RSA;
constexpr AsymmetricFunction AsymmetricFunction_MAX = ECC;
constexpr int AsymmetricFunction_ARRAYSIZE = AsymmetricFunction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsymmetricFunction_descriptor();
template<typename T>
inline const std::string& AsymmetricFunction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AsymmetricFunction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AsymmetricFunction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AsymmetricFunction_descriptor(), enum_t_value);
}
inline bool AsymmetricFunction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AsymmetricFunction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AsymmetricFunction>(
    AsymmetricFunction_descriptor(), name, value);
}
enum SHAAlgorithm : int {
  SHA256 = 0,
  SHA3_512 = 1,
  SHAAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SHAAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SHAAlgorithm_IsValid(int value);
constexpr SHAAlgorithm SHAAlgorithm_MIN = SHA256;
constexpr SHAAlgorithm SHAAlgorithm_MAX = SHA3_512;
constexpr int SHAAlgorithm_ARRAYSIZE = SHAAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SHAAlgorithm_descriptor();
template<typename T>
inline const std::string& SHAAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SHAAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SHAAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SHAAlgorithm_descriptor(), enum_t_value);
}
inline bool SHAAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SHAAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SHAAlgorithm>(
    SHAAlgorithm_descriptor(), name, value);
}
enum AESKeyLength : int {
  AES_128 = 0,
  AES_192 = 1,
  AES_256 = 2,
  AESKeyLength_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AESKeyLength_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AESKeyLength_IsValid(int value);
constexpr AESKeyLength AESKeyLength_MIN = AES_128;
constexpr AESKeyLength AESKeyLength_MAX = AES_256;
constexpr int AESKeyLength_ARRAYSIZE = AESKeyLength_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AESKeyLength_descriptor();
template<typename T>
inline const std::string& AESKeyLength_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AESKeyLength>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AESKeyLength_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AESKeyLength_descriptor(), enum_t_value);
}
inline bool AESKeyLength_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AESKeyLength* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AESKeyLength>(
    AESKeyLength_descriptor(), name, value);
}
// ===================================================================

class AsymetricEncryptRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.AsymetricEncryptRequest) */ {
 public:
  inline AsymetricEncryptRequest() : AsymetricEncryptRequest(nullptr) {}
  ~AsymetricEncryptRequest() override;
  explicit constexpr AsymetricEncryptRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AsymetricEncryptRequest(const AsymetricEncryptRequest& from);
  AsymetricEncryptRequest(AsymetricEncryptRequest&& from) noexcept
    : AsymetricEncryptRequest() {
    *this = ::std::move(from);
  }

  inline AsymetricEncryptRequest& operator=(const AsymetricEncryptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsymetricEncryptRequest& operator=(AsymetricEncryptRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AsymetricEncryptRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AsymetricEncryptRequest* internal_default_instance() {
    return reinterpret_cast<const AsymetricEncryptRequest*>(
               &_AsymetricEncryptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AsymetricEncryptRequest& a, AsymetricEncryptRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AsymetricEncryptRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AsymetricEncryptRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AsymetricEncryptRequest* New() const final {
    return new AsymetricEncryptRequest();
  }

  AsymetricEncryptRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AsymetricEncryptRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AsymetricEncryptRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AsymetricEncryptRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AsymetricEncryptRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.AsymetricEncryptRequest";
  }
  protected:
  explicit AsymetricEncryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIdFieldNumber = 2,
    kDataFieldNumber = 3,
    kSenderIdFieldNumber = 1,
  };
  // string keyId = 2;
  void clear_keyid();
  const std::string& keyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyid();
  PROTOBUF_MUST_USE_RESULT std::string* release_keyid();
  void set_allocated_keyid(std::string* keyid);
  private:
  const std::string& _internal_keyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyid(const std::string& value);
  std::string* _internal_mutable_keyid();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 senderId = 1;
  void clear_senderid();
  ::PROTOBUF_NAMESPACE_ID::int32 senderid() const;
  void set_senderid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_senderid() const;
  void _internal_set_senderid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.AsymetricEncryptRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int32 senderid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class AsymetricEncryptResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.AsymetricEncryptResponse) */ {
 public:
  inline AsymetricEncryptResponse() : AsymetricEncryptResponse(nullptr) {}
  ~AsymetricEncryptResponse() override;
  explicit constexpr AsymetricEncryptResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AsymetricEncryptResponse(const AsymetricEncryptResponse& from);
  AsymetricEncryptResponse(AsymetricEncryptResponse&& from) noexcept
    : AsymetricEncryptResponse() {
    *this = ::std::move(from);
  }

  inline AsymetricEncryptResponse& operator=(const AsymetricEncryptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsymetricEncryptResponse& operator=(AsymetricEncryptResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AsymetricEncryptResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AsymetricEncryptResponse* internal_default_instance() {
    return reinterpret_cast<const AsymetricEncryptResponse*>(
               &_AsymetricEncryptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AsymetricEncryptResponse& a, AsymetricEncryptResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AsymetricEncryptResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AsymetricEncryptResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AsymetricEncryptResponse* New() const final {
    return new AsymetricEncryptResponse();
  }

  AsymetricEncryptResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AsymetricEncryptResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AsymetricEncryptResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AsymetricEncryptResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AsymetricEncryptResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.AsymetricEncryptResponse";
  }
  protected:
  explicit AsymetricEncryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncryptedDataFieldNumber = 1,
  };
  // bytes encrypted_data = 1;
  void clear_encrypted_data();
  const std::string& encrypted_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_encrypted_data();
  void set_allocated_encrypted_data(std::string* encrypted_data);
  private:
  const std::string& _internal_encrypted_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_data(const std::string& value);
  std::string* _internal_mutable_encrypted_data();
  public:

  // @@protoc_insertion_point(class_scope:crypto.AsymetricEncryptResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class AsymetricDecryptRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.AsymetricDecryptRequest) */ {
 public:
  inline AsymetricDecryptRequest() : AsymetricDecryptRequest(nullptr) {}
  ~AsymetricDecryptRequest() override;
  explicit constexpr AsymetricDecryptRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AsymetricDecryptRequest(const AsymetricDecryptRequest& from);
  AsymetricDecryptRequest(AsymetricDecryptRequest&& from) noexcept
    : AsymetricDecryptRequest() {
    *this = ::std::move(from);
  }

  inline AsymetricDecryptRequest& operator=(const AsymetricDecryptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsymetricDecryptRequest& operator=(AsymetricDecryptRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AsymetricDecryptRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AsymetricDecryptRequest* internal_default_instance() {
    return reinterpret_cast<const AsymetricDecryptRequest*>(
               &_AsymetricDecryptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AsymetricDecryptRequest& a, AsymetricDecryptRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AsymetricDecryptRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AsymetricDecryptRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AsymetricDecryptRequest* New() const final {
    return new AsymetricDecryptRequest();
  }

  AsymetricDecryptRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AsymetricDecryptRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AsymetricDecryptRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AsymetricDecryptRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AsymetricDecryptRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.AsymetricDecryptRequest";
  }
  protected:
  explicit AsymetricDecryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyIdFieldNumber = 2,
    kDataFieldNumber = 3,
    kReceiverIdFieldNumber = 1,
  };
  // string keyId = 2;
  void clear_keyid();
  const std::string& keyid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyid();
  PROTOBUF_MUST_USE_RESULT std::string* release_keyid();
  void set_allocated_keyid(std::string* keyid);
  private:
  const std::string& _internal_keyid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyid(const std::string& value);
  std::string* _internal_mutable_keyid();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 receiverId = 1;
  void clear_receiverid();
  ::PROTOBUF_NAMESPACE_ID::int32 receiverid() const;
  void set_receiverid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_receiverid() const;
  void _internal_set_receiverid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.AsymetricDecryptRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int32 receiverid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class GetHashLengthRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.GetHashLengthRequest) */ {
 public:
  inline GetHashLengthRequest() : GetHashLengthRequest(nullptr) {}
  ~GetHashLengthRequest() override;
  explicit constexpr GetHashLengthRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetHashLengthRequest(const GetHashLengthRequest& from);
  GetHashLengthRequest(GetHashLengthRequest&& from) noexcept
    : GetHashLengthRequest() {
    *this = ::std::move(from);
  }

  inline GetHashLengthRequest& operator=(const GetHashLengthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHashLengthRequest& operator=(GetHashLengthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHashLengthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHashLengthRequest* internal_default_instance() {
    return reinterpret_cast<const GetHashLengthRequest*>(
               &_GetHashLengthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetHashLengthRequest& a, GetHashLengthRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetHashLengthRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHashLengthRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetHashLengthRequest* New() const final {
    return new GetHashLengthRequest();
  }

  GetHashLengthRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetHashLengthRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetHashLengthRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetHashLengthRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetHashLengthRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.GetHashLengthRequest";
  }
  protected:
  explicit GetHashLengthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuncFieldNumber = 1,
    kDataLenFieldNumber = 2,
  };
  // .crypto.SHAAlgorithm func = 1;
  void clear_func();
  ::crypto::SHAAlgorithm func() const;
  void set_func(::crypto::SHAAlgorithm value);
  private:
  ::crypto::SHAAlgorithm _internal_func() const;
  void _internal_set_func(::crypto::SHAAlgorithm value);
  public:

  // int32 dataLen = 2;
  void clear_datalen();
  ::PROTOBUF_NAMESPACE_ID::int32 datalen() const;
  void set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_datalen() const;
  void _internal_set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.GetHashLengthRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int func_;
  ::PROTOBUF_NAMESPACE_ID::int32 datalen_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class GetAESLengthRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.GetAESLengthRequest) */ {
 public:
  inline GetAESLengthRequest() : GetAESLengthRequest(nullptr) {}
  ~GetAESLengthRequest() override;
  explicit constexpr GetAESLengthRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAESLengthRequest(const GetAESLengthRequest& from);
  GetAESLengthRequest(GetAESLengthRequest&& from) noexcept
    : GetAESLengthRequest() {
    *this = ::std::move(from);
  }

  inline GetAESLengthRequest& operator=(const GetAESLengthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAESLengthRequest& operator=(GetAESLengthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAESLengthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAESLengthRequest* internal_default_instance() {
    return reinterpret_cast<const GetAESLengthRequest*>(
               &_GetAESLengthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetAESLengthRequest& a, GetAESLengthRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAESLengthRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAESLengthRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAESLengthRequest* New() const final {
    return new GetAESLengthRequest();
  }

  GetAESLengthRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAESLengthRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAESLengthRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAESLengthRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAESLengthRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.GetAESLengthRequest";
  }
  protected:
  explicit GetAESLengthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataLenFieldNumber = 1,
    kIsFirstFieldNumber = 2,
    kChainingModeFieldNumber = 3,
  };
  // int32 dataLen = 1;
  void clear_datalen();
  ::PROTOBUF_NAMESPACE_ID::int32 datalen() const;
  void set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_datalen() const;
  void _internal_set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool isFirst = 2;
  void clear_isfirst();
  bool isfirst() const;
  void set_isfirst(bool value);
  private:
  bool _internal_isfirst() const;
  void _internal_set_isfirst(bool value);
  public:

  // .crypto.AESChainingMode chainingMode = 3;
  void clear_chainingmode();
  ::crypto::AESChainingMode chainingmode() const;
  void set_chainingmode(::crypto::AESChainingMode value);
  private:
  ::crypto::AESChainingMode _internal_chainingmode() const;
  void _internal_set_chainingmode(::crypto::AESChainingMode value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.GetAESLengthRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 datalen_;
  bool isfirst_;
  int chainingmode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class AsymetricDecryptResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.AsymetricDecryptResponse) */ {
 public:
  inline AsymetricDecryptResponse() : AsymetricDecryptResponse(nullptr) {}
  ~AsymetricDecryptResponse() override;
  explicit constexpr AsymetricDecryptResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AsymetricDecryptResponse(const AsymetricDecryptResponse& from);
  AsymetricDecryptResponse(AsymetricDecryptResponse&& from) noexcept
    : AsymetricDecryptResponse() {
    *this = ::std::move(from);
  }

  inline AsymetricDecryptResponse& operator=(const AsymetricDecryptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsymetricDecryptResponse& operator=(AsymetricDecryptResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AsymetricDecryptResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AsymetricDecryptResponse* internal_default_instance() {
    return reinterpret_cast<const AsymetricDecryptResponse*>(
               &_AsymetricDecryptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AsymetricDecryptResponse& a, AsymetricDecryptResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AsymetricDecryptResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AsymetricDecryptResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AsymetricDecryptResponse* New() const final {
    return new AsymetricDecryptResponse();
  }

  AsymetricDecryptResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AsymetricDecryptResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AsymetricDecryptResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AsymetricDecryptResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AsymetricDecryptResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.AsymetricDecryptResponse";
  }
  protected:
  explicit AsymetricDecryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecryptedDataFieldNumber = 1,
  };
  // bytes decrypted_data = 1;
  void clear_decrypted_data();
  const std::string& decrypted_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_decrypted_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_decrypted_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_decrypted_data();
  void set_allocated_decrypted_data(std::string* decrypted_data);
  private:
  const std::string& _internal_decrypted_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_decrypted_data(const std::string& value);
  std::string* _internal_mutable_decrypted_data();
  public:

  // @@protoc_insertion_point(class_scope:crypto.AsymetricDecryptResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr decrypted_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class GetLengthRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.GetLengthRequest) */ {
 public:
  inline GetLengthRequest() : GetLengthRequest(nullptr) {}
  ~GetLengthRequest() override;
  explicit constexpr GetLengthRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLengthRequest(const GetLengthRequest& from);
  GetLengthRequest(GetLengthRequest&& from) noexcept
    : GetLengthRequest() {
    *this = ::std::move(from);
  }

  inline GetLengthRequest& operator=(const GetLengthRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLengthRequest& operator=(GetLengthRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLengthRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLengthRequest* internal_default_instance() {
    return reinterpret_cast<const GetLengthRequest*>(
               &_GetLengthRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetLengthRequest& a, GetLengthRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLengthRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLengthRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLengthRequest* New() const final {
    return new GetLengthRequest();
  }

  GetLengthRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLengthRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLengthRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLengthRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLengthRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.GetLengthRequest";
  }
  protected:
  explicit GetLengthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInLenFieldNumber = 1,
  };
  // int32 in_len = 1;
  void clear_in_len();
  ::PROTOBUF_NAMESPACE_ID::int32 in_len() const;
  void set_in_len(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_in_len() const;
  void _internal_set_in_len(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.GetLengthRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 in_len_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class GetLengthResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.GetLengthResponse) */ {
 public:
  inline GetLengthResponse() : GetLengthResponse(nullptr) {}
  ~GetLengthResponse() override;
  explicit constexpr GetLengthResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLengthResponse(const GetLengthResponse& from);
  GetLengthResponse(GetLengthResponse&& from) noexcept
    : GetLengthResponse() {
    *this = ::std::move(from);
  }

  inline GetLengthResponse& operator=(const GetLengthResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLengthResponse& operator=(GetLengthResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLengthResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLengthResponse* internal_default_instance() {
    return reinterpret_cast<const GetLengthResponse*>(
               &_GetLengthResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetLengthResponse& a, GetLengthResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLengthResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLengthResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLengthResponse* New() const final {
    return new GetLengthResponse();
  }

  GetLengthResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLengthResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLengthResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLengthResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLengthResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.GetLengthResponse";
  }
  protected:
  explicit GetLengthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLenFieldNumber = 1,
  };
  // int32 len = 1;
  void clear_len();
  ::PROTOBUF_NAMESPACE_ID::int32 len() const;
  void set_len(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_len() const;
  void _internal_set_len(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.GetLengthResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 len_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class GetWholeLength final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.GetWholeLength) */ {
 public:
  inline GetWholeLength() : GetWholeLength(nullptr) {}
  ~GetWholeLength() override;
  explicit constexpr GetWholeLength(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWholeLength(const GetWholeLength& from);
  GetWholeLength(GetWholeLength&& from) noexcept
    : GetWholeLength() {
    *this = ::std::move(from);
  }

  inline GetWholeLength& operator=(const GetWholeLength& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWholeLength& operator=(GetWholeLength&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWholeLength& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWholeLength* internal_default_instance() {
    return reinterpret_cast<const GetWholeLength*>(
               &_GetWholeLength_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetWholeLength& a, GetWholeLength& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWholeLength* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWholeLength* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetWholeLength* New() const final {
    return new GetWholeLength();
  }

  GetWholeLength* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetWholeLength>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWholeLength& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetWholeLength& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWholeLength* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.GetWholeLength";
  }
  protected:
  explicit GetWholeLength(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderIdFieldNumber = 1,
    kInLenFieldNumber = 2,
    kIsFirstFieldNumber = 3,
  };
  // int32 senderId = 1;
  void clear_senderid();
  ::PROTOBUF_NAMESPACE_ID::int32 senderid() const;
  void set_senderid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_senderid() const;
  void _internal_set_senderid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 inLen = 2;
  void clear_inlen();
  ::PROTOBUF_NAMESPACE_ID::int32 inlen() const;
  void set_inlen(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_inlen() const;
  void _internal_set_inlen(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool isFirst = 3;
  void clear_isfirst();
  bool isfirst() const;
  void set_isfirst(bool value);
  private:
  bool _internal_isfirst() const;
  void _internal_set_isfirst(bool value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.GetWholeLength)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 senderid_;
  ::PROTOBUF_NAMESPACE_ID::int32 inlen_;
  bool isfirst_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class GenerateAESKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.GenerateAESKeyRequest) */ {
 public:
  inline GenerateAESKeyRequest() : GenerateAESKeyRequest(nullptr) {}
  ~GenerateAESKeyRequest() override;
  explicit constexpr GenerateAESKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateAESKeyRequest(const GenerateAESKeyRequest& from);
  GenerateAESKeyRequest(GenerateAESKeyRequest&& from) noexcept
    : GenerateAESKeyRequest() {
    *this = ::std::move(from);
  }

  inline GenerateAESKeyRequest& operator=(const GenerateAESKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateAESKeyRequest& operator=(GenerateAESKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateAESKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateAESKeyRequest* internal_default_instance() {
    return reinterpret_cast<const GenerateAESKeyRequest*>(
               &_GenerateAESKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GenerateAESKeyRequest& a, GenerateAESKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateAESKeyRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateAESKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenerateAESKeyRequest* New() const final {
    return new GenerateAESKeyRequest();
  }

  GenerateAESKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenerateAESKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateAESKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GenerateAESKeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateAESKeyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.GenerateAESKeyRequest";
  }
  protected:
  explicit GenerateAESKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 2,
    kUserIdFieldNumber = 1,
    kKeyLengthFieldNumber = 3,
    kDestUserIdFieldNumber = 4,
  };
  // repeated .crypto.KeyPermission permissions = 2;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  private:
  ::crypto::KeyPermission _internal_permissions(int index) const;
  void _internal_add_permissions(::crypto::KeyPermission value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_permissions();
  public:
  ::crypto::KeyPermission permissions(int index) const;
  void set_permissions(int index, ::crypto::KeyPermission value);
  void add_permissions(::crypto::KeyPermission value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& permissions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_permissions();

  // int32 user_id = 1;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::int32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .crypto.AESKeyLength keyLength = 3;
  void clear_keylength();
  ::crypto::AESKeyLength keylength() const;
  void set_keylength(::crypto::AESKeyLength value);
  private:
  ::crypto::AESKeyLength _internal_keylength() const;
  void _internal_set_keylength(::crypto::AESKeyLength value);
  public:

  // int32 destUserId = 4;
  void clear_destuserid();
  ::PROTOBUF_NAMESPACE_ID::int32 destuserid() const;
  void set_destuserid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_destuserid() const;
  void _internal_set_destuserid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.GenerateAESKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> permissions_;
  mutable std::atomic<int> _permissions_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 user_id_;
  int keylength_;
  ::PROTOBUF_NAMESPACE_ID::int32 destuserid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class GenerateAESKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.GenerateAESKeyResponse) */ {
 public:
  inline GenerateAESKeyResponse() : GenerateAESKeyResponse(nullptr) {}
  ~GenerateAESKeyResponse() override;
  explicit constexpr GenerateAESKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateAESKeyResponse(const GenerateAESKeyResponse& from);
  GenerateAESKeyResponse(GenerateAESKeyResponse&& from) noexcept
    : GenerateAESKeyResponse() {
    *this = ::std::move(from);
  }

  inline GenerateAESKeyResponse& operator=(const GenerateAESKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateAESKeyResponse& operator=(GenerateAESKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateAESKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateAESKeyResponse* internal_default_instance() {
    return reinterpret_cast<const GenerateAESKeyResponse*>(
               &_GenerateAESKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GenerateAESKeyResponse& a, GenerateAESKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateAESKeyResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateAESKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenerateAESKeyResponse* New() const final {
    return new GenerateAESKeyResponse();
  }

  GenerateAESKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenerateAESKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateAESKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GenerateAESKeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateAESKeyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.GenerateAESKeyResponse";
  }
  protected:
  explicit GenerateAESKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAesKeyFieldNumber = 1,
  };
  // string aes_key = 1;
  void clear_aes_key();
  const std::string& aes_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_aes_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_aes_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_aes_key();
  void set_allocated_aes_key(std::string* aes_key);
  private:
  const std::string& _internal_aes_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aes_key(const std::string& value);
  std::string* _internal_mutable_aes_key();
  public:

  // @@protoc_insertion_point(class_scope:crypto.GenerateAESKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr aes_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class GenerateKeyPairRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.GenerateKeyPairRequest) */ {
 public:
  inline GenerateKeyPairRequest() : GenerateKeyPairRequest(nullptr) {}
  ~GenerateKeyPairRequest() override;
  explicit constexpr GenerateKeyPairRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateKeyPairRequest(const GenerateKeyPairRequest& from);
  GenerateKeyPairRequest(GenerateKeyPairRequest&& from) noexcept
    : GenerateKeyPairRequest() {
    *this = ::std::move(from);
  }

  inline GenerateKeyPairRequest& operator=(const GenerateKeyPairRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateKeyPairRequest& operator=(GenerateKeyPairRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateKeyPairRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateKeyPairRequest* internal_default_instance() {
    return reinterpret_cast<const GenerateKeyPairRequest*>(
               &_GenerateKeyPairRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GenerateKeyPairRequest& a, GenerateKeyPairRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateKeyPairRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateKeyPairRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenerateKeyPairRequest* New() const final {
    return new GenerateKeyPairRequest();
  }

  GenerateKeyPairRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenerateKeyPairRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateKeyPairRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GenerateKeyPairRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateKeyPairRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.GenerateKeyPairRequest";
  }
  protected:
  explicit GenerateKeyPairRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // repeated .crypto.KeyPermission permissions = 2;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  private:
  ::crypto::KeyPermission _internal_permissions(int index) const;
  void _internal_add_permissions(::crypto::KeyPermission value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_permissions();
  public:
  ::crypto::KeyPermission permissions(int index) const;
  void set_permissions(int index, ::crypto::KeyPermission value);
  void add_permissions(::crypto::KeyPermission value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& permissions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_permissions();

  // int32 user_id = 1;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::int32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.GenerateKeyPairRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> permissions_;
  mutable std::atomic<int> _permissions_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class GenerateKeyPairResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.GenerateKeyPairResponse) */ {
 public:
  inline GenerateKeyPairResponse() : GenerateKeyPairResponse(nullptr) {}
  ~GenerateKeyPairResponse() override;
  explicit constexpr GenerateKeyPairResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GenerateKeyPairResponse(const GenerateKeyPairResponse& from);
  GenerateKeyPairResponse(GenerateKeyPairResponse&& from) noexcept
    : GenerateKeyPairResponse() {
    *this = ::std::move(from);
  }

  inline GenerateKeyPairResponse& operator=(const GenerateKeyPairResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenerateKeyPairResponse& operator=(GenerateKeyPairResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenerateKeyPairResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenerateKeyPairResponse* internal_default_instance() {
    return reinterpret_cast<const GenerateKeyPairResponse*>(
               &_GenerateKeyPairResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GenerateKeyPairResponse& a, GenerateKeyPairResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GenerateKeyPairResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenerateKeyPairResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GenerateKeyPairResponse* New() const final {
    return new GenerateKeyPairResponse();
  }

  GenerateKeyPairResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GenerateKeyPairResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GenerateKeyPairResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GenerateKeyPairResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GenerateKeyPairResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.GenerateKeyPairResponse";
  }
  protected:
  explicit GenerateKeyPairResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kPrivateKeyFieldNumber = 2,
  };
  // string public_key = 1;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // string private_key = 2;
  void clear_private_key();
  const std::string& private_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_private_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_private_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_private_key();
  void set_allocated_private_key(std::string* private_key);
  private:
  const std::string& _internal_private_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_private_key(const std::string& value);
  std::string* _internal_mutable_private_key();
  public:

  // @@protoc_insertion_point(class_scope:crypto.GenerateKeyPairResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr private_key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class SignRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.SignRequest) */ {
 public:
  inline SignRequest() : SignRequest(nullptr) {}
  ~SignRequest() override;
  explicit constexpr SignRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignRequest(const SignRequest& from);
  SignRequest(SignRequest&& from) noexcept
    : SignRequest() {
    *this = ::std::move(from);
  }

  inline SignRequest& operator=(const SignRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignRequest& operator=(SignRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignRequest* internal_default_instance() {
    return reinterpret_cast<const SignRequest*>(
               &_SignRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SignRequest& a, SignRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SignRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignRequest* New() const final {
    return new SignRequest();
  }

  SignRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SignRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.SignRequest";
  }
  protected:
  explicit SignRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 2,
    kKeyIdFieldNumber = 6,
    kSenderIdFieldNumber = 1,
    kHashFuncFieldNumber = 3,
    kCounterFieldNumber = 5,
  };
  // bytes data = 2;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string key_id = 6;
  void clear_key_id();
  const std::string& key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_key_id();
  void set_allocated_key_id(std::string* key_id);
  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(const std::string& value);
  std::string* _internal_mutable_key_id();
  public:

  // int32 sender_id = 1;
  void clear_sender_id();
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id() const;
  void set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sender_id() const;
  void _internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .crypto.SHAAlgorithm hash_func = 3;
  void clear_hash_func();
  ::crypto::SHAAlgorithm hash_func() const;
  void set_hash_func(::crypto::SHAAlgorithm value);
  private:
  ::crypto::SHAAlgorithm _internal_hash_func() const;
  void _internal_set_hash_func(::crypto::SHAAlgorithm value);
  public:

  // int64 counter = 5;
  void clear_counter();
  ::PROTOBUF_NAMESPACE_ID::int64 counter() const;
  void set_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_counter() const;
  void _internal_set_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.SignRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id_;
  int hash_func_;
  ::PROTOBUF_NAMESPACE_ID::int64 counter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class SignResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.SignResponse) */ {
 public:
  inline SignResponse() : SignResponse(nullptr) {}
  ~SignResponse() override;
  explicit constexpr SignResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignResponse(const SignResponse& from);
  SignResponse(SignResponse&& from) noexcept
    : SignResponse() {
    *this = ::std::move(from);
  }

  inline SignResponse& operator=(const SignResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignResponse& operator=(SignResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignResponse* internal_default_instance() {
    return reinterpret_cast<const SignResponse*>(
               &_SignResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SignResponse& a, SignResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SignResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SignResponse* New() const final {
    return new SignResponse();
  }

  SignResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SignResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SignResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.SignResponse";
  }
  protected:
  explicit SignResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 1,
  };
  // bytes signature = 1;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // @@protoc_insertion_point(class_scope:crypto.SignResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class VerifyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.VerifyRequest) */ {
 public:
  inline VerifyRequest() : VerifyRequest(nullptr) {}
  ~VerifyRequest() override;
  explicit constexpr VerifyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyRequest(const VerifyRequest& from);
  VerifyRequest(VerifyRequest&& from) noexcept
    : VerifyRequest() {
    *this = ::std::move(from);
  }

  inline VerifyRequest& operator=(const VerifyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyRequest& operator=(VerifyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyRequest*>(
               &_VerifyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(VerifyRequest& a, VerifyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VerifyRequest* New() const final {
    return new VerifyRequest();
  }

  VerifyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VerifyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VerifyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.VerifyRequest";
  }
  protected:
  explicit VerifyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kSignatureFieldNumber = 4,
    kKeyIdFieldNumber = 6,
    kSenderIdFieldNumber = 1,
    kReceiverIdFieldNumber = 2,
    kHashFuncFieldNumber = 5,
    kCounterFieldNumber = 7,
  };
  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // bytes signature = 4;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // string key_id = 6;
  void clear_key_id();
  const std::string& key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_key_id();
  void set_allocated_key_id(std::string* key_id);
  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(const std::string& value);
  std::string* _internal_mutable_key_id();
  public:

  // int32 sender_id = 1;
  void clear_sender_id();
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id() const;
  void set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sender_id() const;
  void _internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 receiver_id = 2;
  void clear_receiver_id();
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_id() const;
  void set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_receiver_id() const;
  void _internal_set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .crypto.SHAAlgorithm hash_func = 5;
  void clear_hash_func();
  ::crypto::SHAAlgorithm hash_func() const;
  void set_hash_func(::crypto::SHAAlgorithm value);
  private:
  ::crypto::SHAAlgorithm _internal_hash_func() const;
  void _internal_set_hash_func(::crypto::SHAAlgorithm value);
  public:

  // int32 counter = 7;
  void clear_counter();
  ::PROTOBUF_NAMESPACE_ID::int32 counter() const;
  void set_counter(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_counter() const;
  void _internal_set_counter(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.VerifyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_id_;
  int hash_func_;
  ::PROTOBUF_NAMESPACE_ID::int32 counter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class VerifyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.VerifyResponse) */ {
 public:
  inline VerifyResponse() : VerifyResponse(nullptr) {}
  ~VerifyResponse() override;
  explicit constexpr VerifyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyResponse(const VerifyResponse& from);
  VerifyResponse(VerifyResponse&& from) noexcept
    : VerifyResponse() {
    *this = ::std::move(from);
  }

  inline VerifyResponse& operator=(const VerifyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyResponse& operator=(VerifyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyResponse* internal_default_instance() {
    return reinterpret_cast<const VerifyResponse*>(
               &_VerifyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(VerifyResponse& a, VerifyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VerifyResponse* New() const final {
    return new VerifyResponse();
  }

  VerifyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VerifyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VerifyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.VerifyResponse";
  }
  protected:
  explicit VerifyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutFieldNumber = 2,
    kValidFieldNumber = 1,
  };
  // bytes out = 2;
  void clear_out();
  const std::string& out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_out();
  PROTOBUF_MUST_USE_RESULT std::string* release_out();
  void set_allocated_out(std::string* out);
  private:
  const std::string& _internal_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_out(const std::string& value);
  std::string* _internal_mutable_out();
  public:

  // bool valid = 1;
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.VerifyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr out_;
  bool valid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class KeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.KeyRequest) */ {
 public:
  inline KeyRequest() : KeyRequest(nullptr) {}
  ~KeyRequest() override;
  explicit constexpr KeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyRequest(const KeyRequest& from);
  KeyRequest(KeyRequest&& from) noexcept
    : KeyRequest() {
    *this = ::std::move(from);
  }

  inline KeyRequest& operator=(const KeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyRequest& operator=(KeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyRequest* internal_default_instance() {
    return reinterpret_cast<const KeyRequest*>(
               &_KeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(KeyRequest& a, KeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyRequest* New() const final {
    return new KeyRequest();
  }

  KeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KeyRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.KeyRequest";
  }
  protected:
  explicit KeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // int32 user_id = 1;
  void clear_user_id();
  ::PROTOBUF_NAMESPACE_ID::int32 user_id() const;
  void set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_user_id() const;
  void _internal_set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.KeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class KeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.KeyResponse) */ {
 public:
  inline KeyResponse() : KeyResponse(nullptr) {}
  ~KeyResponse() override;
  explicit constexpr KeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyResponse(const KeyResponse& from);
  KeyResponse(KeyResponse&& from) noexcept
    : KeyResponse() {
    *this = ::std::move(from);
  }

  inline KeyResponse& operator=(const KeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyResponse& operator=(KeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyResponse* internal_default_instance() {
    return reinterpret_cast<const KeyResponse*>(
               &_KeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(KeyResponse& a, KeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyResponse* New() const final {
    return new KeyResponse();
  }

  KeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KeyResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.KeyResponse";
  }
  protected:
  explicit KeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // @@protoc_insertion_point(class_scope:crypto.KeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class UserKeyPermissions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.UserKeyPermissions) */ {
 public:
  inline UserKeyPermissions() : UserKeyPermissions(nullptr) {}
  ~UserKeyPermissions() override;
  explicit constexpr UserKeyPermissions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UserKeyPermissions(const UserKeyPermissions& from);
  UserKeyPermissions(UserKeyPermissions&& from) noexcept
    : UserKeyPermissions() {
    *this = ::std::move(from);
  }

  inline UserKeyPermissions& operator=(const UserKeyPermissions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserKeyPermissions& operator=(UserKeyPermissions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UserKeyPermissions& default_instance() {
    return *internal_default_instance();
  }
  static inline const UserKeyPermissions* internal_default_instance() {
    return reinterpret_cast<const UserKeyPermissions*>(
               &_UserKeyPermissions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UserKeyPermissions& a, UserKeyPermissions& b) {
    a.Swap(&b);
  }
  inline void Swap(UserKeyPermissions* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UserKeyPermissions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserKeyPermissions* New() const final {
    return new UserKeyPermissions();
  }

  UserKeyPermissions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserKeyPermissions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UserKeyPermissions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UserKeyPermissions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserKeyPermissions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.UserKeyPermissions";
  }
  protected:
  explicit UserKeyPermissions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // repeated .crypto.KeyPermission permissions = 2;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  private:
  ::crypto::KeyPermission _internal_permissions(int index) const;
  void _internal_add_permissions(::crypto::KeyPermission value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_permissions();
  public:
  ::crypto::KeyPermission permissions(int index) const;
  void set_permissions(int index, ::crypto::KeyPermission value);
  void add_permissions(::crypto::KeyPermission value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& permissions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_permissions();

  // int32 userId = 1;
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.UserKeyPermissions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> permissions_;
  mutable std::atomic<int> _permissions_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class BootSystemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.BootSystemRequest) */ {
 public:
  inline BootSystemRequest() : BootSystemRequest(nullptr) {}
  ~BootSystemRequest() override;
  explicit constexpr BootSystemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BootSystemRequest(const BootSystemRequest& from);
  BootSystemRequest(BootSystemRequest&& from) noexcept
    : BootSystemRequest() {
    *this = ::std::move(from);
  }

  inline BootSystemRequest& operator=(const BootSystemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BootSystemRequest& operator=(BootSystemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BootSystemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BootSystemRequest* internal_default_instance() {
    return reinterpret_cast<const BootSystemRequest*>(
               &_BootSystemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BootSystemRequest& a, BootSystemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BootSystemRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BootSystemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BootSystemRequest* New() const final {
    return new BootSystemRequest();
  }

  BootSystemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BootSystemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BootSystemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BootSystemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BootSystemRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.BootSystemRequest";
  }
  protected:
  explicit BootSystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersIdsPermissionsFieldNumber = 1,
  };
  // repeated .crypto.UserKeyPermissions usersIdsPermissions = 1;
  int usersidspermissions_size() const;
  private:
  int _internal_usersidspermissions_size() const;
  public:
  void clear_usersidspermissions();
  ::crypto::UserKeyPermissions* mutable_usersidspermissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::crypto::UserKeyPermissions >*
      mutable_usersidspermissions();
  private:
  const ::crypto::UserKeyPermissions& _internal_usersidspermissions(int index) const;
  ::crypto::UserKeyPermissions* _internal_add_usersidspermissions();
  public:
  const ::crypto::UserKeyPermissions& usersidspermissions(int index) const;
  ::crypto::UserKeyPermissions* add_usersidspermissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::crypto::UserKeyPermissions >&
      usersidspermissions() const;

  // @@protoc_insertion_point(class_scope:crypto.BootSystemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::crypto::UserKeyPermissions > usersidspermissions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:crypto.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit constexpr Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Empty* New() const final {
    return new Empty();
  }

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:crypto.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class CryptoConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.CryptoConfig) */ {
 public:
  inline CryptoConfig() : CryptoConfig(nullptr) {}
  ~CryptoConfig() override;
  explicit constexpr CryptoConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CryptoConfig(const CryptoConfig& from);
  CryptoConfig(CryptoConfig&& from) noexcept
    : CryptoConfig() {
    *this = ::std::move(from);
  }

  inline CryptoConfig& operator=(const CryptoConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CryptoConfig& operator=(CryptoConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CryptoConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CryptoConfig* internal_default_instance() {
    return reinterpret_cast<const CryptoConfig*>(
               &_CryptoConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CryptoConfig& a, CryptoConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CryptoConfig* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CryptoConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CryptoConfig* New() const final {
    return new CryptoConfig();
  }

  CryptoConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CryptoConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CryptoConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CryptoConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CryptoConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.CryptoConfig";
  }
  protected:
  explicit CryptoConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFunctionFieldNumber = 1,
    kAesKeyLengthFieldNumber = 2,
    kAesChainingModeFieldNumber = 3,
    kAsymmetricFunctionFieldNumber = 4,
  };
  // .crypto.SHAAlgorithm hashFunction = 1;
  void clear_hashfunction();
  ::crypto::SHAAlgorithm hashfunction() const;
  void set_hashfunction(::crypto::SHAAlgorithm value);
  private:
  ::crypto::SHAAlgorithm _internal_hashfunction() const;
  void _internal_set_hashfunction(::crypto::SHAAlgorithm value);
  public:

  // .crypto.AESKeyLength aesKeyLength = 2;
  void clear_aeskeylength();
  ::crypto::AESKeyLength aeskeylength() const;
  void set_aeskeylength(::crypto::AESKeyLength value);
  private:
  ::crypto::AESKeyLength _internal_aeskeylength() const;
  void _internal_set_aeskeylength(::crypto::AESKeyLength value);
  public:

  // .crypto.AESChainingMode aesChainingMode = 3;
  void clear_aeschainingmode();
  ::crypto::AESChainingMode aeschainingmode() const;
  void set_aeschainingmode(::crypto::AESChainingMode value);
  private:
  ::crypto::AESChainingMode _internal_aeschainingmode() const;
  void _internal_set_aeschainingmode(::crypto::AESChainingMode value);
  public:

  // .crypto.AsymmetricFunction asymmetricFunction = 4;
  void clear_asymmetricfunction();
  ::crypto::AsymmetricFunction asymmetricfunction() const;
  void set_asymmetricfunction(::crypto::AsymmetricFunction value);
  private:
  ::crypto::AsymmetricFunction _internal_asymmetricfunction() const;
  void _internal_set_asymmetricfunction(::crypto::AsymmetricFunction value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.CryptoConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int hashfunction_;
  int aeskeylength_;
  int aeschainingmode_;
  int asymmetricfunction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class ConfigureRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.ConfigureRequest) */ {
 public:
  inline ConfigureRequest() : ConfigureRequest(nullptr) {}
  ~ConfigureRequest() override;
  explicit constexpr ConfigureRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfigureRequest(const ConfigureRequest& from);
  ConfigureRequest(ConfigureRequest&& from) noexcept
    : ConfigureRequest() {
    *this = ::std::move(from);
  }

  inline ConfigureRequest& operator=(const ConfigureRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfigureRequest& operator=(ConfigureRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfigureRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfigureRequest* internal_default_instance() {
    return reinterpret_cast<const ConfigureRequest*>(
               &_ConfigureRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ConfigureRequest& a, ConfigureRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfigureRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfigureRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConfigureRequest* New() const final {
    return new ConfigureRequest();
  }

  ConfigureRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConfigureRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfigureRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConfigureRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfigureRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.ConfigureRequest";
  }
  protected:
  explicit ConfigureRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // .crypto.CryptoConfig config = 2;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::crypto::CryptoConfig& config() const;
  PROTOBUF_MUST_USE_RESULT ::crypto::CryptoConfig* release_config();
  ::crypto::CryptoConfig* mutable_config();
  void set_allocated_config(::crypto::CryptoConfig* config);
  private:
  const ::crypto::CryptoConfig& _internal_config() const;
  ::crypto::CryptoConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::crypto::CryptoConfig* config);
  ::crypto::CryptoConfig* unsafe_arena_release_config();

  // int32 userId = 1;
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.ConfigureRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::crypto::CryptoConfig* config_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class AddProcessRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.AddProcessRequest) */ {
 public:
  inline AddProcessRequest() : AddProcessRequest(nullptr) {}
  ~AddProcessRequest() override;
  explicit constexpr AddProcessRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddProcessRequest(const AddProcessRequest& from);
  AddProcessRequest(AddProcessRequest&& from) noexcept
    : AddProcessRequest() {
    *this = ::std::move(from);
  }

  inline AddProcessRequest& operator=(const AddProcessRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddProcessRequest& operator=(AddProcessRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddProcessRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddProcessRequest* internal_default_instance() {
    return reinterpret_cast<const AddProcessRequest*>(
               &_AddProcessRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AddProcessRequest& a, AddProcessRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddProcessRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddProcessRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AddProcessRequest* New() const final {
    return new AddProcessRequest();
  }

  AddProcessRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AddProcessRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddProcessRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddProcessRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddProcessRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.AddProcessRequest";
  }
  protected:
  explicit AddProcessRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // repeated .crypto.KeyPermission permissions = 2;
  int permissions_size() const;
  private:
  int _internal_permissions_size() const;
  public:
  void clear_permissions();
  private:
  ::crypto::KeyPermission _internal_permissions(int index) const;
  void _internal_add_permissions(::crypto::KeyPermission value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_permissions();
  public:
  ::crypto::KeyPermission permissions(int index) const;
  void set_permissions(int index, ::crypto::KeyPermission value);
  void add_permissions(::crypto::KeyPermission value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& permissions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_permissions();

  // int32 userId = 1;
  void clear_userid();
  ::PROTOBUF_NAMESPACE_ID::int32 userid() const;
  void set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_userid() const;
  void _internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.AddProcessRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> permissions_;
  mutable std::atomic<int> _permissions_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class EncryptRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.EncryptRequest) */ {
 public:
  inline EncryptRequest() : EncryptRequest(nullptr) {}
  ~EncryptRequest() override;
  explicit constexpr EncryptRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EncryptRequest(const EncryptRequest& from);
  EncryptRequest(EncryptRequest&& from) noexcept
    : EncryptRequest() {
    *this = ::std::move(from);
  }

  inline EncryptRequest& operator=(const EncryptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncryptRequest& operator=(EncryptRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncryptRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncryptRequest* internal_default_instance() {
    return reinterpret_cast<const EncryptRequest*>(
               &_EncryptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(EncryptRequest& a, EncryptRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EncryptRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncryptRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EncryptRequest* New() const final {
    return new EncryptRequest();
  }

  EncryptRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EncryptRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EncryptRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EncryptRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncryptRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.EncryptRequest";
  }
  protected:
  explicit EncryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kSenderIdFieldNumber = 1,
    kReceiverIdFieldNumber = 2,
    kCounterFieldNumber = 4,
    kIsFirstFieldNumber = 5,
  };
  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int32 sender_id = 1;
  void clear_sender_id();
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id() const;
  void set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sender_id() const;
  void _internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 receiver_id = 2;
  void clear_receiver_id();
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_id() const;
  void set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_receiver_id() const;
  void _internal_set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 counter = 4;
  void clear_counter();
  ::PROTOBUF_NAMESPACE_ID::int64 counter() const;
  void set_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_counter() const;
  void _internal_set_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool isFirst = 5;
  void clear_isfirst();
  bool isfirst() const;
  void set_isfirst(bool value);
  private:
  bool _internal_isfirst() const;
  void _internal_set_isfirst(bool value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.EncryptRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 counter_;
  bool isfirst_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class EncryptResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.EncryptResponse) */ {
 public:
  inline EncryptResponse() : EncryptResponse(nullptr) {}
  ~EncryptResponse() override;
  explicit constexpr EncryptResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EncryptResponse(const EncryptResponse& from);
  EncryptResponse(EncryptResponse&& from) noexcept
    : EncryptResponse() {
    *this = ::std::move(from);
  }

  inline EncryptResponse& operator=(const EncryptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EncryptResponse& operator=(EncryptResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EncryptResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EncryptResponse* internal_default_instance() {
    return reinterpret_cast<const EncryptResponse*>(
               &_EncryptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(EncryptResponse& a, EncryptResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EncryptResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EncryptResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EncryptResponse* New() const final {
    return new EncryptResponse();
  }

  EncryptResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EncryptResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EncryptResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EncryptResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EncryptResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.EncryptResponse";
  }
  protected:
  explicit EncryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncryptedDataFieldNumber = 1,
    kSignatureFieldNumber = 2,
  };
  // bytes encrypted_data = 1;
  void clear_encrypted_data();
  const std::string& encrypted_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_encrypted_data();
  void set_allocated_encrypted_data(std::string* encrypted_data);
  private:
  const std::string& _internal_encrypted_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_data(const std::string& value);
  std::string* _internal_mutable_encrypted_data();
  public:

  // bytes signature = 2;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // @@protoc_insertion_point(class_scope:crypto.EncryptResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class DecryptRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.DecryptRequest) */ {
 public:
  inline DecryptRequest() : DecryptRequest(nullptr) {}
  ~DecryptRequest() override;
  explicit constexpr DecryptRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecryptRequest(const DecryptRequest& from);
  DecryptRequest(DecryptRequest&& from) noexcept
    : DecryptRequest() {
    *this = ::std::move(from);
  }

  inline DecryptRequest& operator=(const DecryptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecryptRequest& operator=(DecryptRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecryptRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecryptRequest* internal_default_instance() {
    return reinterpret_cast<const DecryptRequest*>(
               &_DecryptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(DecryptRequest& a, DecryptRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DecryptRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecryptRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecryptRequest* New() const final {
    return new DecryptRequest();
  }

  DecryptRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecryptRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecryptRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DecryptRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecryptRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.DecryptRequest";
  }
  protected:
  explicit DecryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncryptedDataFieldNumber = 3,
    kSignatureFieldNumber = 5,
    kSenderIdFieldNumber = 1,
    kReceiverIdFieldNumber = 2,
    kCounterFieldNumber = 4,
    kIsFirstFieldNumber = 6,
  };
  // bytes encrypted_data = 3;
  void clear_encrypted_data();
  const std::string& encrypted_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_encrypted_data();
  void set_allocated_encrypted_data(std::string* encrypted_data);
  private:
  const std::string& _internal_encrypted_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_data(const std::string& value);
  std::string* _internal_mutable_encrypted_data();
  public:

  // bytes signature = 5;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // int32 sender_id = 1;
  void clear_sender_id();
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id() const;
  void set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sender_id() const;
  void _internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 receiver_id = 2;
  void clear_receiver_id();
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_id() const;
  void set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_receiver_id() const;
  void _internal_set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 counter = 4;
  void clear_counter();
  ::PROTOBUF_NAMESPACE_ID::int64 counter() const;
  void set_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_counter() const;
  void _internal_set_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool isFirst = 6;
  void clear_isfirst();
  bool isfirst() const;
  void set_isfirst(bool value);
  private:
  bool _internal_isfirst() const;
  void _internal_set_isfirst(bool value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.DecryptRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 counter_;
  bool isfirst_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class DecryptResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.DecryptResponse) */ {
 public:
  inline DecryptResponse() : DecryptResponse(nullptr) {}
  ~DecryptResponse() override;
  explicit constexpr DecryptResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecryptResponse(const DecryptResponse& from);
  DecryptResponse(DecryptResponse&& from) noexcept
    : DecryptResponse() {
    *this = ::std::move(from);
  }

  inline DecryptResponse& operator=(const DecryptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecryptResponse& operator=(DecryptResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DecryptResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecryptResponse* internal_default_instance() {
    return reinterpret_cast<const DecryptResponse*>(
               &_DecryptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DecryptResponse& a, DecryptResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DecryptResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecryptResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DecryptResponse* New() const final {
    return new DecryptResponse();
  }

  DecryptResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DecryptResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DecryptResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DecryptResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecryptResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.DecryptResponse";
  }
  protected:
  explicit DecryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecryptedDataFieldNumber = 1,
  };
  // bytes decrypted_data = 1;
  void clear_decrypted_data();
  const std::string& decrypted_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_decrypted_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_decrypted_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_decrypted_data();
  void set_allocated_decrypted_data(std::string* decrypted_data);
  private:
  const std::string& _internal_decrypted_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_decrypted_data(const std::string& value);
  std::string* _internal_mutable_decrypted_data();
  public:

  // @@protoc_insertion_point(class_scope:crypto.DecryptResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr decrypted_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class AESEncryptRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.AESEncryptRequest) */ {
 public:
  inline AESEncryptRequest() : AESEncryptRequest(nullptr) {}
  ~AESEncryptRequest() override;
  explicit constexpr AESEncryptRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AESEncryptRequest(const AESEncryptRequest& from);
  AESEncryptRequest(AESEncryptRequest&& from) noexcept
    : AESEncryptRequest() {
    *this = ::std::move(from);
  }

  inline AESEncryptRequest& operator=(const AESEncryptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AESEncryptRequest& operator=(AESEncryptRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AESEncryptRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AESEncryptRequest* internal_default_instance() {
    return reinterpret_cast<const AESEncryptRequest*>(
               &_AESEncryptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(AESEncryptRequest& a, AESEncryptRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AESEncryptRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AESEncryptRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AESEncryptRequest* New() const final {
    return new AESEncryptRequest();
  }

  AESEncryptRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AESEncryptRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AESEncryptRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AESEncryptRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AESEncryptRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.AESEncryptRequest";
  }
  protected:
  explicit AESEncryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kKeyIdFieldNumber = 6,
    kSenderIdFieldNumber = 1,
    kReceiverIdFieldNumber = 2,
    kCounterFieldNumber = 5,
    kFuncFieldNumber = 4,
    kKeyLengthFieldNumber = 7,
    kChainingModeFieldNumber = 8,
    kIsFirstFieldNumber = 9,
  };
  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // string key_id = 6;
  void clear_key_id();
  const std::string& key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_key_id();
  void set_allocated_key_id(std::string* key_id);
  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(const std::string& value);
  std::string* _internal_mutable_key_id();
  public:

  // int32 sender_id = 1;
  void clear_sender_id();
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id() const;
  void set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sender_id() const;
  void _internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 receiver_id = 2;
  void clear_receiver_id();
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_id() const;
  void set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_receiver_id() const;
  void _internal_set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 counter = 5;
  void clear_counter();
  ::PROTOBUF_NAMESPACE_ID::int64 counter() const;
  void set_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_counter() const;
  void _internal_set_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .crypto.AsymmetricFunction func = 4;
  void clear_func();
  ::crypto::AsymmetricFunction func() const;
  void set_func(::crypto::AsymmetricFunction value);
  private:
  ::crypto::AsymmetricFunction _internal_func() const;
  void _internal_set_func(::crypto::AsymmetricFunction value);
  public:

  // .crypto.AESKeyLength key_length = 7;
  void clear_key_length();
  ::crypto::AESKeyLength key_length() const;
  void set_key_length(::crypto::AESKeyLength value);
  private:
  ::crypto::AESKeyLength _internal_key_length() const;
  void _internal_set_key_length(::crypto::AESKeyLength value);
  public:

  // .crypto.AESChainingMode chainingMode = 8;
  void clear_chainingmode();
  ::crypto::AESChainingMode chainingmode() const;
  void set_chainingmode(::crypto::AESChainingMode value);
  private:
  ::crypto::AESChainingMode _internal_chainingmode() const;
  void _internal_set_chainingmode(::crypto::AESChainingMode value);
  public:

  // bool isFirst = 9;
  void clear_isfirst();
  bool isfirst() const;
  void set_isfirst(bool value);
  private:
  bool _internal_isfirst() const;
  void _internal_set_isfirst(bool value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.AESEncryptRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 counter_;
  int func_;
  int key_length_;
  int chainingmode_;
  bool isfirst_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class AESEncryptResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.AESEncryptResponse) */ {
 public:
  inline AESEncryptResponse() : AESEncryptResponse(nullptr) {}
  ~AESEncryptResponse() override;
  explicit constexpr AESEncryptResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AESEncryptResponse(const AESEncryptResponse& from);
  AESEncryptResponse(AESEncryptResponse&& from) noexcept
    : AESEncryptResponse() {
    *this = ::std::move(from);
  }

  inline AESEncryptResponse& operator=(const AESEncryptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AESEncryptResponse& operator=(AESEncryptResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AESEncryptResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AESEncryptResponse* internal_default_instance() {
    return reinterpret_cast<const AESEncryptResponse*>(
               &_AESEncryptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(AESEncryptResponse& a, AESEncryptResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AESEncryptResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AESEncryptResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AESEncryptResponse* New() const final {
    return new AESEncryptResponse();
  }

  AESEncryptResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AESEncryptResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AESEncryptResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AESEncryptResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AESEncryptResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.AESEncryptResponse";
  }
  protected:
  explicit AESEncryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncryptedDataFieldNumber = 1,
  };
  // bytes encrypted_data = 1;
  void clear_encrypted_data();
  const std::string& encrypted_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_encrypted_data();
  void set_allocated_encrypted_data(std::string* encrypted_data);
  private:
  const std::string& _internal_encrypted_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_data(const std::string& value);
  std::string* _internal_mutable_encrypted_data();
  public:

  // @@protoc_insertion_point(class_scope:crypto.AESEncryptResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class AESDecryptRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.AESDecryptRequest) */ {
 public:
  inline AESDecryptRequest() : AESDecryptRequest(nullptr) {}
  ~AESDecryptRequest() override;
  explicit constexpr AESDecryptRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AESDecryptRequest(const AESDecryptRequest& from);
  AESDecryptRequest(AESDecryptRequest&& from) noexcept
    : AESDecryptRequest() {
    *this = ::std::move(from);
  }

  inline AESDecryptRequest& operator=(const AESDecryptRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AESDecryptRequest& operator=(AESDecryptRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AESDecryptRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AESDecryptRequest* internal_default_instance() {
    return reinterpret_cast<const AESDecryptRequest*>(
               &_AESDecryptRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(AESDecryptRequest& a, AESDecryptRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AESDecryptRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AESDecryptRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AESDecryptRequest* New() const final {
    return new AESDecryptRequest();
  }

  AESDecryptRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AESDecryptRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AESDecryptRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AESDecryptRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AESDecryptRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.AESDecryptRequest";
  }
  protected:
  explicit AESDecryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataInFieldNumber = 3,
    kDataOutFieldNumber = 5,
    kKeyIdFieldNumber = 10,
    kSenderIdFieldNumber = 1,
    kReceiverIdFieldNumber = 2,
    kInLenFieldNumber = 4,
    kFuncFieldNumber = 6,
    kKeyLengthFieldNumber = 7,
    kChainingModeFieldNumber = 8,
    kCounterFieldNumber = 9,
    kIsFirstFieldNumber = 11,
  };
  // bytes data_in = 3;
  void clear_data_in();
  const std::string& data_in() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_in(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_in();
  PROTOBUF_MUST_USE_RESULT std::string* release_data_in();
  void set_allocated_data_in(std::string* data_in);
  private:
  const std::string& _internal_data_in() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_in(const std::string& value);
  std::string* _internal_mutable_data_in();
  public:

  // bytes data_out = 5;
  void clear_data_out();
  const std::string& data_out() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_out(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_out();
  PROTOBUF_MUST_USE_RESULT std::string* release_data_out();
  void set_allocated_data_out(std::string* data_out);
  private:
  const std::string& _internal_data_out() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_out(const std::string& value);
  std::string* _internal_mutable_data_out();
  public:

  // string key_id = 10;
  void clear_key_id();
  const std::string& key_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_key_id();
  void set_allocated_key_id(std::string* key_id);
  private:
  const std::string& _internal_key_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_id(const std::string& value);
  std::string* _internal_mutable_key_id();
  public:

  // int32 sender_id = 1;
  void clear_sender_id();
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id() const;
  void set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_sender_id() const;
  void _internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 receiver_id = 2;
  void clear_receiver_id();
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_id() const;
  void set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_receiver_id() const;
  void _internal_set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 in_len = 4;
  void clear_in_len();
  ::PROTOBUF_NAMESPACE_ID::int32 in_len() const;
  void set_in_len(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_in_len() const;
  void _internal_set_in_len(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .crypto.AsymmetricFunction func = 6;
  void clear_func();
  ::crypto::AsymmetricFunction func() const;
  void set_func(::crypto::AsymmetricFunction value);
  private:
  ::crypto::AsymmetricFunction _internal_func() const;
  void _internal_set_func(::crypto::AsymmetricFunction value);
  public:

  // .crypto.AESKeyLength key_length = 7;
  void clear_key_length();
  ::crypto::AESKeyLength key_length() const;
  void set_key_length(::crypto::AESKeyLength value);
  private:
  ::crypto::AESKeyLength _internal_key_length() const;
  void _internal_set_key_length(::crypto::AESKeyLength value);
  public:

  // .crypto.AESChainingMode chainingMode = 8;
  void clear_chainingmode();
  ::crypto::AESChainingMode chainingmode() const;
  void set_chainingmode(::crypto::AESChainingMode value);
  private:
  ::crypto::AESChainingMode _internal_chainingmode() const;
  void _internal_set_chainingmode(::crypto::AESChainingMode value);
  public:

  // int64 counter = 9;
  void clear_counter();
  ::PROTOBUF_NAMESPACE_ID::int64 counter() const;
  void set_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_counter() const;
  void _internal_set_counter(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool isFirst = 11;
  void clear_isfirst();
  bool isfirst() const;
  void set_isfirst(bool value);
  private:
  bool _internal_isfirst() const;
  void _internal_set_isfirst(bool value);
  public:

  // @@protoc_insertion_point(class_scope:crypto.AESDecryptRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_in_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_out_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 sender_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 receiver_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 in_len_;
  int func_;
  int key_length_;
  int chainingmode_;
  ::PROTOBUF_NAMESPACE_ID::int64 counter_;
  bool isfirst_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// -------------------------------------------------------------------

class AESDecryptResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:crypto.AESDecryptResponse) */ {
 public:
  inline AESDecryptResponse() : AESDecryptResponse(nullptr) {}
  ~AESDecryptResponse() override;
  explicit constexpr AESDecryptResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AESDecryptResponse(const AESDecryptResponse& from);
  AESDecryptResponse(AESDecryptResponse&& from) noexcept
    : AESDecryptResponse() {
    *this = ::std::move(from);
  }

  inline AESDecryptResponse& operator=(const AESDecryptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AESDecryptResponse& operator=(AESDecryptResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AESDecryptResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AESDecryptResponse* internal_default_instance() {
    return reinterpret_cast<const AESDecryptResponse*>(
               &_AESDecryptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(AESDecryptResponse& a, AESDecryptResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AESDecryptResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AESDecryptResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AESDecryptResponse* New() const final {
    return new AESDecryptResponse();
  }

  AESDecryptResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AESDecryptResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AESDecryptResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AESDecryptResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AESDecryptResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "crypto.AESDecryptResponse";
  }
  protected:
  explicit AESDecryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecryptedDataFieldNumber = 1,
  };
  // bytes decrypted_data = 1;
  void clear_decrypted_data();
  const std::string& decrypted_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_decrypted_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_decrypted_data();
  PROTOBUF_MUST_USE_RESULT std::string* release_decrypted_data();
  void set_allocated_decrypted_data(std::string* decrypted_data);
  private:
  const std::string& _internal_decrypted_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_decrypted_data(const std::string& value);
  std::string* _internal_mutable_decrypted_data();
  public:

  // @@protoc_insertion_point(class_scope:crypto.AESDecryptResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr decrypted_data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_encryption_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AsymetricEncryptRequest

// int32 senderId = 1;
inline void AsymetricEncryptRequest::clear_senderid() {
  senderid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymetricEncryptRequest::_internal_senderid() const {
  return senderid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymetricEncryptRequest::senderid() const {
  // @@protoc_insertion_point(field_get:crypto.AsymetricEncryptRequest.senderId)
  return _internal_senderid();
}
inline void AsymetricEncryptRequest::_internal_set_senderid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  senderid_ = value;
}
inline void AsymetricEncryptRequest::set_senderid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_senderid(value);
  // @@protoc_insertion_point(field_set:crypto.AsymetricEncryptRequest.senderId)
}

// string keyId = 2;
inline void AsymetricEncryptRequest::clear_keyid() {
  keyid_.ClearToEmpty();
}
inline const std::string& AsymetricEncryptRequest::keyid() const {
  // @@protoc_insertion_point(field_get:crypto.AsymetricEncryptRequest.keyId)
  return _internal_keyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AsymetricEncryptRequest::set_keyid(ArgT0&& arg0, ArgT... args) {
 
 keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.AsymetricEncryptRequest.keyId)
}
inline std::string* AsymetricEncryptRequest::mutable_keyid() {
  std::string* _s = _internal_mutable_keyid();
  // @@protoc_insertion_point(field_mutable:crypto.AsymetricEncryptRequest.keyId)
  return _s;
}
inline const std::string& AsymetricEncryptRequest::_internal_keyid() const {
  return keyid_.Get();
}
inline void AsymetricEncryptRequest::_internal_set_keyid(const std::string& value) {
  
  keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AsymetricEncryptRequest::_internal_mutable_keyid() {
  
  return keyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AsymetricEncryptRequest::release_keyid() {
  // @@protoc_insertion_point(field_release:crypto.AsymetricEncryptRequest.keyId)
  return keyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AsymetricEncryptRequest::set_allocated_keyid(std::string* keyid) {
  if (keyid != nullptr) {
    
  } else {
    
  }
  keyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keyid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.AsymetricEncryptRequest.keyId)
}

// bytes data = 3;
inline void AsymetricEncryptRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& AsymetricEncryptRequest::data() const {
  // @@protoc_insertion_point(field_get:crypto.AsymetricEncryptRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AsymetricEncryptRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.AsymetricEncryptRequest.data)
}
inline std::string* AsymetricEncryptRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:crypto.AsymetricEncryptRequest.data)
  return _s;
}
inline const std::string& AsymetricEncryptRequest::_internal_data() const {
  return data_.Get();
}
inline void AsymetricEncryptRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AsymetricEncryptRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AsymetricEncryptRequest::release_data() {
  // @@protoc_insertion_point(field_release:crypto.AsymetricEncryptRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AsymetricEncryptRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.AsymetricEncryptRequest.data)
}

// -------------------------------------------------------------------

// AsymetricEncryptResponse

// bytes encrypted_data = 1;
inline void AsymetricEncryptResponse::clear_encrypted_data() {
  encrypted_data_.ClearToEmpty();
}
inline const std::string& AsymetricEncryptResponse::encrypted_data() const {
  // @@protoc_insertion_point(field_get:crypto.AsymetricEncryptResponse.encrypted_data)
  return _internal_encrypted_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AsymetricEncryptResponse::set_encrypted_data(ArgT0&& arg0, ArgT... args) {
 
 encrypted_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.AsymetricEncryptResponse.encrypted_data)
}
inline std::string* AsymetricEncryptResponse::mutable_encrypted_data() {
  std::string* _s = _internal_mutable_encrypted_data();
  // @@protoc_insertion_point(field_mutable:crypto.AsymetricEncryptResponse.encrypted_data)
  return _s;
}
inline const std::string& AsymetricEncryptResponse::_internal_encrypted_data() const {
  return encrypted_data_.Get();
}
inline void AsymetricEncryptResponse::_internal_set_encrypted_data(const std::string& value) {
  
  encrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AsymetricEncryptResponse::_internal_mutable_encrypted_data() {
  
  return encrypted_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AsymetricEncryptResponse::release_encrypted_data() {
  // @@protoc_insertion_point(field_release:crypto.AsymetricEncryptResponse.encrypted_data)
  return encrypted_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AsymetricEncryptResponse::set_allocated_encrypted_data(std::string* encrypted_data) {
  if (encrypted_data != nullptr) {
    
  } else {
    
  }
  encrypted_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.AsymetricEncryptResponse.encrypted_data)
}

// -------------------------------------------------------------------

// AsymetricDecryptRequest

// int32 receiverId = 1;
inline void AsymetricDecryptRequest::clear_receiverid() {
  receiverid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymetricDecryptRequest::_internal_receiverid() const {
  return receiverid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AsymetricDecryptRequest::receiverid() const {
  // @@protoc_insertion_point(field_get:crypto.AsymetricDecryptRequest.receiverId)
  return _internal_receiverid();
}
inline void AsymetricDecryptRequest::_internal_set_receiverid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  receiverid_ = value;
}
inline void AsymetricDecryptRequest::set_receiverid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_receiverid(value);
  // @@protoc_insertion_point(field_set:crypto.AsymetricDecryptRequest.receiverId)
}

// string keyId = 2;
inline void AsymetricDecryptRequest::clear_keyid() {
  keyid_.ClearToEmpty();
}
inline const std::string& AsymetricDecryptRequest::keyid() const {
  // @@protoc_insertion_point(field_get:crypto.AsymetricDecryptRequest.keyId)
  return _internal_keyid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AsymetricDecryptRequest::set_keyid(ArgT0&& arg0, ArgT... args) {
 
 keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.AsymetricDecryptRequest.keyId)
}
inline std::string* AsymetricDecryptRequest::mutable_keyid() {
  std::string* _s = _internal_mutable_keyid();
  // @@protoc_insertion_point(field_mutable:crypto.AsymetricDecryptRequest.keyId)
  return _s;
}
inline const std::string& AsymetricDecryptRequest::_internal_keyid() const {
  return keyid_.Get();
}
inline void AsymetricDecryptRequest::_internal_set_keyid(const std::string& value) {
  
  keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AsymetricDecryptRequest::_internal_mutable_keyid() {
  
  return keyid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AsymetricDecryptRequest::release_keyid() {
  // @@protoc_insertion_point(field_release:crypto.AsymetricDecryptRequest.keyId)
  return keyid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AsymetricDecryptRequest::set_allocated_keyid(std::string* keyid) {
  if (keyid != nullptr) {
    
  } else {
    
  }
  keyid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), keyid,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.AsymetricDecryptRequest.keyId)
}

// bytes data = 3;
inline void AsymetricDecryptRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& AsymetricDecryptRequest::data() const {
  // @@protoc_insertion_point(field_get:crypto.AsymetricDecryptRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AsymetricDecryptRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.AsymetricDecryptRequest.data)
}
inline std::string* AsymetricDecryptRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:crypto.AsymetricDecryptRequest.data)
  return _s;
}
inline const std::string& AsymetricDecryptRequest::_internal_data() const {
  return data_.Get();
}
inline void AsymetricDecryptRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AsymetricDecryptRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AsymetricDecryptRequest::release_data() {
  // @@protoc_insertion_point(field_release:crypto.AsymetricDecryptRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AsymetricDecryptRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.AsymetricDecryptRequest.data)
}

// -------------------------------------------------------------------

// GetHashLengthRequest

// .crypto.SHAAlgorithm func = 1;
inline void GetHashLengthRequest::clear_func() {
  func_ = 0;
}
inline ::crypto::SHAAlgorithm GetHashLengthRequest::_internal_func() const {
  return static_cast< ::crypto::SHAAlgorithm >(func_);
}
inline ::crypto::SHAAlgorithm GetHashLengthRequest::func() const {
  // @@protoc_insertion_point(field_get:crypto.GetHashLengthRequest.func)
  return _internal_func();
}
inline void GetHashLengthRequest::_internal_set_func(::crypto::SHAAlgorithm value) {
  
  func_ = value;
}
inline void GetHashLengthRequest::set_func(::crypto::SHAAlgorithm value) {
  _internal_set_func(value);
  // @@protoc_insertion_point(field_set:crypto.GetHashLengthRequest.func)
}

// int32 dataLen = 2;
inline void GetHashLengthRequest::clear_datalen() {
  datalen_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetHashLengthRequest::_internal_datalen() const {
  return datalen_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetHashLengthRequest::datalen() const {
  // @@protoc_insertion_point(field_get:crypto.GetHashLengthRequest.dataLen)
  return _internal_datalen();
}
inline void GetHashLengthRequest::_internal_set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  datalen_ = value;
}
inline void GetHashLengthRequest::set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_datalen(value);
  // @@protoc_insertion_point(field_set:crypto.GetHashLengthRequest.dataLen)
}

// -------------------------------------------------------------------

// GetAESLengthRequest

// int32 dataLen = 1;
inline void GetAESLengthRequest::clear_datalen() {
  datalen_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetAESLengthRequest::_internal_datalen() const {
  return datalen_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetAESLengthRequest::datalen() const {
  // @@protoc_insertion_point(field_get:crypto.GetAESLengthRequest.dataLen)
  return _internal_datalen();
}
inline void GetAESLengthRequest::_internal_set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  datalen_ = value;
}
inline void GetAESLengthRequest::set_datalen(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_datalen(value);
  // @@protoc_insertion_point(field_set:crypto.GetAESLengthRequest.dataLen)
}

// bool isFirst = 2;
inline void GetAESLengthRequest::clear_isfirst() {
  isfirst_ = false;
}
inline bool GetAESLengthRequest::_internal_isfirst() const {
  return isfirst_;
}
inline bool GetAESLengthRequest::isfirst() const {
  // @@protoc_insertion_point(field_get:crypto.GetAESLengthRequest.isFirst)
  return _internal_isfirst();
}
inline void GetAESLengthRequest::_internal_set_isfirst(bool value) {
  
  isfirst_ = value;
}
inline void GetAESLengthRequest::set_isfirst(bool value) {
  _internal_set_isfirst(value);
  // @@protoc_insertion_point(field_set:crypto.GetAESLengthRequest.isFirst)
}

// .crypto.AESChainingMode chainingMode = 3;
inline void GetAESLengthRequest::clear_chainingmode() {
  chainingmode_ = 0;
}
inline ::crypto::AESChainingMode GetAESLengthRequest::_internal_chainingmode() const {
  return static_cast< ::crypto::AESChainingMode >(chainingmode_);
}
inline ::crypto::AESChainingMode GetAESLengthRequest::chainingmode() const {
  // @@protoc_insertion_point(field_get:crypto.GetAESLengthRequest.chainingMode)
  return _internal_chainingmode();
}
inline void GetAESLengthRequest::_internal_set_chainingmode(::crypto::AESChainingMode value) {
  
  chainingmode_ = value;
}
inline void GetAESLengthRequest::set_chainingmode(::crypto::AESChainingMode value) {
  _internal_set_chainingmode(value);
  // @@protoc_insertion_point(field_set:crypto.GetAESLengthRequest.chainingMode)
}

// -------------------------------------------------------------------

// AsymetricDecryptResponse

// bytes decrypted_data = 1;
inline void AsymetricDecryptResponse::clear_decrypted_data() {
  decrypted_data_.ClearToEmpty();
}
inline const std::string& AsymetricDecryptResponse::decrypted_data() const {
  // @@protoc_insertion_point(field_get:crypto.AsymetricDecryptResponse.decrypted_data)
  return _internal_decrypted_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AsymetricDecryptResponse::set_decrypted_data(ArgT0&& arg0, ArgT... args) {
 
 decrypted_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.AsymetricDecryptResponse.decrypted_data)
}
inline std::string* AsymetricDecryptResponse::mutable_decrypted_data() {
  std::string* _s = _internal_mutable_decrypted_data();
  // @@protoc_insertion_point(field_mutable:crypto.AsymetricDecryptResponse.decrypted_data)
  return _s;
}
inline const std::string& AsymetricDecryptResponse::_internal_decrypted_data() const {
  return decrypted_data_.Get();
}
inline void AsymetricDecryptResponse::_internal_set_decrypted_data(const std::string& value) {
  
  decrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AsymetricDecryptResponse::_internal_mutable_decrypted_data() {
  
  return decrypted_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AsymetricDecryptResponse::release_decrypted_data() {
  // @@protoc_insertion_point(field_release:crypto.AsymetricDecryptResponse.decrypted_data)
  return decrypted_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AsymetricDecryptResponse::set_allocated_decrypted_data(std::string* decrypted_data) {
  if (decrypted_data != nullptr) {
    
  } else {
    
  }
  decrypted_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), decrypted_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.AsymetricDecryptResponse.decrypted_data)
}

// -------------------------------------------------------------------

// GetLengthRequest

// int32 in_len = 1;
inline void GetLengthRequest::clear_in_len() {
  in_len_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetLengthRequest::_internal_in_len() const {
  return in_len_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetLengthRequest::in_len() const {
  // @@protoc_insertion_point(field_get:crypto.GetLengthRequest.in_len)
  return _internal_in_len();
}
inline void GetLengthRequest::_internal_set_in_len(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  in_len_ = value;
}
inline void GetLengthRequest::set_in_len(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_in_len(value);
  // @@protoc_insertion_point(field_set:crypto.GetLengthRequest.in_len)
}

// -------------------------------------------------------------------

// GetLengthResponse

// int32 len = 1;
inline void GetLengthResponse::clear_len() {
  len_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetLengthResponse::_internal_len() const {
  return len_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetLengthResponse::len() const {
  // @@protoc_insertion_point(field_get:crypto.GetLengthResponse.len)
  return _internal_len();
}
inline void GetLengthResponse::_internal_set_len(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  len_ = value;
}
inline void GetLengthResponse::set_len(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_len(value);
  // @@protoc_insertion_point(field_set:crypto.GetLengthResponse.len)
}

// -------------------------------------------------------------------

// GetWholeLength

// int32 senderId = 1;
inline void GetWholeLength::clear_senderid() {
  senderid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetWholeLength::_internal_senderid() const {
  return senderid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetWholeLength::senderid() const {
  // @@protoc_insertion_point(field_get:crypto.GetWholeLength.senderId)
  return _internal_senderid();
}
inline void GetWholeLength::_internal_set_senderid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  senderid_ = value;
}
inline void GetWholeLength::set_senderid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_senderid(value);
  // @@protoc_insertion_point(field_set:crypto.GetWholeLength.senderId)
}

// int32 inLen = 2;
inline void GetWholeLength::clear_inlen() {
  inlen_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetWholeLength::_internal_inlen() const {
  return inlen_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GetWholeLength::inlen() const {
  // @@protoc_insertion_point(field_get:crypto.GetWholeLength.inLen)
  return _internal_inlen();
}
inline void GetWholeLength::_internal_set_inlen(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  inlen_ = value;
}
inline void GetWholeLength::set_inlen(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_inlen(value);
  // @@protoc_insertion_point(field_set:crypto.GetWholeLength.inLen)
}

// bool isFirst = 3;
inline void GetWholeLength::clear_isfirst() {
  isfirst_ = false;
}
inline bool GetWholeLength::_internal_isfirst() const {
  return isfirst_;
}
inline bool GetWholeLength::isfirst() const {
  // @@protoc_insertion_point(field_get:crypto.GetWholeLength.isFirst)
  return _internal_isfirst();
}
inline void GetWholeLength::_internal_set_isfirst(bool value) {
  
  isfirst_ = value;
}
inline void GetWholeLength::set_isfirst(bool value) {
  _internal_set_isfirst(value);
  // @@protoc_insertion_point(field_set:crypto.GetWholeLength.isFirst)
}

// -------------------------------------------------------------------

// GenerateAESKeyRequest

// int32 user_id = 1;
inline void GenerateAESKeyRequest::clear_user_id() {
  user_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GenerateAESKeyRequest::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GenerateAESKeyRequest::user_id() const {
  // @@protoc_insertion_point(field_get:crypto.GenerateAESKeyRequest.user_id)
  return _internal_user_id();
}
inline void GenerateAESKeyRequest::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  user_id_ = value;
}
inline void GenerateAESKeyRequest::set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:crypto.GenerateAESKeyRequest.user_id)
}

// repeated .crypto.KeyPermission permissions = 2;
inline int GenerateAESKeyRequest::_internal_permissions_size() const {
  return permissions_.size();
}
inline int GenerateAESKeyRequest::permissions_size() const {
  return _internal_permissions_size();
}
inline void GenerateAESKeyRequest::clear_permissions() {
  permissions_.Clear();
}
inline ::crypto::KeyPermission GenerateAESKeyRequest::_internal_permissions(int index) const {
  return static_cast< ::crypto::KeyPermission >(permissions_.Get(index));
}
inline ::crypto::KeyPermission GenerateAESKeyRequest::permissions(int index) const {
  // @@protoc_insertion_point(field_get:crypto.GenerateAESKeyRequest.permissions)
  return _internal_permissions(index);
}
inline void GenerateAESKeyRequest::set_permissions(int index, ::crypto::KeyPermission value) {
  permissions_.Set(index, value);
  // @@protoc_insertion_point(field_set:crypto.GenerateAESKeyRequest.permissions)
}
inline void GenerateAESKeyRequest::_internal_add_permissions(::crypto::KeyPermission value) {
  permissions_.Add(value);
}
inline void GenerateAESKeyRequest::add_permissions(::crypto::KeyPermission value) {
  _internal_add_permissions(value);
  // @@protoc_insertion_point(field_add:crypto.GenerateAESKeyRequest.permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
GenerateAESKeyRequest::permissions() const {
  // @@protoc_insertion_point(field_list:crypto.GenerateAESKeyRequest.permissions)
  return permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
GenerateAESKeyRequest::_internal_mutable_permissions() {
  return &permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
GenerateAESKeyRequest::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:crypto.GenerateAESKeyRequest.permissions)
  return _internal_mutable_permissions();
}

// .crypto.AESKeyLength keyLength = 3;
inline void GenerateAESKeyRequest::clear_keylength() {
  keylength_ = 0;
}
inline ::crypto::AESKeyLength GenerateAESKeyRequest::_internal_keylength() const {
  return static_cast< ::crypto::AESKeyLength >(keylength_);
}
inline ::crypto::AESKeyLength GenerateAESKeyRequest::keylength() const {
  // @@protoc_insertion_point(field_get:crypto.GenerateAESKeyRequest.keyLength)
  return _internal_keylength();
}
inline void GenerateAESKeyRequest::_internal_set_keylength(::crypto::AESKeyLength value) {
  
  keylength_ = value;
}
inline void GenerateAESKeyRequest::set_keylength(::crypto::AESKeyLength value) {
  _internal_set_keylength(value);
  // @@protoc_insertion_point(field_set:crypto.GenerateAESKeyRequest.keyLength)
}

// int32 destUserId = 4;
inline void GenerateAESKeyRequest::clear_destuserid() {
  destuserid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GenerateAESKeyRequest::_internal_destuserid() const {
  return destuserid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GenerateAESKeyRequest::destuserid() const {
  // @@protoc_insertion_point(field_get:crypto.GenerateAESKeyRequest.destUserId)
  return _internal_destuserid();
}
inline void GenerateAESKeyRequest::_internal_set_destuserid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  destuserid_ = value;
}
inline void GenerateAESKeyRequest::set_destuserid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_destuserid(value);
  // @@protoc_insertion_point(field_set:crypto.GenerateAESKeyRequest.destUserId)
}

// -------------------------------------------------------------------

// GenerateAESKeyResponse

// string aes_key = 1;
inline void GenerateAESKeyResponse::clear_aes_key() {
  aes_key_.ClearToEmpty();
}
inline const std::string& GenerateAESKeyResponse::aes_key() const {
  // @@protoc_insertion_point(field_get:crypto.GenerateAESKeyResponse.aes_key)
  return _internal_aes_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateAESKeyResponse::set_aes_key(ArgT0&& arg0, ArgT... args) {
 
 aes_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.GenerateAESKeyResponse.aes_key)
}
inline std::string* GenerateAESKeyResponse::mutable_aes_key() {
  std::string* _s = _internal_mutable_aes_key();
  // @@protoc_insertion_point(field_mutable:crypto.GenerateAESKeyResponse.aes_key)
  return _s;
}
inline const std::string& GenerateAESKeyResponse::_internal_aes_key() const {
  return aes_key_.Get();
}
inline void GenerateAESKeyResponse::_internal_set_aes_key(const std::string& value) {
  
  aes_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenerateAESKeyResponse::_internal_mutable_aes_key() {
  
  return aes_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenerateAESKeyResponse::release_aes_key() {
  // @@protoc_insertion_point(field_release:crypto.GenerateAESKeyResponse.aes_key)
  return aes_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GenerateAESKeyResponse::set_allocated_aes_key(std::string* aes_key) {
  if (aes_key != nullptr) {
    
  } else {
    
  }
  aes_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), aes_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.GenerateAESKeyResponse.aes_key)
}

// -------------------------------------------------------------------

// GenerateKeyPairRequest

// int32 user_id = 1;
inline void GenerateKeyPairRequest::clear_user_id() {
  user_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GenerateKeyPairRequest::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GenerateKeyPairRequest::user_id() const {
  // @@protoc_insertion_point(field_get:crypto.GenerateKeyPairRequest.user_id)
  return _internal_user_id();
}
inline void GenerateKeyPairRequest::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  user_id_ = value;
}
inline void GenerateKeyPairRequest::set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:crypto.GenerateKeyPairRequest.user_id)
}

// repeated .crypto.KeyPermission permissions = 2;
inline int GenerateKeyPairRequest::_internal_permissions_size() const {
  return permissions_.size();
}
inline int GenerateKeyPairRequest::permissions_size() const {
  return _internal_permissions_size();
}
inline void GenerateKeyPairRequest::clear_permissions() {
  permissions_.Clear();
}
inline ::crypto::KeyPermission GenerateKeyPairRequest::_internal_permissions(int index) const {
  return static_cast< ::crypto::KeyPermission >(permissions_.Get(index));
}
inline ::crypto::KeyPermission GenerateKeyPairRequest::permissions(int index) const {
  // @@protoc_insertion_point(field_get:crypto.GenerateKeyPairRequest.permissions)
  return _internal_permissions(index);
}
inline void GenerateKeyPairRequest::set_permissions(int index, ::crypto::KeyPermission value) {
  permissions_.Set(index, value);
  // @@protoc_insertion_point(field_set:crypto.GenerateKeyPairRequest.permissions)
}
inline void GenerateKeyPairRequest::_internal_add_permissions(::crypto::KeyPermission value) {
  permissions_.Add(value);
}
inline void GenerateKeyPairRequest::add_permissions(::crypto::KeyPermission value) {
  _internal_add_permissions(value);
  // @@protoc_insertion_point(field_add:crypto.GenerateKeyPairRequest.permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
GenerateKeyPairRequest::permissions() const {
  // @@protoc_insertion_point(field_list:crypto.GenerateKeyPairRequest.permissions)
  return permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
GenerateKeyPairRequest::_internal_mutable_permissions() {
  return &permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
GenerateKeyPairRequest::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:crypto.GenerateKeyPairRequest.permissions)
  return _internal_mutable_permissions();
}

// -------------------------------------------------------------------

// GenerateKeyPairResponse

// string public_key = 1;
inline void GenerateKeyPairResponse::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& GenerateKeyPairResponse::public_key() const {
  // @@protoc_insertion_point(field_get:crypto.GenerateKeyPairResponse.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateKeyPairResponse::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.GenerateKeyPairResponse.public_key)
}
inline std::string* GenerateKeyPairResponse::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:crypto.GenerateKeyPairResponse.public_key)
  return _s;
}
inline const std::string& GenerateKeyPairResponse::_internal_public_key() const {
  return public_key_.Get();
}
inline void GenerateKeyPairResponse::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenerateKeyPairResponse::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenerateKeyPairResponse::release_public_key() {
  // @@protoc_insertion_point(field_release:crypto.GenerateKeyPairResponse.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GenerateKeyPairResponse::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.GenerateKeyPairResponse.public_key)
}

// string private_key = 2;
inline void GenerateKeyPairResponse::clear_private_key() {
  private_key_.ClearToEmpty();
}
inline const std::string& GenerateKeyPairResponse::private_key() const {
  // @@protoc_insertion_point(field_get:crypto.GenerateKeyPairResponse.private_key)
  return _internal_private_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GenerateKeyPairResponse::set_private_key(ArgT0&& arg0, ArgT... args) {
 
 private_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.GenerateKeyPairResponse.private_key)
}
inline std::string* GenerateKeyPairResponse::mutable_private_key() {
  std::string* _s = _internal_mutable_private_key();
  // @@protoc_insertion_point(field_mutable:crypto.GenerateKeyPairResponse.private_key)
  return _s;
}
inline const std::string& GenerateKeyPairResponse::_internal_private_key() const {
  return private_key_.Get();
}
inline void GenerateKeyPairResponse::_internal_set_private_key(const std::string& value) {
  
  private_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GenerateKeyPairResponse::_internal_mutable_private_key() {
  
  return private_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GenerateKeyPairResponse::release_private_key() {
  // @@protoc_insertion_point(field_release:crypto.GenerateKeyPairResponse.private_key)
  return private_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GenerateKeyPairResponse::set_allocated_private_key(std::string* private_key) {
  if (private_key != nullptr) {
    
  } else {
    
  }
  private_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), private_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.GenerateKeyPairResponse.private_key)
}

// -------------------------------------------------------------------

// SignRequest

// int32 sender_id = 1;
inline void SignRequest::clear_sender_id() {
  sender_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignRequest::_internal_sender_id() const {
  return sender_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SignRequest::sender_id() const {
  // @@protoc_insertion_point(field_get:crypto.SignRequest.sender_id)
  return _internal_sender_id();
}
inline void SignRequest::_internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sender_id_ = value;
}
inline void SignRequest::set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:crypto.SignRequest.sender_id)
}

// bytes data = 2;
inline void SignRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& SignRequest::data() const {
  // @@protoc_insertion_point(field_get:crypto.SignRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.SignRequest.data)
}
inline std::string* SignRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:crypto.SignRequest.data)
  return _s;
}
inline const std::string& SignRequest::_internal_data() const {
  return data_.Get();
}
inline void SignRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SignRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SignRequest::release_data() {
  // @@protoc_insertion_point(field_release:crypto.SignRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SignRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.SignRequest.data)
}

// .crypto.SHAAlgorithm hash_func = 3;
inline void SignRequest::clear_hash_func() {
  hash_func_ = 0;
}
inline ::crypto::SHAAlgorithm SignRequest::_internal_hash_func() const {
  return static_cast< ::crypto::SHAAlgorithm >(hash_func_);
}
inline ::crypto::SHAAlgorithm SignRequest::hash_func() const {
  // @@protoc_insertion_point(field_get:crypto.SignRequest.hash_func)
  return _internal_hash_func();
}
inline void SignRequest::_internal_set_hash_func(::crypto::SHAAlgorithm value) {
  
  hash_func_ = value;
}
inline void SignRequest::set_hash_func(::crypto::SHAAlgorithm value) {
  _internal_set_hash_func(value);
  // @@protoc_insertion_point(field_set:crypto.SignRequest.hash_func)
}

// int64 counter = 5;
inline void SignRequest::clear_counter() {
  counter_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SignRequest::_internal_counter() const {
  return counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SignRequest::counter() const {
  // @@protoc_insertion_point(field_get:crypto.SignRequest.counter)
  return _internal_counter();
}
inline void SignRequest::_internal_set_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  counter_ = value;
}
inline void SignRequest::set_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:crypto.SignRequest.counter)
}

// string key_id = 6;
inline void SignRequest::clear_key_id() {
  key_id_.ClearToEmpty();
}
inline const std::string& SignRequest::key_id() const {
  // @@protoc_insertion_point(field_get:crypto.SignRequest.key_id)
  return _internal_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignRequest::set_key_id(ArgT0&& arg0, ArgT... args) {
 
 key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.SignRequest.key_id)
}
inline std::string* SignRequest::mutable_key_id() {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:crypto.SignRequest.key_id)
  return _s;
}
inline const std::string& SignRequest::_internal_key_id() const {
  return key_id_.Get();
}
inline void SignRequest::_internal_set_key_id(const std::string& value) {
  
  key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SignRequest::_internal_mutable_key_id() {
  
  return key_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SignRequest::release_key_id() {
  // @@protoc_insertion_point(field_release:crypto.SignRequest.key_id)
  return key_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SignRequest::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    
  } else {
    
  }
  key_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.SignRequest.key_id)
}

// -------------------------------------------------------------------

// SignResponse

// bytes signature = 1;
inline void SignResponse::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& SignResponse::signature() const {
  // @@protoc_insertion_point(field_get:crypto.SignResponse.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignResponse::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.SignResponse.signature)
}
inline std::string* SignResponse::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:crypto.SignResponse.signature)
  return _s;
}
inline const std::string& SignResponse::_internal_signature() const {
  return signature_.Get();
}
inline void SignResponse::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SignResponse::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SignResponse::release_signature() {
  // @@protoc_insertion_point(field_release:crypto.SignResponse.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SignResponse::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.SignResponse.signature)
}

// -------------------------------------------------------------------

// VerifyRequest

// int32 sender_id = 1;
inline void VerifyRequest::clear_sender_id() {
  sender_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VerifyRequest::_internal_sender_id() const {
  return sender_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VerifyRequest::sender_id() const {
  // @@protoc_insertion_point(field_get:crypto.VerifyRequest.sender_id)
  return _internal_sender_id();
}
inline void VerifyRequest::_internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sender_id_ = value;
}
inline void VerifyRequest::set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:crypto.VerifyRequest.sender_id)
}

// int32 receiver_id = 2;
inline void VerifyRequest::clear_receiver_id() {
  receiver_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VerifyRequest::_internal_receiver_id() const {
  return receiver_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VerifyRequest::receiver_id() const {
  // @@protoc_insertion_point(field_get:crypto.VerifyRequest.receiver_id)
  return _internal_receiver_id();
}
inline void VerifyRequest::_internal_set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  receiver_id_ = value;
}
inline void VerifyRequest::set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_receiver_id(value);
  // @@protoc_insertion_point(field_set:crypto.VerifyRequest.receiver_id)
}

// bytes data = 3;
inline void VerifyRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& VerifyRequest::data() const {
  // @@protoc_insertion_point(field_get:crypto.VerifyRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.VerifyRequest.data)
}
inline std::string* VerifyRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:crypto.VerifyRequest.data)
  return _s;
}
inline const std::string& VerifyRequest::_internal_data() const {
  return data_.Get();
}
inline void VerifyRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyRequest::release_data() {
  // @@protoc_insertion_point(field_release:crypto.VerifyRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VerifyRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.VerifyRequest.data)
}

// bytes signature = 4;
inline void VerifyRequest::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& VerifyRequest::signature() const {
  // @@protoc_insertion_point(field_get:crypto.VerifyRequest.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyRequest::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.VerifyRequest.signature)
}
inline std::string* VerifyRequest::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:crypto.VerifyRequest.signature)
  return _s;
}
inline const std::string& VerifyRequest::_internal_signature() const {
  return signature_.Get();
}
inline void VerifyRequest::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyRequest::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyRequest::release_signature() {
  // @@protoc_insertion_point(field_release:crypto.VerifyRequest.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VerifyRequest::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.VerifyRequest.signature)
}

// .crypto.SHAAlgorithm hash_func = 5;
inline void VerifyRequest::clear_hash_func() {
  hash_func_ = 0;
}
inline ::crypto::SHAAlgorithm VerifyRequest::_internal_hash_func() const {
  return static_cast< ::crypto::SHAAlgorithm >(hash_func_);
}
inline ::crypto::SHAAlgorithm VerifyRequest::hash_func() const {
  // @@protoc_insertion_point(field_get:crypto.VerifyRequest.hash_func)
  return _internal_hash_func();
}
inline void VerifyRequest::_internal_set_hash_func(::crypto::SHAAlgorithm value) {
  
  hash_func_ = value;
}
inline void VerifyRequest::set_hash_func(::crypto::SHAAlgorithm value) {
  _internal_set_hash_func(value);
  // @@protoc_insertion_point(field_set:crypto.VerifyRequest.hash_func)
}

// string key_id = 6;
inline void VerifyRequest::clear_key_id() {
  key_id_.ClearToEmpty();
}
inline const std::string& VerifyRequest::key_id() const {
  // @@protoc_insertion_point(field_get:crypto.VerifyRequest.key_id)
  return _internal_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyRequest::set_key_id(ArgT0&& arg0, ArgT... args) {
 
 key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.VerifyRequest.key_id)
}
inline std::string* VerifyRequest::mutable_key_id() {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:crypto.VerifyRequest.key_id)
  return _s;
}
inline const std::string& VerifyRequest::_internal_key_id() const {
  return key_id_.Get();
}
inline void VerifyRequest::_internal_set_key_id(const std::string& value) {
  
  key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyRequest::_internal_mutable_key_id() {
  
  return key_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyRequest::release_key_id() {
  // @@protoc_insertion_point(field_release:crypto.VerifyRequest.key_id)
  return key_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VerifyRequest::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    
  } else {
    
  }
  key_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.VerifyRequest.key_id)
}

// int32 counter = 7;
inline void VerifyRequest::clear_counter() {
  counter_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VerifyRequest::_internal_counter() const {
  return counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VerifyRequest::counter() const {
  // @@protoc_insertion_point(field_get:crypto.VerifyRequest.counter)
  return _internal_counter();
}
inline void VerifyRequest::_internal_set_counter(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  counter_ = value;
}
inline void VerifyRequest::set_counter(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:crypto.VerifyRequest.counter)
}

// -------------------------------------------------------------------

// VerifyResponse

// bool valid = 1;
inline void VerifyResponse::clear_valid() {
  valid_ = false;
}
inline bool VerifyResponse::_internal_valid() const {
  return valid_;
}
inline bool VerifyResponse::valid() const {
  // @@protoc_insertion_point(field_get:crypto.VerifyResponse.valid)
  return _internal_valid();
}
inline void VerifyResponse::_internal_set_valid(bool value) {
  
  valid_ = value;
}
inline void VerifyResponse::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:crypto.VerifyResponse.valid)
}

// bytes out = 2;
inline void VerifyResponse::clear_out() {
  out_.ClearToEmpty();
}
inline const std::string& VerifyResponse::out() const {
  // @@protoc_insertion_point(field_get:crypto.VerifyResponse.out)
  return _internal_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyResponse::set_out(ArgT0&& arg0, ArgT... args) {
 
 out_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.VerifyResponse.out)
}
inline std::string* VerifyResponse::mutable_out() {
  std::string* _s = _internal_mutable_out();
  // @@protoc_insertion_point(field_mutable:crypto.VerifyResponse.out)
  return _s;
}
inline const std::string& VerifyResponse::_internal_out() const {
  return out_.Get();
}
inline void VerifyResponse::_internal_set_out(const std::string& value) {
  
  out_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VerifyResponse::_internal_mutable_out() {
  
  return out_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VerifyResponse::release_out() {
  // @@protoc_insertion_point(field_release:crypto.VerifyResponse.out)
  return out_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VerifyResponse::set_allocated_out(std::string* out) {
  if (out != nullptr) {
    
  } else {
    
  }
  out_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), out,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.VerifyResponse.out)
}

// -------------------------------------------------------------------

// KeyRequest

// int32 user_id = 1;
inline void KeyRequest::clear_user_id() {
  user_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KeyRequest::_internal_user_id() const {
  return user_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 KeyRequest::user_id() const {
  // @@protoc_insertion_point(field_get:crypto.KeyRequest.user_id)
  return _internal_user_id();
}
inline void KeyRequest::_internal_set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  user_id_ = value;
}
inline void KeyRequest::set_user_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:crypto.KeyRequest.user_id)
}

// -------------------------------------------------------------------

// KeyResponse

// string key = 1;
inline void KeyResponse::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& KeyResponse::key() const {
  // @@protoc_insertion_point(field_get:crypto.KeyResponse.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KeyResponse::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.KeyResponse.key)
}
inline std::string* KeyResponse::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:crypto.KeyResponse.key)
  return _s;
}
inline const std::string& KeyResponse::_internal_key() const {
  return key_.Get();
}
inline void KeyResponse::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KeyResponse::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KeyResponse::release_key() {
  // @@protoc_insertion_point(field_release:crypto.KeyResponse.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KeyResponse::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.KeyResponse.key)
}

// -------------------------------------------------------------------

// UserKeyPermissions

// int32 userId = 1;
inline void UserKeyPermissions::clear_userid() {
  userid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserKeyPermissions::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UserKeyPermissions::userid() const {
  // @@protoc_insertion_point(field_get:crypto.UserKeyPermissions.userId)
  return _internal_userid();
}
inline void UserKeyPermissions::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  userid_ = value;
}
inline void UserKeyPermissions::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:crypto.UserKeyPermissions.userId)
}

// repeated .crypto.KeyPermission permissions = 2;
inline int UserKeyPermissions::_internal_permissions_size() const {
  return permissions_.size();
}
inline int UserKeyPermissions::permissions_size() const {
  return _internal_permissions_size();
}
inline void UserKeyPermissions::clear_permissions() {
  permissions_.Clear();
}
inline ::crypto::KeyPermission UserKeyPermissions::_internal_permissions(int index) const {
  return static_cast< ::crypto::KeyPermission >(permissions_.Get(index));
}
inline ::crypto::KeyPermission UserKeyPermissions::permissions(int index) const {
  // @@protoc_insertion_point(field_get:crypto.UserKeyPermissions.permissions)
  return _internal_permissions(index);
}
inline void UserKeyPermissions::set_permissions(int index, ::crypto::KeyPermission value) {
  permissions_.Set(index, value);
  // @@protoc_insertion_point(field_set:crypto.UserKeyPermissions.permissions)
}
inline void UserKeyPermissions::_internal_add_permissions(::crypto::KeyPermission value) {
  permissions_.Add(value);
}
inline void UserKeyPermissions::add_permissions(::crypto::KeyPermission value) {
  _internal_add_permissions(value);
  // @@protoc_insertion_point(field_add:crypto.UserKeyPermissions.permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
UserKeyPermissions::permissions() const {
  // @@protoc_insertion_point(field_list:crypto.UserKeyPermissions.permissions)
  return permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UserKeyPermissions::_internal_mutable_permissions() {
  return &permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
UserKeyPermissions::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:crypto.UserKeyPermissions.permissions)
  return _internal_mutable_permissions();
}

// -------------------------------------------------------------------

// BootSystemRequest

// repeated .crypto.UserKeyPermissions usersIdsPermissions = 1;
inline int BootSystemRequest::_internal_usersidspermissions_size() const {
  return usersidspermissions_.size();
}
inline int BootSystemRequest::usersidspermissions_size() const {
  return _internal_usersidspermissions_size();
}
inline void BootSystemRequest::clear_usersidspermissions() {
  usersidspermissions_.Clear();
}
inline ::crypto::UserKeyPermissions* BootSystemRequest::mutable_usersidspermissions(int index) {
  // @@protoc_insertion_point(field_mutable:crypto.BootSystemRequest.usersIdsPermissions)
  return usersidspermissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::crypto::UserKeyPermissions >*
BootSystemRequest::mutable_usersidspermissions() {
  // @@protoc_insertion_point(field_mutable_list:crypto.BootSystemRequest.usersIdsPermissions)
  return &usersidspermissions_;
}
inline const ::crypto::UserKeyPermissions& BootSystemRequest::_internal_usersidspermissions(int index) const {
  return usersidspermissions_.Get(index);
}
inline const ::crypto::UserKeyPermissions& BootSystemRequest::usersidspermissions(int index) const {
  // @@protoc_insertion_point(field_get:crypto.BootSystemRequest.usersIdsPermissions)
  return _internal_usersidspermissions(index);
}
inline ::crypto::UserKeyPermissions* BootSystemRequest::_internal_add_usersidspermissions() {
  return usersidspermissions_.Add();
}
inline ::crypto::UserKeyPermissions* BootSystemRequest::add_usersidspermissions() {
  ::crypto::UserKeyPermissions* _add = _internal_add_usersidspermissions();
  // @@protoc_insertion_point(field_add:crypto.BootSystemRequest.usersIdsPermissions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::crypto::UserKeyPermissions >&
BootSystemRequest::usersidspermissions() const {
  // @@protoc_insertion_point(field_list:crypto.BootSystemRequest.usersIdsPermissions)
  return usersidspermissions_;
}

// -------------------------------------------------------------------

// Empty

// -------------------------------------------------------------------

// CryptoConfig

// .crypto.SHAAlgorithm hashFunction = 1;
inline void CryptoConfig::clear_hashfunction() {
  hashfunction_ = 0;
}
inline ::crypto::SHAAlgorithm CryptoConfig::_internal_hashfunction() const {
  return static_cast< ::crypto::SHAAlgorithm >(hashfunction_);
}
inline ::crypto::SHAAlgorithm CryptoConfig::hashfunction() const {
  // @@protoc_insertion_point(field_get:crypto.CryptoConfig.hashFunction)
  return _internal_hashfunction();
}
inline void CryptoConfig::_internal_set_hashfunction(::crypto::SHAAlgorithm value) {
  
  hashfunction_ = value;
}
inline void CryptoConfig::set_hashfunction(::crypto::SHAAlgorithm value) {
  _internal_set_hashfunction(value);
  // @@protoc_insertion_point(field_set:crypto.CryptoConfig.hashFunction)
}

// .crypto.AESKeyLength aesKeyLength = 2;
inline void CryptoConfig::clear_aeskeylength() {
  aeskeylength_ = 0;
}
inline ::crypto::AESKeyLength CryptoConfig::_internal_aeskeylength() const {
  return static_cast< ::crypto::AESKeyLength >(aeskeylength_);
}
inline ::crypto::AESKeyLength CryptoConfig::aeskeylength() const {
  // @@protoc_insertion_point(field_get:crypto.CryptoConfig.aesKeyLength)
  return _internal_aeskeylength();
}
inline void CryptoConfig::_internal_set_aeskeylength(::crypto::AESKeyLength value) {
  
  aeskeylength_ = value;
}
inline void CryptoConfig::set_aeskeylength(::crypto::AESKeyLength value) {
  _internal_set_aeskeylength(value);
  // @@protoc_insertion_point(field_set:crypto.CryptoConfig.aesKeyLength)
}

// .crypto.AESChainingMode aesChainingMode = 3;
inline void CryptoConfig::clear_aeschainingmode() {
  aeschainingmode_ = 0;
}
inline ::crypto::AESChainingMode CryptoConfig::_internal_aeschainingmode() const {
  return static_cast< ::crypto::AESChainingMode >(aeschainingmode_);
}
inline ::crypto::AESChainingMode CryptoConfig::aeschainingmode() const {
  // @@protoc_insertion_point(field_get:crypto.CryptoConfig.aesChainingMode)
  return _internal_aeschainingmode();
}
inline void CryptoConfig::_internal_set_aeschainingmode(::crypto::AESChainingMode value) {
  
  aeschainingmode_ = value;
}
inline void CryptoConfig::set_aeschainingmode(::crypto::AESChainingMode value) {
  _internal_set_aeschainingmode(value);
  // @@protoc_insertion_point(field_set:crypto.CryptoConfig.aesChainingMode)
}

// .crypto.AsymmetricFunction asymmetricFunction = 4;
inline void CryptoConfig::clear_asymmetricfunction() {
  asymmetricfunction_ = 0;
}
inline ::crypto::AsymmetricFunction CryptoConfig::_internal_asymmetricfunction() const {
  return static_cast< ::crypto::AsymmetricFunction >(asymmetricfunction_);
}
inline ::crypto::AsymmetricFunction CryptoConfig::asymmetricfunction() const {
  // @@protoc_insertion_point(field_get:crypto.CryptoConfig.asymmetricFunction)
  return _internal_asymmetricfunction();
}
inline void CryptoConfig::_internal_set_asymmetricfunction(::crypto::AsymmetricFunction value) {
  
  asymmetricfunction_ = value;
}
inline void CryptoConfig::set_asymmetricfunction(::crypto::AsymmetricFunction value) {
  _internal_set_asymmetricfunction(value);
  // @@protoc_insertion_point(field_set:crypto.CryptoConfig.asymmetricFunction)
}

// -------------------------------------------------------------------

// ConfigureRequest

// int32 userId = 1;
inline void ConfigureRequest::clear_userid() {
  userid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConfigureRequest::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ConfigureRequest::userid() const {
  // @@protoc_insertion_point(field_get:crypto.ConfigureRequest.userId)
  return _internal_userid();
}
inline void ConfigureRequest::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  userid_ = value;
}
inline void ConfigureRequest::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:crypto.ConfigureRequest.userId)
}

// .crypto.CryptoConfig config = 2;
inline bool ConfigureRequest::_internal_has_config() const {
  return this != internal_default_instance() && config_ != nullptr;
}
inline bool ConfigureRequest::has_config() const {
  return _internal_has_config();
}
inline void ConfigureRequest::clear_config() {
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
}
inline const ::crypto::CryptoConfig& ConfigureRequest::_internal_config() const {
  const ::crypto::CryptoConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::crypto::CryptoConfig&>(
      ::crypto::_CryptoConfig_default_instance_);
}
inline const ::crypto::CryptoConfig& ConfigureRequest::config() const {
  // @@protoc_insertion_point(field_get:crypto.ConfigureRequest.config)
  return _internal_config();
}
inline void ConfigureRequest::unsafe_arena_set_allocated_config(
    ::crypto::CryptoConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:crypto.ConfigureRequest.config)
}
inline ::crypto::CryptoConfig* ConfigureRequest::release_config() {
  
  ::crypto::CryptoConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::crypto::CryptoConfig* ConfigureRequest::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:crypto.ConfigureRequest.config)
  
  ::crypto::CryptoConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::crypto::CryptoConfig* ConfigureRequest::_internal_mutable_config() {
  
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::crypto::CryptoConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::crypto::CryptoConfig* ConfigureRequest::mutable_config() {
  ::crypto::CryptoConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:crypto.ConfigureRequest.config)
  return _msg;
}
inline void ConfigureRequest::set_allocated_config(::crypto::CryptoConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::crypto::CryptoConfig>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:crypto.ConfigureRequest.config)
}

// -------------------------------------------------------------------

// AddProcessRequest

// int32 userId = 1;
inline void AddProcessRequest::clear_userid() {
  userid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AddProcessRequest::_internal_userid() const {
  return userid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AddProcessRequest::userid() const {
  // @@protoc_insertion_point(field_get:crypto.AddProcessRequest.userId)
  return _internal_userid();
}
inline void AddProcessRequest::_internal_set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  userid_ = value;
}
inline void AddProcessRequest::set_userid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:crypto.AddProcessRequest.userId)
}

// repeated .crypto.KeyPermission permissions = 2;
inline int AddProcessRequest::_internal_permissions_size() const {
  return permissions_.size();
}
inline int AddProcessRequest::permissions_size() const {
  return _internal_permissions_size();
}
inline void AddProcessRequest::clear_permissions() {
  permissions_.Clear();
}
inline ::crypto::KeyPermission AddProcessRequest::_internal_permissions(int index) const {
  return static_cast< ::crypto::KeyPermission >(permissions_.Get(index));
}
inline ::crypto::KeyPermission AddProcessRequest::permissions(int index) const {
  // @@protoc_insertion_point(field_get:crypto.AddProcessRequest.permissions)
  return _internal_permissions(index);
}
inline void AddProcessRequest::set_permissions(int index, ::crypto::KeyPermission value) {
  permissions_.Set(index, value);
  // @@protoc_insertion_point(field_set:crypto.AddProcessRequest.permissions)
}
inline void AddProcessRequest::_internal_add_permissions(::crypto::KeyPermission value) {
  permissions_.Add(value);
}
inline void AddProcessRequest::add_permissions(::crypto::KeyPermission value) {
  _internal_add_permissions(value);
  // @@protoc_insertion_point(field_add:crypto.AddProcessRequest.permissions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
AddProcessRequest::permissions() const {
  // @@protoc_insertion_point(field_list:crypto.AddProcessRequest.permissions)
  return permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
AddProcessRequest::_internal_mutable_permissions() {
  return &permissions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
AddProcessRequest::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:crypto.AddProcessRequest.permissions)
  return _internal_mutable_permissions();
}

// -------------------------------------------------------------------

// EncryptRequest

// int32 sender_id = 1;
inline void EncryptRequest::clear_sender_id() {
  sender_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EncryptRequest::_internal_sender_id() const {
  return sender_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EncryptRequest::sender_id() const {
  // @@protoc_insertion_point(field_get:crypto.EncryptRequest.sender_id)
  return _internal_sender_id();
}
inline void EncryptRequest::_internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sender_id_ = value;
}
inline void EncryptRequest::set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:crypto.EncryptRequest.sender_id)
}

// int32 receiver_id = 2;
inline void EncryptRequest::clear_receiver_id() {
  receiver_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EncryptRequest::_internal_receiver_id() const {
  return receiver_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 EncryptRequest::receiver_id() const {
  // @@protoc_insertion_point(field_get:crypto.EncryptRequest.receiver_id)
  return _internal_receiver_id();
}
inline void EncryptRequest::_internal_set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  receiver_id_ = value;
}
inline void EncryptRequest::set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_receiver_id(value);
  // @@protoc_insertion_point(field_set:crypto.EncryptRequest.receiver_id)
}

// bytes data = 3;
inline void EncryptRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& EncryptRequest::data() const {
  // @@protoc_insertion_point(field_get:crypto.EncryptRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncryptRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.EncryptRequest.data)
}
inline std::string* EncryptRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:crypto.EncryptRequest.data)
  return _s;
}
inline const std::string& EncryptRequest::_internal_data() const {
  return data_.Get();
}
inline void EncryptRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EncryptRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EncryptRequest::release_data() {
  // @@protoc_insertion_point(field_release:crypto.EncryptRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EncryptRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.EncryptRequest.data)
}

// int64 counter = 4;
inline void EncryptRequest::clear_counter() {
  counter_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EncryptRequest::_internal_counter() const {
  return counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EncryptRequest::counter() const {
  // @@protoc_insertion_point(field_get:crypto.EncryptRequest.counter)
  return _internal_counter();
}
inline void EncryptRequest::_internal_set_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  counter_ = value;
}
inline void EncryptRequest::set_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:crypto.EncryptRequest.counter)
}

// bool isFirst = 5;
inline void EncryptRequest::clear_isfirst() {
  isfirst_ = false;
}
inline bool EncryptRequest::_internal_isfirst() const {
  return isfirst_;
}
inline bool EncryptRequest::isfirst() const {
  // @@protoc_insertion_point(field_get:crypto.EncryptRequest.isFirst)
  return _internal_isfirst();
}
inline void EncryptRequest::_internal_set_isfirst(bool value) {
  
  isfirst_ = value;
}
inline void EncryptRequest::set_isfirst(bool value) {
  _internal_set_isfirst(value);
  // @@protoc_insertion_point(field_set:crypto.EncryptRequest.isFirst)
}

// -------------------------------------------------------------------

// EncryptResponse

// bytes encrypted_data = 1;
inline void EncryptResponse::clear_encrypted_data() {
  encrypted_data_.ClearToEmpty();
}
inline const std::string& EncryptResponse::encrypted_data() const {
  // @@protoc_insertion_point(field_get:crypto.EncryptResponse.encrypted_data)
  return _internal_encrypted_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncryptResponse::set_encrypted_data(ArgT0&& arg0, ArgT... args) {
 
 encrypted_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.EncryptResponse.encrypted_data)
}
inline std::string* EncryptResponse::mutable_encrypted_data() {
  std::string* _s = _internal_mutable_encrypted_data();
  // @@protoc_insertion_point(field_mutable:crypto.EncryptResponse.encrypted_data)
  return _s;
}
inline const std::string& EncryptResponse::_internal_encrypted_data() const {
  return encrypted_data_.Get();
}
inline void EncryptResponse::_internal_set_encrypted_data(const std::string& value) {
  
  encrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EncryptResponse::_internal_mutable_encrypted_data() {
  
  return encrypted_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EncryptResponse::release_encrypted_data() {
  // @@protoc_insertion_point(field_release:crypto.EncryptResponse.encrypted_data)
  return encrypted_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EncryptResponse::set_allocated_encrypted_data(std::string* encrypted_data) {
  if (encrypted_data != nullptr) {
    
  } else {
    
  }
  encrypted_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.EncryptResponse.encrypted_data)
}

// bytes signature = 2;
inline void EncryptResponse::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& EncryptResponse::signature() const {
  // @@protoc_insertion_point(field_get:crypto.EncryptResponse.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EncryptResponse::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.EncryptResponse.signature)
}
inline std::string* EncryptResponse::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:crypto.EncryptResponse.signature)
  return _s;
}
inline const std::string& EncryptResponse::_internal_signature() const {
  return signature_.Get();
}
inline void EncryptResponse::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EncryptResponse::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EncryptResponse::release_signature() {
  // @@protoc_insertion_point(field_release:crypto.EncryptResponse.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EncryptResponse::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.EncryptResponse.signature)
}

// -------------------------------------------------------------------

// DecryptRequest

// int32 sender_id = 1;
inline void DecryptRequest::clear_sender_id() {
  sender_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DecryptRequest::_internal_sender_id() const {
  return sender_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DecryptRequest::sender_id() const {
  // @@protoc_insertion_point(field_get:crypto.DecryptRequest.sender_id)
  return _internal_sender_id();
}
inline void DecryptRequest::_internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sender_id_ = value;
}
inline void DecryptRequest::set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:crypto.DecryptRequest.sender_id)
}

// int32 receiver_id = 2;
inline void DecryptRequest::clear_receiver_id() {
  receiver_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DecryptRequest::_internal_receiver_id() const {
  return receiver_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 DecryptRequest::receiver_id() const {
  // @@protoc_insertion_point(field_get:crypto.DecryptRequest.receiver_id)
  return _internal_receiver_id();
}
inline void DecryptRequest::_internal_set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  receiver_id_ = value;
}
inline void DecryptRequest::set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_receiver_id(value);
  // @@protoc_insertion_point(field_set:crypto.DecryptRequest.receiver_id)
}

// bytes encrypted_data = 3;
inline void DecryptRequest::clear_encrypted_data() {
  encrypted_data_.ClearToEmpty();
}
inline const std::string& DecryptRequest::encrypted_data() const {
  // @@protoc_insertion_point(field_get:crypto.DecryptRequest.encrypted_data)
  return _internal_encrypted_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DecryptRequest::set_encrypted_data(ArgT0&& arg0, ArgT... args) {
 
 encrypted_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.DecryptRequest.encrypted_data)
}
inline std::string* DecryptRequest::mutable_encrypted_data() {
  std::string* _s = _internal_mutable_encrypted_data();
  // @@protoc_insertion_point(field_mutable:crypto.DecryptRequest.encrypted_data)
  return _s;
}
inline const std::string& DecryptRequest::_internal_encrypted_data() const {
  return encrypted_data_.Get();
}
inline void DecryptRequest::_internal_set_encrypted_data(const std::string& value) {
  
  encrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DecryptRequest::_internal_mutable_encrypted_data() {
  
  return encrypted_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DecryptRequest::release_encrypted_data() {
  // @@protoc_insertion_point(field_release:crypto.DecryptRequest.encrypted_data)
  return encrypted_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DecryptRequest::set_allocated_encrypted_data(std::string* encrypted_data) {
  if (encrypted_data != nullptr) {
    
  } else {
    
  }
  encrypted_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.DecryptRequest.encrypted_data)
}

// int64 counter = 4;
inline void DecryptRequest::clear_counter() {
  counter_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DecryptRequest::_internal_counter() const {
  return counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 DecryptRequest::counter() const {
  // @@protoc_insertion_point(field_get:crypto.DecryptRequest.counter)
  return _internal_counter();
}
inline void DecryptRequest::_internal_set_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  counter_ = value;
}
inline void DecryptRequest::set_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:crypto.DecryptRequest.counter)
}

// bytes signature = 5;
inline void DecryptRequest::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& DecryptRequest::signature() const {
  // @@protoc_insertion_point(field_get:crypto.DecryptRequest.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DecryptRequest::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.DecryptRequest.signature)
}
inline std::string* DecryptRequest::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:crypto.DecryptRequest.signature)
  return _s;
}
inline const std::string& DecryptRequest::_internal_signature() const {
  return signature_.Get();
}
inline void DecryptRequest::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DecryptRequest::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DecryptRequest::release_signature() {
  // @@protoc_insertion_point(field_release:crypto.DecryptRequest.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DecryptRequest::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.DecryptRequest.signature)
}

// bool isFirst = 6;
inline void DecryptRequest::clear_isfirst() {
  isfirst_ = false;
}
inline bool DecryptRequest::_internal_isfirst() const {
  return isfirst_;
}
inline bool DecryptRequest::isfirst() const {
  // @@protoc_insertion_point(field_get:crypto.DecryptRequest.isFirst)
  return _internal_isfirst();
}
inline void DecryptRequest::_internal_set_isfirst(bool value) {
  
  isfirst_ = value;
}
inline void DecryptRequest::set_isfirst(bool value) {
  _internal_set_isfirst(value);
  // @@protoc_insertion_point(field_set:crypto.DecryptRequest.isFirst)
}

// -------------------------------------------------------------------

// DecryptResponse

// bytes decrypted_data = 1;
inline void DecryptResponse::clear_decrypted_data() {
  decrypted_data_.ClearToEmpty();
}
inline const std::string& DecryptResponse::decrypted_data() const {
  // @@protoc_insertion_point(field_get:crypto.DecryptResponse.decrypted_data)
  return _internal_decrypted_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DecryptResponse::set_decrypted_data(ArgT0&& arg0, ArgT... args) {
 
 decrypted_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.DecryptResponse.decrypted_data)
}
inline std::string* DecryptResponse::mutable_decrypted_data() {
  std::string* _s = _internal_mutable_decrypted_data();
  // @@protoc_insertion_point(field_mutable:crypto.DecryptResponse.decrypted_data)
  return _s;
}
inline const std::string& DecryptResponse::_internal_decrypted_data() const {
  return decrypted_data_.Get();
}
inline void DecryptResponse::_internal_set_decrypted_data(const std::string& value) {
  
  decrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DecryptResponse::_internal_mutable_decrypted_data() {
  
  return decrypted_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DecryptResponse::release_decrypted_data() {
  // @@protoc_insertion_point(field_release:crypto.DecryptResponse.decrypted_data)
  return decrypted_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DecryptResponse::set_allocated_decrypted_data(std::string* decrypted_data) {
  if (decrypted_data != nullptr) {
    
  } else {
    
  }
  decrypted_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), decrypted_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.DecryptResponse.decrypted_data)
}

// -------------------------------------------------------------------

// AESEncryptRequest

// int32 sender_id = 1;
inline void AESEncryptRequest::clear_sender_id() {
  sender_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AESEncryptRequest::_internal_sender_id() const {
  return sender_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AESEncryptRequest::sender_id() const {
  // @@protoc_insertion_point(field_get:crypto.AESEncryptRequest.sender_id)
  return _internal_sender_id();
}
inline void AESEncryptRequest::_internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sender_id_ = value;
}
inline void AESEncryptRequest::set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:crypto.AESEncryptRequest.sender_id)
}

// int32 receiver_id = 2;
inline void AESEncryptRequest::clear_receiver_id() {
  receiver_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AESEncryptRequest::_internal_receiver_id() const {
  return receiver_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AESEncryptRequest::receiver_id() const {
  // @@protoc_insertion_point(field_get:crypto.AESEncryptRequest.receiver_id)
  return _internal_receiver_id();
}
inline void AESEncryptRequest::_internal_set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  receiver_id_ = value;
}
inline void AESEncryptRequest::set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_receiver_id(value);
  // @@protoc_insertion_point(field_set:crypto.AESEncryptRequest.receiver_id)
}

// bytes data = 3;
inline void AESEncryptRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& AESEncryptRequest::data() const {
  // @@protoc_insertion_point(field_get:crypto.AESEncryptRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AESEncryptRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.AESEncryptRequest.data)
}
inline std::string* AESEncryptRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:crypto.AESEncryptRequest.data)
  return _s;
}
inline const std::string& AESEncryptRequest::_internal_data() const {
  return data_.Get();
}
inline void AESEncryptRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AESEncryptRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AESEncryptRequest::release_data() {
  // @@protoc_insertion_point(field_release:crypto.AESEncryptRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AESEncryptRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.AESEncryptRequest.data)
}

// .crypto.AsymmetricFunction func = 4;
inline void AESEncryptRequest::clear_func() {
  func_ = 0;
}
inline ::crypto::AsymmetricFunction AESEncryptRequest::_internal_func() const {
  return static_cast< ::crypto::AsymmetricFunction >(func_);
}
inline ::crypto::AsymmetricFunction AESEncryptRequest::func() const {
  // @@protoc_insertion_point(field_get:crypto.AESEncryptRequest.func)
  return _internal_func();
}
inline void AESEncryptRequest::_internal_set_func(::crypto::AsymmetricFunction value) {
  
  func_ = value;
}
inline void AESEncryptRequest::set_func(::crypto::AsymmetricFunction value) {
  _internal_set_func(value);
  // @@protoc_insertion_point(field_set:crypto.AESEncryptRequest.func)
}

// int64 counter = 5;
inline void AESEncryptRequest::clear_counter() {
  counter_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AESEncryptRequest::_internal_counter() const {
  return counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AESEncryptRequest::counter() const {
  // @@protoc_insertion_point(field_get:crypto.AESEncryptRequest.counter)
  return _internal_counter();
}
inline void AESEncryptRequest::_internal_set_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  counter_ = value;
}
inline void AESEncryptRequest::set_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:crypto.AESEncryptRequest.counter)
}

// string key_id = 6;
inline void AESEncryptRequest::clear_key_id() {
  key_id_.ClearToEmpty();
}
inline const std::string& AESEncryptRequest::key_id() const {
  // @@protoc_insertion_point(field_get:crypto.AESEncryptRequest.key_id)
  return _internal_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AESEncryptRequest::set_key_id(ArgT0&& arg0, ArgT... args) {
 
 key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.AESEncryptRequest.key_id)
}
inline std::string* AESEncryptRequest::mutable_key_id() {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:crypto.AESEncryptRequest.key_id)
  return _s;
}
inline const std::string& AESEncryptRequest::_internal_key_id() const {
  return key_id_.Get();
}
inline void AESEncryptRequest::_internal_set_key_id(const std::string& value) {
  
  key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AESEncryptRequest::_internal_mutable_key_id() {
  
  return key_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AESEncryptRequest::release_key_id() {
  // @@protoc_insertion_point(field_release:crypto.AESEncryptRequest.key_id)
  return key_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AESEncryptRequest::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    
  } else {
    
  }
  key_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.AESEncryptRequest.key_id)
}

// .crypto.AESKeyLength key_length = 7;
inline void AESEncryptRequest::clear_key_length() {
  key_length_ = 0;
}
inline ::crypto::AESKeyLength AESEncryptRequest::_internal_key_length() const {
  return static_cast< ::crypto::AESKeyLength >(key_length_);
}
inline ::crypto::AESKeyLength AESEncryptRequest::key_length() const {
  // @@protoc_insertion_point(field_get:crypto.AESEncryptRequest.key_length)
  return _internal_key_length();
}
inline void AESEncryptRequest::_internal_set_key_length(::crypto::AESKeyLength value) {
  
  key_length_ = value;
}
inline void AESEncryptRequest::set_key_length(::crypto::AESKeyLength value) {
  _internal_set_key_length(value);
  // @@protoc_insertion_point(field_set:crypto.AESEncryptRequest.key_length)
}

// .crypto.AESChainingMode chainingMode = 8;
inline void AESEncryptRequest::clear_chainingmode() {
  chainingmode_ = 0;
}
inline ::crypto::AESChainingMode AESEncryptRequest::_internal_chainingmode() const {
  return static_cast< ::crypto::AESChainingMode >(chainingmode_);
}
inline ::crypto::AESChainingMode AESEncryptRequest::chainingmode() const {
  // @@protoc_insertion_point(field_get:crypto.AESEncryptRequest.chainingMode)
  return _internal_chainingmode();
}
inline void AESEncryptRequest::_internal_set_chainingmode(::crypto::AESChainingMode value) {
  
  chainingmode_ = value;
}
inline void AESEncryptRequest::set_chainingmode(::crypto::AESChainingMode value) {
  _internal_set_chainingmode(value);
  // @@protoc_insertion_point(field_set:crypto.AESEncryptRequest.chainingMode)
}

// bool isFirst = 9;
inline void AESEncryptRequest::clear_isfirst() {
  isfirst_ = false;
}
inline bool AESEncryptRequest::_internal_isfirst() const {
  return isfirst_;
}
inline bool AESEncryptRequest::isfirst() const {
  // @@protoc_insertion_point(field_get:crypto.AESEncryptRequest.isFirst)
  return _internal_isfirst();
}
inline void AESEncryptRequest::_internal_set_isfirst(bool value) {
  
  isfirst_ = value;
}
inline void AESEncryptRequest::set_isfirst(bool value) {
  _internal_set_isfirst(value);
  // @@protoc_insertion_point(field_set:crypto.AESEncryptRequest.isFirst)
}

// -------------------------------------------------------------------

// AESEncryptResponse

// bytes encrypted_data = 1;
inline void AESEncryptResponse::clear_encrypted_data() {
  encrypted_data_.ClearToEmpty();
}
inline const std::string& AESEncryptResponse::encrypted_data() const {
  // @@protoc_insertion_point(field_get:crypto.AESEncryptResponse.encrypted_data)
  return _internal_encrypted_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AESEncryptResponse::set_encrypted_data(ArgT0&& arg0, ArgT... args) {
 
 encrypted_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.AESEncryptResponse.encrypted_data)
}
inline std::string* AESEncryptResponse::mutable_encrypted_data() {
  std::string* _s = _internal_mutable_encrypted_data();
  // @@protoc_insertion_point(field_mutable:crypto.AESEncryptResponse.encrypted_data)
  return _s;
}
inline const std::string& AESEncryptResponse::_internal_encrypted_data() const {
  return encrypted_data_.Get();
}
inline void AESEncryptResponse::_internal_set_encrypted_data(const std::string& value) {
  
  encrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AESEncryptResponse::_internal_mutable_encrypted_data() {
  
  return encrypted_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AESEncryptResponse::release_encrypted_data() {
  // @@protoc_insertion_point(field_release:crypto.AESEncryptResponse.encrypted_data)
  return encrypted_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AESEncryptResponse::set_allocated_encrypted_data(std::string* encrypted_data) {
  if (encrypted_data != nullptr) {
    
  } else {
    
  }
  encrypted_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.AESEncryptResponse.encrypted_data)
}

// -------------------------------------------------------------------

// AESDecryptRequest

// int32 sender_id = 1;
inline void AESDecryptRequest::clear_sender_id() {
  sender_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AESDecryptRequest::_internal_sender_id() const {
  return sender_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AESDecryptRequest::sender_id() const {
  // @@protoc_insertion_point(field_get:crypto.AESDecryptRequest.sender_id)
  return _internal_sender_id();
}
inline void AESDecryptRequest::_internal_set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  sender_id_ = value;
}
inline void AESDecryptRequest::set_sender_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_sender_id(value);
  // @@protoc_insertion_point(field_set:crypto.AESDecryptRequest.sender_id)
}

// int32 receiver_id = 2;
inline void AESDecryptRequest::clear_receiver_id() {
  receiver_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AESDecryptRequest::_internal_receiver_id() const {
  return receiver_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AESDecryptRequest::receiver_id() const {
  // @@protoc_insertion_point(field_get:crypto.AESDecryptRequest.receiver_id)
  return _internal_receiver_id();
}
inline void AESDecryptRequest::_internal_set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  receiver_id_ = value;
}
inline void AESDecryptRequest::set_receiver_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_receiver_id(value);
  // @@protoc_insertion_point(field_set:crypto.AESDecryptRequest.receiver_id)
}

// bytes data_in = 3;
inline void AESDecryptRequest::clear_data_in() {
  data_in_.ClearToEmpty();
}
inline const std::string& AESDecryptRequest::data_in() const {
  // @@protoc_insertion_point(field_get:crypto.AESDecryptRequest.data_in)
  return _internal_data_in();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AESDecryptRequest::set_data_in(ArgT0&& arg0, ArgT... args) {
 
 data_in_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.AESDecryptRequest.data_in)
}
inline std::string* AESDecryptRequest::mutable_data_in() {
  std::string* _s = _internal_mutable_data_in();
  // @@protoc_insertion_point(field_mutable:crypto.AESDecryptRequest.data_in)
  return _s;
}
inline const std::string& AESDecryptRequest::_internal_data_in() const {
  return data_in_.Get();
}
inline void AESDecryptRequest::_internal_set_data_in(const std::string& value) {
  
  data_in_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AESDecryptRequest::_internal_mutable_data_in() {
  
  return data_in_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AESDecryptRequest::release_data_in() {
  // @@protoc_insertion_point(field_release:crypto.AESDecryptRequest.data_in)
  return data_in_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AESDecryptRequest::set_allocated_data_in(std::string* data_in) {
  if (data_in != nullptr) {
    
  } else {
    
  }
  data_in_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_in,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.AESDecryptRequest.data_in)
}

// int32 in_len = 4;
inline void AESDecryptRequest::clear_in_len() {
  in_len_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AESDecryptRequest::_internal_in_len() const {
  return in_len_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AESDecryptRequest::in_len() const {
  // @@protoc_insertion_point(field_get:crypto.AESDecryptRequest.in_len)
  return _internal_in_len();
}
inline void AESDecryptRequest::_internal_set_in_len(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  in_len_ = value;
}
inline void AESDecryptRequest::set_in_len(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_in_len(value);
  // @@protoc_insertion_point(field_set:crypto.AESDecryptRequest.in_len)
}

// bytes data_out = 5;
inline void AESDecryptRequest::clear_data_out() {
  data_out_.ClearToEmpty();
}
inline const std::string& AESDecryptRequest::data_out() const {
  // @@protoc_insertion_point(field_get:crypto.AESDecryptRequest.data_out)
  return _internal_data_out();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AESDecryptRequest::set_data_out(ArgT0&& arg0, ArgT... args) {
 
 data_out_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.AESDecryptRequest.data_out)
}
inline std::string* AESDecryptRequest::mutable_data_out() {
  std::string* _s = _internal_mutable_data_out();
  // @@protoc_insertion_point(field_mutable:crypto.AESDecryptRequest.data_out)
  return _s;
}
inline const std::string& AESDecryptRequest::_internal_data_out() const {
  return data_out_.Get();
}
inline void AESDecryptRequest::_internal_set_data_out(const std::string& value) {
  
  data_out_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AESDecryptRequest::_internal_mutable_data_out() {
  
  return data_out_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AESDecryptRequest::release_data_out() {
  // @@protoc_insertion_point(field_release:crypto.AESDecryptRequest.data_out)
  return data_out_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AESDecryptRequest::set_allocated_data_out(std::string* data_out) {
  if (data_out != nullptr) {
    
  } else {
    
  }
  data_out_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data_out,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.AESDecryptRequest.data_out)
}

// .crypto.AsymmetricFunction func = 6;
inline void AESDecryptRequest::clear_func() {
  func_ = 0;
}
inline ::crypto::AsymmetricFunction AESDecryptRequest::_internal_func() const {
  return static_cast< ::crypto::AsymmetricFunction >(func_);
}
inline ::crypto::AsymmetricFunction AESDecryptRequest::func() const {
  // @@protoc_insertion_point(field_get:crypto.AESDecryptRequest.func)
  return _internal_func();
}
inline void AESDecryptRequest::_internal_set_func(::crypto::AsymmetricFunction value) {
  
  func_ = value;
}
inline void AESDecryptRequest::set_func(::crypto::AsymmetricFunction value) {
  _internal_set_func(value);
  // @@protoc_insertion_point(field_set:crypto.AESDecryptRequest.func)
}

// .crypto.AESKeyLength key_length = 7;
inline void AESDecryptRequest::clear_key_length() {
  key_length_ = 0;
}
inline ::crypto::AESKeyLength AESDecryptRequest::_internal_key_length() const {
  return static_cast< ::crypto::AESKeyLength >(key_length_);
}
inline ::crypto::AESKeyLength AESDecryptRequest::key_length() const {
  // @@protoc_insertion_point(field_get:crypto.AESDecryptRequest.key_length)
  return _internal_key_length();
}
inline void AESDecryptRequest::_internal_set_key_length(::crypto::AESKeyLength value) {
  
  key_length_ = value;
}
inline void AESDecryptRequest::set_key_length(::crypto::AESKeyLength value) {
  _internal_set_key_length(value);
  // @@protoc_insertion_point(field_set:crypto.AESDecryptRequest.key_length)
}

// .crypto.AESChainingMode chainingMode = 8;
inline void AESDecryptRequest::clear_chainingmode() {
  chainingmode_ = 0;
}
inline ::crypto::AESChainingMode AESDecryptRequest::_internal_chainingmode() const {
  return static_cast< ::crypto::AESChainingMode >(chainingmode_);
}
inline ::crypto::AESChainingMode AESDecryptRequest::chainingmode() const {
  // @@protoc_insertion_point(field_get:crypto.AESDecryptRequest.chainingMode)
  return _internal_chainingmode();
}
inline void AESDecryptRequest::_internal_set_chainingmode(::crypto::AESChainingMode value) {
  
  chainingmode_ = value;
}
inline void AESDecryptRequest::set_chainingmode(::crypto::AESChainingMode value) {
  _internal_set_chainingmode(value);
  // @@protoc_insertion_point(field_set:crypto.AESDecryptRequest.chainingMode)
}

// int64 counter = 9;
inline void AESDecryptRequest::clear_counter() {
  counter_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AESDecryptRequest::_internal_counter() const {
  return counter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 AESDecryptRequest::counter() const {
  // @@protoc_insertion_point(field_get:crypto.AESDecryptRequest.counter)
  return _internal_counter();
}
inline void AESDecryptRequest::_internal_set_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  counter_ = value;
}
inline void AESDecryptRequest::set_counter(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_counter(value);
  // @@protoc_insertion_point(field_set:crypto.AESDecryptRequest.counter)
}

// string key_id = 10;
inline void AESDecryptRequest::clear_key_id() {
  key_id_.ClearToEmpty();
}
inline const std::string& AESDecryptRequest::key_id() const {
  // @@protoc_insertion_point(field_get:crypto.AESDecryptRequest.key_id)
  return _internal_key_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AESDecryptRequest::set_key_id(ArgT0&& arg0, ArgT... args) {
 
 key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.AESDecryptRequest.key_id)
}
inline std::string* AESDecryptRequest::mutable_key_id() {
  std::string* _s = _internal_mutable_key_id();
  // @@protoc_insertion_point(field_mutable:crypto.AESDecryptRequest.key_id)
  return _s;
}
inline const std::string& AESDecryptRequest::_internal_key_id() const {
  return key_id_.Get();
}
inline void AESDecryptRequest::_internal_set_key_id(const std::string& value) {
  
  key_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AESDecryptRequest::_internal_mutable_key_id() {
  
  return key_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AESDecryptRequest::release_key_id() {
  // @@protoc_insertion_point(field_release:crypto.AESDecryptRequest.key_id)
  return key_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AESDecryptRequest::set_allocated_key_id(std::string* key_id) {
  if (key_id != nullptr) {
    
  } else {
    
  }
  key_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.AESDecryptRequest.key_id)
}

// bool isFirst = 11;
inline void AESDecryptRequest::clear_isfirst() {
  isfirst_ = false;
}
inline bool AESDecryptRequest::_internal_isfirst() const {
  return isfirst_;
}
inline bool AESDecryptRequest::isfirst() const {
  // @@protoc_insertion_point(field_get:crypto.AESDecryptRequest.isFirst)
  return _internal_isfirst();
}
inline void AESDecryptRequest::_internal_set_isfirst(bool value) {
  
  isfirst_ = value;
}
inline void AESDecryptRequest::set_isfirst(bool value) {
  _internal_set_isfirst(value);
  // @@protoc_insertion_point(field_set:crypto.AESDecryptRequest.isFirst)
}

// -------------------------------------------------------------------

// AESDecryptResponse

// bytes decrypted_data = 1;
inline void AESDecryptResponse::clear_decrypted_data() {
  decrypted_data_.ClearToEmpty();
}
inline const std::string& AESDecryptResponse::decrypted_data() const {
  // @@protoc_insertion_point(field_get:crypto.AESDecryptResponse.decrypted_data)
  return _internal_decrypted_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AESDecryptResponse::set_decrypted_data(ArgT0&& arg0, ArgT... args) {
 
 decrypted_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:crypto.AESDecryptResponse.decrypted_data)
}
inline std::string* AESDecryptResponse::mutable_decrypted_data() {
  std::string* _s = _internal_mutable_decrypted_data();
  // @@protoc_insertion_point(field_mutable:crypto.AESDecryptResponse.decrypted_data)
  return _s;
}
inline const std::string& AESDecryptResponse::_internal_decrypted_data() const {
  return decrypted_data_.Get();
}
inline void AESDecryptResponse::_internal_set_decrypted_data(const std::string& value) {
  
  decrypted_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AESDecryptResponse::_internal_mutable_decrypted_data() {
  
  return decrypted_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AESDecryptResponse::release_decrypted_data() {
  // @@protoc_insertion_point(field_release:crypto.AESDecryptResponse.decrypted_data)
  return decrypted_data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AESDecryptResponse::set_allocated_decrypted_data(std::string* decrypted_data) {
  if (decrypted_data != nullptr) {
    
  } else {
    
  }
  decrypted_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), decrypted_data,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:crypto.AESDecryptResponse.decrypted_data)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace crypto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::crypto::KeyPermission> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::crypto::KeyPermission>() {
  return ::crypto::KeyPermission_descriptor();
}
template <> struct is_proto_enum< ::crypto::AESChainingMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::crypto::AESChainingMode>() {
  return ::crypto::AESChainingMode_descriptor();
}
template <> struct is_proto_enum< ::crypto::AsymmetricFunction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::crypto::AsymmetricFunction>() {
  return ::crypto::AsymmetricFunction_descriptor();
}
template <> struct is_proto_enum< ::crypto::SHAAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::crypto::SHAAlgorithm>() {
  return ::crypto::SHAAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::crypto::AESKeyLength> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::crypto::AESKeyLength>() {
  return ::crypto::AESKeyLength_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_encryption_2eproto
