// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: encryption.proto
#ifndef GRPC_encryption_2eproto__INCLUDED
#define GRPC_encryption_2eproto__INCLUDED

#include "encryption.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace crypto {

class CryptoService final {
 public:
  static constexpr char const* service_full_name() {
    return "crypto.CryptoService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status bootSystem(::grpc::ClientContext* context, const ::crypto::BootSystemRequest& request, ::crypto::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>> AsyncbootSystem(::grpc::ClientContext* context, const ::crypto::BootSystemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>>(AsyncbootSystemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>> PrepareAsyncbootSystem(::grpc::ClientContext* context, const ::crypto::BootSystemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>>(PrepareAsyncbootSystemRaw(context, request, cq));
    }
    virtual ::grpc::Status addProccess(::grpc::ClientContext* context, const ::crypto::AddProcessRequest& request, ::crypto::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>> AsyncaddProccess(::grpc::ClientContext* context, const ::crypto::AddProcessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>>(AsyncaddProccessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>> PrepareAsyncaddProccess(::grpc::ClientContext* context, const ::crypto::AddProcessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>>(PrepareAsyncaddProccessRaw(context, request, cq));
    }
    virtual ::grpc::Status configure(::grpc::ClientContext* context, const ::crypto::ConfigureRequest& request, ::crypto::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>> Asyncconfigure(::grpc::ClientContext* context, const ::crypto::ConfigureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>>(AsyncconfigureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>> PrepareAsyncconfigure(::grpc::ClientContext* context, const ::crypto::ConfigureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>>(PrepareAsyncconfigureRaw(context, request, cq));
    }
    virtual ::grpc::Status generateAESKey(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest& request, ::crypto::GenerateAESKeyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateAESKeyResponse>> AsyncgenerateAESKey(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateAESKeyResponse>>(AsyncgenerateAESKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateAESKeyResponse>> PrepareAsyncgenerateAESKey(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateAESKeyResponse>>(PrepareAsyncgenerateAESKeyRaw(context, request, cq));
    }
    virtual ::grpc::Status generateRSAKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::crypto::GenerateKeyPairResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateKeyPairResponse>> AsyncgenerateRSAKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateKeyPairResponse>>(AsyncgenerateRSAKeyPairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateKeyPairResponse>> PrepareAsyncgenerateRSAKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateKeyPairResponse>>(PrepareAsyncgenerateRSAKeyPairRaw(context, request, cq));
    }
    virtual ::grpc::Status generateECCKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::crypto::GenerateKeyPairResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateKeyPairResponse>> AsyncgenerateECCKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateKeyPairResponse>>(AsyncgenerateECCKeyPairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateKeyPairResponse>> PrepareAsyncgenerateECCKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateKeyPairResponse>>(PrepareAsyncgenerateECCKeyPairRaw(context, request, cq));
    }
    virtual ::grpc::Status getSignedDataLength(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest& request, ::crypto::GetLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> AsyncgetSignedDataLength(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(AsyncgetSignedDataLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> PrepareAsyncgetSignedDataLength(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(PrepareAsyncgetSignedDataLengthRaw(context, request, cq));
    }
    virtual ::grpc::Status getECCencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::crypto::GetLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> AsyncgetECCencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(AsyncgetECCencryptedLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> PrepareAsyncgetECCencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(PrepareAsyncgetECCencryptedLengthRaw(context, request, cq));
    }
    virtual ::grpc::Status getECCDecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::crypto::GetLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> AsyncgetECCDecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(AsyncgetECCDecryptedLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> PrepareAsyncgetECCDecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(PrepareAsyncgetECCDecryptedLengthRaw(context, request, cq));
    }
    virtual ::grpc::Status getRSAencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::crypto::GetLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> AsyncgetRSAencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(AsyncgetRSAencryptedLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> PrepareAsyncgetRSAencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(PrepareAsyncgetRSAencryptedLengthRaw(context, request, cq));
    }
    virtual ::grpc::Status getRSAdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::crypto::GetLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> AsyncgetRSAdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(AsyncgetRSAdecryptedLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> PrepareAsyncgetRSAdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(PrepareAsyncgetRSAdecryptedLengthRaw(context, request, cq));
    }
    virtual ::grpc::Status getAESencryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::crypto::GetLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> AsyncgetAESencryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(AsyncgetAESencryptedLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> PrepareAsyncgetAESencryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(PrepareAsyncgetAESencryptedLengthRaw(context, request, cq));
    }
    virtual ::grpc::Status getAESdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::crypto::GetLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> AsyncgetAESdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(AsyncgetAESdecryptedLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> PrepareAsyncgetAESdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(PrepareAsyncgetAESdecryptedLengthRaw(context, request, cq));
    }
    virtual ::grpc::Status getEncryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::crypto::GetLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> AsyncgetEncryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(AsyncgetEncryptedLenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> PrepareAsyncgetEncryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(PrepareAsyncgetEncryptedLenRaw(context, request, cq));
    }
    virtual ::grpc::Status getDecryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::crypto::GetLengthResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> AsyncgetDecryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(AsyncgetDecryptedLenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>> PrepareAsyncgetDecryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>>(PrepareAsyncgetDecryptedLenRaw(context, request, cq));
    }
    virtual ::grpc::Status sign(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::crypto::SignResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>> Asyncsign(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>>(AsyncsignRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>> PrepareAsyncsign(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>>(PrepareAsyncsignRaw(context, request, cq));
    }
    virtual ::grpc::Status verify(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::crypto::VerifyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>> Asyncverify(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>>(AsyncverifyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>> PrepareAsyncverify(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>>(PrepareAsyncverifyRaw(context, request, cq));
    }
    virtual ::grpc::Status getPublicECCKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::crypto::KeyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::KeyResponse>> AsyncgetPublicECCKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::KeyResponse>>(AsyncgetPublicECCKeyByUserIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::KeyResponse>> PrepareAsyncgetPublicECCKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::KeyResponse>>(PrepareAsyncgetPublicECCKeyByUserIdRaw(context, request, cq));
    }
    virtual ::grpc::Status getPublicRSAKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::crypto::KeyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::KeyResponse>> AsyncgetPublicRSAKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::KeyResponse>>(AsyncgetPublicRSAKeyByUserIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::KeyResponse>> PrepareAsyncgetPublicRSAKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::KeyResponse>>(PrepareAsyncgetPublicRSAKeyByUserIdRaw(context, request, cq));
    }
    virtual ::grpc::Status ECCencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::crypto::AsymetricEncryptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricEncryptResponse>> AsyncECCencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricEncryptResponse>>(AsyncECCencryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricEncryptResponse>> PrepareAsyncECCencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricEncryptResponse>>(PrepareAsyncECCencryptRaw(context, request, cq));
    }
    virtual ::grpc::Status ECCdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::crypto::AsymetricDecryptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricDecryptResponse>> AsyncECCdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricDecryptResponse>>(AsyncECCdecryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricDecryptResponse>> PrepareAsyncECCdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricDecryptResponse>>(PrepareAsyncECCdecryptRaw(context, request, cq));
    }
    virtual ::grpc::Status RSAencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::crypto::AsymetricEncryptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricEncryptResponse>> AsyncRSAencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricEncryptResponse>>(AsyncRSAencryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricEncryptResponse>> PrepareAsyncRSAencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricEncryptResponse>>(PrepareAsyncRSAencryptRaw(context, request, cq));
    }
    virtual ::grpc::Status RSAdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::crypto::AsymetricDecryptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricDecryptResponse>> AsyncRSAdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricDecryptResponse>>(AsyncRSAdecryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricDecryptResponse>> PrepareAsyncRSAdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricDecryptResponse>>(PrepareAsyncRSAdecryptRaw(context, request, cq));
    }
    virtual ::grpc::Status AESencrypt(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest& request, ::crypto::AESEncryptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AESEncryptResponse>> AsyncAESencrypt(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AESEncryptResponse>>(AsyncAESencryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AESEncryptResponse>> PrepareAsyncAESencrypt(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AESEncryptResponse>>(PrepareAsyncAESencryptRaw(context, request, cq));
    }
    virtual ::grpc::Status AESdecrypt(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest& request, ::crypto::AESDecryptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AESDecryptResponse>> AsyncAESdecrypt(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AESDecryptResponse>>(AsyncAESdecryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AESDecryptResponse>> PrepareAsyncAESdecrypt(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AESDecryptResponse>>(PrepareAsyncAESdecryptRaw(context, request, cq));
    }
    virtual ::grpc::Status encrypt(::grpc::ClientContext* context, const ::crypto::EncryptRequest& request, ::crypto::EncryptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::EncryptResponse>> Asyncencrypt(::grpc::ClientContext* context, const ::crypto::EncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::EncryptResponse>>(AsyncencryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::EncryptResponse>> PrepareAsyncencrypt(::grpc::ClientContext* context, const ::crypto::EncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::EncryptResponse>>(PrepareAsyncencryptRaw(context, request, cq));
    }
    virtual ::grpc::Status decrypt(::grpc::ClientContext* context, const ::crypto::DecryptRequest& request, ::crypto::DecryptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::DecryptResponse>> Asyncdecrypt(::grpc::ClientContext* context, const ::crypto::DecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::DecryptResponse>>(AsyncdecryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::DecryptResponse>> PrepareAsyncdecrypt(::grpc::ClientContext* context, const ::crypto::DecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::DecryptResponse>>(PrepareAsyncdecryptRaw(context, request, cq));
    }
    virtual ::grpc::Status signUpdate(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::crypto::SignResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>> AsyncsignUpdate(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>>(AsyncsignUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>> PrepareAsyncsignUpdate(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>>(PrepareAsyncsignUpdateRaw(context, request, cq));
    }
    virtual ::grpc::Status signFinalize(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::crypto::SignResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>> AsyncsignFinalize(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>>(AsyncsignFinalizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>> PrepareAsyncsignFinalize(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>>(PrepareAsyncsignFinalizeRaw(context, request, cq));
    }
    virtual ::grpc::Status verifyUpdate(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::crypto::VerifyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>> AsyncverifyUpdate(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>>(AsyncverifyUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>> PrepareAsyncverifyUpdate(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>>(PrepareAsyncverifyUpdateRaw(context, request, cq));
    }
    virtual ::grpc::Status verifyFinalize(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::crypto::VerifyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>> AsyncverifyFinalize(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>>(AsyncverifyFinalizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>> PrepareAsyncverifyFinalize(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>>(PrepareAsyncverifyFinalizeRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void bootSystem(::grpc::ClientContext* context, const ::crypto::BootSystemRequest* request, ::crypto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void bootSystem(::grpc::ClientContext* context, const ::crypto::BootSystemRequest* request, ::crypto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void addProccess(::grpc::ClientContext* context, const ::crypto::AddProcessRequest* request, ::crypto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void addProccess(::grpc::ClientContext* context, const ::crypto::AddProcessRequest* request, ::crypto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void configure(::grpc::ClientContext* context, const ::crypto::ConfigureRequest* request, ::crypto::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void configure(::grpc::ClientContext* context, const ::crypto::ConfigureRequest* request, ::crypto::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void generateAESKey(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest* request, ::crypto::GenerateAESKeyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void generateAESKey(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest* request, ::crypto::GenerateAESKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void generateRSAKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void generateRSAKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void generateECCKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void generateECCKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getSignedDataLength(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getSignedDataLength(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getECCencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getECCencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getECCDecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getECCDecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getRSAencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getRSAencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getRSAdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getRSAdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getAESencryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getAESencryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getAESdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getAESdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getEncryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getEncryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getDecryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getDecryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void sign(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void sign(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void verify(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void verify(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getPublicECCKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getPublicECCKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void getPublicRSAKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void getPublicRSAKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ECCencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ECCencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ECCdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ECCdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RSAencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RSAencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RSAdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RSAdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void AESencrypt(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest* request, ::crypto::AESEncryptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AESencrypt(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest* request, ::crypto::AESEncryptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void AESdecrypt(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest* request, ::crypto::AESDecryptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AESdecrypt(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest* request, ::crypto::AESDecryptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void encrypt(::grpc::ClientContext* context, const ::crypto::EncryptRequest* request, ::crypto::EncryptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void encrypt(::grpc::ClientContext* context, const ::crypto::EncryptRequest* request, ::crypto::EncryptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void decrypt(::grpc::ClientContext* context, const ::crypto::DecryptRequest* request, ::crypto::DecryptResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void decrypt(::grpc::ClientContext* context, const ::crypto::DecryptRequest* request, ::crypto::DecryptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void signUpdate(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void signUpdate(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void signFinalize(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void signFinalize(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void verifyUpdate(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void verifyUpdate(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void verifyFinalize(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void verifyFinalize(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>* AsyncbootSystemRaw(::grpc::ClientContext* context, const ::crypto::BootSystemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>* PrepareAsyncbootSystemRaw(::grpc::ClientContext* context, const ::crypto::BootSystemRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>* AsyncaddProccessRaw(::grpc::ClientContext* context, const ::crypto::AddProcessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>* PrepareAsyncaddProccessRaw(::grpc::ClientContext* context, const ::crypto::AddProcessRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>* AsyncconfigureRaw(::grpc::ClientContext* context, const ::crypto::ConfigureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::Empty>* PrepareAsyncconfigureRaw(::grpc::ClientContext* context, const ::crypto::ConfigureRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateAESKeyResponse>* AsyncgenerateAESKeyRaw(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateAESKeyResponse>* PrepareAsyncgenerateAESKeyRaw(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateKeyPairResponse>* AsyncgenerateRSAKeyPairRaw(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateKeyPairResponse>* PrepareAsyncgenerateRSAKeyPairRaw(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateKeyPairResponse>* AsyncgenerateECCKeyPairRaw(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GenerateKeyPairResponse>* PrepareAsyncgenerateECCKeyPairRaw(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* AsyncgetSignedDataLengthRaw(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* PrepareAsyncgetSignedDataLengthRaw(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* AsyncgetECCencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* PrepareAsyncgetECCencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* AsyncgetECCDecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* PrepareAsyncgetECCDecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* AsyncgetRSAencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* PrepareAsyncgetRSAencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* AsyncgetRSAdecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* PrepareAsyncgetRSAdecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* AsyncgetAESencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* PrepareAsyncgetAESencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* AsyncgetAESdecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* PrepareAsyncgetAESdecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* AsyncgetEncryptedLenRaw(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* PrepareAsyncgetEncryptedLenRaw(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* AsyncgetDecryptedLenRaw(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::GetLengthResponse>* PrepareAsyncgetDecryptedLenRaw(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>* AsyncsignRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>* PrepareAsyncsignRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>* AsyncverifyRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>* PrepareAsyncverifyRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::KeyResponse>* AsyncgetPublicECCKeyByUserIdRaw(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::KeyResponse>* PrepareAsyncgetPublicECCKeyByUserIdRaw(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::KeyResponse>* AsyncgetPublicRSAKeyByUserIdRaw(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::KeyResponse>* PrepareAsyncgetPublicRSAKeyByUserIdRaw(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricEncryptResponse>* AsyncECCencryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricEncryptResponse>* PrepareAsyncECCencryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricDecryptResponse>* AsyncECCdecryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricDecryptResponse>* PrepareAsyncECCdecryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricEncryptResponse>* AsyncRSAencryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricEncryptResponse>* PrepareAsyncRSAencryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricDecryptResponse>* AsyncRSAdecryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AsymetricDecryptResponse>* PrepareAsyncRSAdecryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AESEncryptResponse>* AsyncAESencryptRaw(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AESEncryptResponse>* PrepareAsyncAESencryptRaw(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AESDecryptResponse>* AsyncAESdecryptRaw(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::AESDecryptResponse>* PrepareAsyncAESdecryptRaw(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::EncryptResponse>* AsyncencryptRaw(::grpc::ClientContext* context, const ::crypto::EncryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::EncryptResponse>* PrepareAsyncencryptRaw(::grpc::ClientContext* context, const ::crypto::EncryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::DecryptResponse>* AsyncdecryptRaw(::grpc::ClientContext* context, const ::crypto::DecryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::DecryptResponse>* PrepareAsyncdecryptRaw(::grpc::ClientContext* context, const ::crypto::DecryptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>* AsyncsignUpdateRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>* PrepareAsyncsignUpdateRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>* AsyncsignFinalizeRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::SignResponse>* PrepareAsyncsignFinalizeRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>* AsyncverifyUpdateRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>* PrepareAsyncverifyUpdateRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>* AsyncverifyFinalizeRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::crypto::VerifyResponse>* PrepareAsyncverifyFinalizeRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status bootSystem(::grpc::ClientContext* context, const ::crypto::BootSystemRequest& request, ::crypto::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::Empty>> AsyncbootSystem(::grpc::ClientContext* context, const ::crypto::BootSystemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::Empty>>(AsyncbootSystemRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::Empty>> PrepareAsyncbootSystem(::grpc::ClientContext* context, const ::crypto::BootSystemRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::Empty>>(PrepareAsyncbootSystemRaw(context, request, cq));
    }
    ::grpc::Status addProccess(::grpc::ClientContext* context, const ::crypto::AddProcessRequest& request, ::crypto::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::Empty>> AsyncaddProccess(::grpc::ClientContext* context, const ::crypto::AddProcessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::Empty>>(AsyncaddProccessRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::Empty>> PrepareAsyncaddProccess(::grpc::ClientContext* context, const ::crypto::AddProcessRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::Empty>>(PrepareAsyncaddProccessRaw(context, request, cq));
    }
    ::grpc::Status configure(::grpc::ClientContext* context, const ::crypto::ConfigureRequest& request, ::crypto::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::Empty>> Asyncconfigure(::grpc::ClientContext* context, const ::crypto::ConfigureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::Empty>>(AsyncconfigureRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::Empty>> PrepareAsyncconfigure(::grpc::ClientContext* context, const ::crypto::ConfigureRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::Empty>>(PrepareAsyncconfigureRaw(context, request, cq));
    }
    ::grpc::Status generateAESKey(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest& request, ::crypto::GenerateAESKeyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GenerateAESKeyResponse>> AsyncgenerateAESKey(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GenerateAESKeyResponse>>(AsyncgenerateAESKeyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GenerateAESKeyResponse>> PrepareAsyncgenerateAESKey(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GenerateAESKeyResponse>>(PrepareAsyncgenerateAESKeyRaw(context, request, cq));
    }
    ::grpc::Status generateRSAKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::crypto::GenerateKeyPairResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>> AsyncgenerateRSAKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>>(AsyncgenerateRSAKeyPairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>> PrepareAsyncgenerateRSAKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>>(PrepareAsyncgenerateRSAKeyPairRaw(context, request, cq));
    }
    ::grpc::Status generateECCKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::crypto::GenerateKeyPairResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>> AsyncgenerateECCKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>>(AsyncgenerateECCKeyPairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>> PrepareAsyncgenerateECCKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>>(PrepareAsyncgenerateECCKeyPairRaw(context, request, cq));
    }
    ::grpc::Status getSignedDataLength(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest& request, ::crypto::GetLengthResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> AsyncgetSignedDataLength(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(AsyncgetSignedDataLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> PrepareAsyncgetSignedDataLength(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(PrepareAsyncgetSignedDataLengthRaw(context, request, cq));
    }
    ::grpc::Status getECCencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::crypto::GetLengthResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> AsyncgetECCencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(AsyncgetECCencryptedLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> PrepareAsyncgetECCencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(PrepareAsyncgetECCencryptedLengthRaw(context, request, cq));
    }
    ::grpc::Status getECCDecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::crypto::GetLengthResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> AsyncgetECCDecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(AsyncgetECCDecryptedLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> PrepareAsyncgetECCDecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(PrepareAsyncgetECCDecryptedLengthRaw(context, request, cq));
    }
    ::grpc::Status getRSAencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::crypto::GetLengthResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> AsyncgetRSAencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(AsyncgetRSAencryptedLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> PrepareAsyncgetRSAencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(PrepareAsyncgetRSAencryptedLengthRaw(context, request, cq));
    }
    ::grpc::Status getRSAdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::crypto::GetLengthResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> AsyncgetRSAdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(AsyncgetRSAdecryptedLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> PrepareAsyncgetRSAdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(PrepareAsyncgetRSAdecryptedLengthRaw(context, request, cq));
    }
    ::grpc::Status getAESencryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::crypto::GetLengthResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> AsyncgetAESencryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(AsyncgetAESencryptedLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> PrepareAsyncgetAESencryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(PrepareAsyncgetAESencryptedLengthRaw(context, request, cq));
    }
    ::grpc::Status getAESdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::crypto::GetLengthResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> AsyncgetAESdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(AsyncgetAESdecryptedLengthRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> PrepareAsyncgetAESdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(PrepareAsyncgetAESdecryptedLengthRaw(context, request, cq));
    }
    ::grpc::Status getEncryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::crypto::GetLengthResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> AsyncgetEncryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(AsyncgetEncryptedLenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> PrepareAsyncgetEncryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(PrepareAsyncgetEncryptedLenRaw(context, request, cq));
    }
    ::grpc::Status getDecryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::crypto::GetLengthResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> AsyncgetDecryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(AsyncgetDecryptedLenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>> PrepareAsyncgetDecryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>>(PrepareAsyncgetDecryptedLenRaw(context, request, cq));
    }
    ::grpc::Status sign(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::crypto::SignResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>> Asyncsign(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>>(AsyncsignRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>> PrepareAsyncsign(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>>(PrepareAsyncsignRaw(context, request, cq));
    }
    ::grpc::Status verify(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::crypto::VerifyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>> Asyncverify(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>>(AsyncverifyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>> PrepareAsyncverify(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>>(PrepareAsyncverifyRaw(context, request, cq));
    }
    ::grpc::Status getPublicECCKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::crypto::KeyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>> AsyncgetPublicECCKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>>(AsyncgetPublicECCKeyByUserIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>> PrepareAsyncgetPublicECCKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>>(PrepareAsyncgetPublicECCKeyByUserIdRaw(context, request, cq));
    }
    ::grpc::Status getPublicRSAKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::crypto::KeyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>> AsyncgetPublicRSAKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>>(AsyncgetPublicRSAKeyByUserIdRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>> PrepareAsyncgetPublicRSAKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>>(PrepareAsyncgetPublicRSAKeyByUserIdRaw(context, request, cq));
    }
    ::grpc::Status ECCencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::crypto::AsymetricEncryptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>> AsyncECCencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>>(AsyncECCencryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>> PrepareAsyncECCencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>>(PrepareAsyncECCencryptRaw(context, request, cq));
    }
    ::grpc::Status ECCdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::crypto::AsymetricDecryptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>> AsyncECCdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>>(AsyncECCdecryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>> PrepareAsyncECCdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>>(PrepareAsyncECCdecryptRaw(context, request, cq));
    }
    ::grpc::Status RSAencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::crypto::AsymetricEncryptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>> AsyncRSAencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>>(AsyncRSAencryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>> PrepareAsyncRSAencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>>(PrepareAsyncRSAencryptRaw(context, request, cq));
    }
    ::grpc::Status RSAdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::crypto::AsymetricDecryptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>> AsyncRSAdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>>(AsyncRSAdecryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>> PrepareAsyncRSAdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>>(PrepareAsyncRSAdecryptRaw(context, request, cq));
    }
    ::grpc::Status AESencrypt(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest& request, ::crypto::AESEncryptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AESEncryptResponse>> AsyncAESencrypt(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AESEncryptResponse>>(AsyncAESencryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AESEncryptResponse>> PrepareAsyncAESencrypt(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AESEncryptResponse>>(PrepareAsyncAESencryptRaw(context, request, cq));
    }
    ::grpc::Status AESdecrypt(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest& request, ::crypto::AESDecryptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AESDecryptResponse>> AsyncAESdecrypt(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AESDecryptResponse>>(AsyncAESdecryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AESDecryptResponse>> PrepareAsyncAESdecrypt(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::AESDecryptResponse>>(PrepareAsyncAESdecryptRaw(context, request, cq));
    }
    ::grpc::Status encrypt(::grpc::ClientContext* context, const ::crypto::EncryptRequest& request, ::crypto::EncryptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::EncryptResponse>> Asyncencrypt(::grpc::ClientContext* context, const ::crypto::EncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::EncryptResponse>>(AsyncencryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::EncryptResponse>> PrepareAsyncencrypt(::grpc::ClientContext* context, const ::crypto::EncryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::EncryptResponse>>(PrepareAsyncencryptRaw(context, request, cq));
    }
    ::grpc::Status decrypt(::grpc::ClientContext* context, const ::crypto::DecryptRequest& request, ::crypto::DecryptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::DecryptResponse>> Asyncdecrypt(::grpc::ClientContext* context, const ::crypto::DecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::DecryptResponse>>(AsyncdecryptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::DecryptResponse>> PrepareAsyncdecrypt(::grpc::ClientContext* context, const ::crypto::DecryptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::DecryptResponse>>(PrepareAsyncdecryptRaw(context, request, cq));
    }
    ::grpc::Status signUpdate(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::crypto::SignResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>> AsyncsignUpdate(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>>(AsyncsignUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>> PrepareAsyncsignUpdate(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>>(PrepareAsyncsignUpdateRaw(context, request, cq));
    }
    ::grpc::Status signFinalize(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::crypto::SignResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>> AsyncsignFinalize(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>>(AsyncsignFinalizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>> PrepareAsyncsignFinalize(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>>(PrepareAsyncsignFinalizeRaw(context, request, cq));
    }
    ::grpc::Status verifyUpdate(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::crypto::VerifyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>> AsyncverifyUpdate(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>>(AsyncverifyUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>> PrepareAsyncverifyUpdate(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>>(PrepareAsyncverifyUpdateRaw(context, request, cq));
    }
    ::grpc::Status verifyFinalize(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::crypto::VerifyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>> AsyncverifyFinalize(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>>(AsyncverifyFinalizeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>> PrepareAsyncverifyFinalize(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>>(PrepareAsyncverifyFinalizeRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void bootSystem(::grpc::ClientContext* context, const ::crypto::BootSystemRequest* request, ::crypto::Empty* response, std::function<void(::grpc::Status)>) override;
      void bootSystem(::grpc::ClientContext* context, const ::crypto::BootSystemRequest* request, ::crypto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void addProccess(::grpc::ClientContext* context, const ::crypto::AddProcessRequest* request, ::crypto::Empty* response, std::function<void(::grpc::Status)>) override;
      void addProccess(::grpc::ClientContext* context, const ::crypto::AddProcessRequest* request, ::crypto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void configure(::grpc::ClientContext* context, const ::crypto::ConfigureRequest* request, ::crypto::Empty* response, std::function<void(::grpc::Status)>) override;
      void configure(::grpc::ClientContext* context, const ::crypto::ConfigureRequest* request, ::crypto::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void generateAESKey(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest* request, ::crypto::GenerateAESKeyResponse* response, std::function<void(::grpc::Status)>) override;
      void generateAESKey(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest* request, ::crypto::GenerateAESKeyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void generateRSAKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response, std::function<void(::grpc::Status)>) override;
      void generateRSAKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void generateECCKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response, std::function<void(::grpc::Status)>) override;
      void generateECCKeyPair(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getSignedDataLength(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) override;
      void getSignedDataLength(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getECCencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) override;
      void getECCencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getECCDecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) override;
      void getECCDecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getRSAencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) override;
      void getRSAencryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getRSAdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) override;
      void getRSAdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getAESencryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) override;
      void getAESencryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getAESdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) override;
      void getAESdecryptedLength(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getEncryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) override;
      void getEncryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getDecryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response, std::function<void(::grpc::Status)>) override;
      void getDecryptedLen(::grpc::ClientContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void sign(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, std::function<void(::grpc::Status)>) override;
      void sign(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void verify(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, std::function<void(::grpc::Status)>) override;
      void verify(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getPublicECCKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response, std::function<void(::grpc::Status)>) override;
      void getPublicECCKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void getPublicRSAKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response, std::function<void(::grpc::Status)>) override;
      void getPublicRSAKeyByUserId(::grpc::ClientContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ECCencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response, std::function<void(::grpc::Status)>) override;
      void ECCencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ECCdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response, std::function<void(::grpc::Status)>) override;
      void ECCdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RSAencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response, std::function<void(::grpc::Status)>) override;
      void RSAencrypt(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RSAdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response, std::function<void(::grpc::Status)>) override;
      void RSAdecrypt(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AESencrypt(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest* request, ::crypto::AESEncryptResponse* response, std::function<void(::grpc::Status)>) override;
      void AESencrypt(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest* request, ::crypto::AESEncryptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AESdecrypt(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest* request, ::crypto::AESDecryptResponse* response, std::function<void(::grpc::Status)>) override;
      void AESdecrypt(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest* request, ::crypto::AESDecryptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void encrypt(::grpc::ClientContext* context, const ::crypto::EncryptRequest* request, ::crypto::EncryptResponse* response, std::function<void(::grpc::Status)>) override;
      void encrypt(::grpc::ClientContext* context, const ::crypto::EncryptRequest* request, ::crypto::EncryptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void decrypt(::grpc::ClientContext* context, const ::crypto::DecryptRequest* request, ::crypto::DecryptResponse* response, std::function<void(::grpc::Status)>) override;
      void decrypt(::grpc::ClientContext* context, const ::crypto::DecryptRequest* request, ::crypto::DecryptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void signUpdate(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, std::function<void(::grpc::Status)>) override;
      void signUpdate(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void signFinalize(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, std::function<void(::grpc::Status)>) override;
      void signFinalize(::grpc::ClientContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void verifyUpdate(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, std::function<void(::grpc::Status)>) override;
      void verifyUpdate(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void verifyFinalize(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, std::function<void(::grpc::Status)>) override;
      void verifyFinalize(::grpc::ClientContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::crypto::Empty>* AsyncbootSystemRaw(::grpc::ClientContext* context, const ::crypto::BootSystemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::Empty>* PrepareAsyncbootSystemRaw(::grpc::ClientContext* context, const ::crypto::BootSystemRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::Empty>* AsyncaddProccessRaw(::grpc::ClientContext* context, const ::crypto::AddProcessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::Empty>* PrepareAsyncaddProccessRaw(::grpc::ClientContext* context, const ::crypto::AddProcessRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::Empty>* AsyncconfigureRaw(::grpc::ClientContext* context, const ::crypto::ConfigureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::Empty>* PrepareAsyncconfigureRaw(::grpc::ClientContext* context, const ::crypto::ConfigureRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GenerateAESKeyResponse>* AsyncgenerateAESKeyRaw(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GenerateAESKeyResponse>* PrepareAsyncgenerateAESKeyRaw(::grpc::ClientContext* context, const ::crypto::GenerateAESKeyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>* AsyncgenerateRSAKeyPairRaw(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>* PrepareAsyncgenerateRSAKeyPairRaw(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>* AsyncgenerateECCKeyPairRaw(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GenerateKeyPairResponse>* PrepareAsyncgenerateECCKeyPairRaw(::grpc::ClientContext* context, const ::crypto::GenerateKeyPairRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* AsyncgetSignedDataLengthRaw(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* PrepareAsyncgetSignedDataLengthRaw(::grpc::ClientContext* context, const ::crypto::GetHashLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* AsyncgetECCencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* PrepareAsyncgetECCencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* AsyncgetECCDecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* PrepareAsyncgetECCDecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* AsyncgetRSAencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* PrepareAsyncgetRSAencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* AsyncgetRSAdecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* PrepareAsyncgetRSAdecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* AsyncgetAESencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* PrepareAsyncgetAESencryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* AsyncgetAESdecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* PrepareAsyncgetAESdecryptedLengthRaw(::grpc::ClientContext* context, const ::crypto::GetAESLengthRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* AsyncgetEncryptedLenRaw(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* PrepareAsyncgetEncryptedLenRaw(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* AsyncgetDecryptedLenRaw(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::GetLengthResponse>* PrepareAsyncgetDecryptedLenRaw(::grpc::ClientContext* context, const ::crypto::GetWholeLength& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>* AsyncsignRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>* PrepareAsyncsignRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>* AsyncverifyRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>* PrepareAsyncverifyRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>* AsyncgetPublicECCKeyByUserIdRaw(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>* PrepareAsyncgetPublicECCKeyByUserIdRaw(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>* AsyncgetPublicRSAKeyByUserIdRaw(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::KeyResponse>* PrepareAsyncgetPublicRSAKeyByUserIdRaw(::grpc::ClientContext* context, const ::crypto::KeyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>* AsyncECCencryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>* PrepareAsyncECCencryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>* AsyncECCdecryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>* PrepareAsyncECCdecryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>* AsyncRSAencryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricEncryptResponse>* PrepareAsyncRSAencryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricEncryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>* AsyncRSAdecryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::AsymetricDecryptResponse>* PrepareAsyncRSAdecryptRaw(::grpc::ClientContext* context, const ::crypto::AsymetricDecryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::AESEncryptResponse>* AsyncAESencryptRaw(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::AESEncryptResponse>* PrepareAsyncAESencryptRaw(::grpc::ClientContext* context, const ::crypto::AESEncryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::AESDecryptResponse>* AsyncAESdecryptRaw(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::AESDecryptResponse>* PrepareAsyncAESdecryptRaw(::grpc::ClientContext* context, const ::crypto::AESDecryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::EncryptResponse>* AsyncencryptRaw(::grpc::ClientContext* context, const ::crypto::EncryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::EncryptResponse>* PrepareAsyncencryptRaw(::grpc::ClientContext* context, const ::crypto::EncryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::DecryptResponse>* AsyncdecryptRaw(::grpc::ClientContext* context, const ::crypto::DecryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::DecryptResponse>* PrepareAsyncdecryptRaw(::grpc::ClientContext* context, const ::crypto::DecryptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>* AsyncsignUpdateRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>* PrepareAsyncsignUpdateRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>* AsyncsignFinalizeRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::SignResponse>* PrepareAsyncsignFinalizeRaw(::grpc::ClientContext* context, const ::crypto::SignRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>* AsyncverifyUpdateRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>* PrepareAsyncverifyUpdateRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>* AsyncverifyFinalizeRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::crypto::VerifyResponse>* PrepareAsyncverifyFinalizeRaw(::grpc::ClientContext* context, const ::crypto::VerifyRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_bootSystem_;
    const ::grpc::internal::RpcMethod rpcmethod_addProccess_;
    const ::grpc::internal::RpcMethod rpcmethod_configure_;
    const ::grpc::internal::RpcMethod rpcmethod_generateAESKey_;
    const ::grpc::internal::RpcMethod rpcmethod_generateRSAKeyPair_;
    const ::grpc::internal::RpcMethod rpcmethod_generateECCKeyPair_;
    const ::grpc::internal::RpcMethod rpcmethod_getSignedDataLength_;
    const ::grpc::internal::RpcMethod rpcmethod_getECCencryptedLength_;
    const ::grpc::internal::RpcMethod rpcmethod_getECCDecryptedLength_;
    const ::grpc::internal::RpcMethod rpcmethod_getRSAencryptedLength_;
    const ::grpc::internal::RpcMethod rpcmethod_getRSAdecryptedLength_;
    const ::grpc::internal::RpcMethod rpcmethod_getAESencryptedLength_;
    const ::grpc::internal::RpcMethod rpcmethod_getAESdecryptedLength_;
    const ::grpc::internal::RpcMethod rpcmethod_getEncryptedLen_;
    const ::grpc::internal::RpcMethod rpcmethod_getDecryptedLen_;
    const ::grpc::internal::RpcMethod rpcmethod_sign_;
    const ::grpc::internal::RpcMethod rpcmethod_verify_;
    const ::grpc::internal::RpcMethod rpcmethod_getPublicECCKeyByUserId_;
    const ::grpc::internal::RpcMethod rpcmethod_getPublicRSAKeyByUserId_;
    const ::grpc::internal::RpcMethod rpcmethod_ECCencrypt_;
    const ::grpc::internal::RpcMethod rpcmethod_ECCdecrypt_;
    const ::grpc::internal::RpcMethod rpcmethod_RSAencrypt_;
    const ::grpc::internal::RpcMethod rpcmethod_RSAdecrypt_;
    const ::grpc::internal::RpcMethod rpcmethod_AESencrypt_;
    const ::grpc::internal::RpcMethod rpcmethod_AESdecrypt_;
    const ::grpc::internal::RpcMethod rpcmethod_encrypt_;
    const ::grpc::internal::RpcMethod rpcmethod_decrypt_;
    const ::grpc::internal::RpcMethod rpcmethod_signUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_signFinalize_;
    const ::grpc::internal::RpcMethod rpcmethod_verifyUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_verifyFinalize_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status bootSystem(::grpc::ServerContext* context, const ::crypto::BootSystemRequest* request, ::crypto::Empty* response);
    virtual ::grpc::Status addProccess(::grpc::ServerContext* context, const ::crypto::AddProcessRequest* request, ::crypto::Empty* response);
    virtual ::grpc::Status configure(::grpc::ServerContext* context, const ::crypto::ConfigureRequest* request, ::crypto::Empty* response);
    virtual ::grpc::Status generateAESKey(::grpc::ServerContext* context, const ::crypto::GenerateAESKeyRequest* request, ::crypto::GenerateAESKeyResponse* response);
    virtual ::grpc::Status generateRSAKeyPair(::grpc::ServerContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response);
    virtual ::grpc::Status generateECCKeyPair(::grpc::ServerContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response);
    virtual ::grpc::Status getSignedDataLength(::grpc::ServerContext* context, const ::crypto::GetHashLengthRequest* request, ::crypto::GetLengthResponse* response);
    virtual ::grpc::Status getECCencryptedLength(::grpc::ServerContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response);
    virtual ::grpc::Status getECCDecryptedLength(::grpc::ServerContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response);
    virtual ::grpc::Status getRSAencryptedLength(::grpc::ServerContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response);
    virtual ::grpc::Status getRSAdecryptedLength(::grpc::ServerContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response);
    virtual ::grpc::Status getAESencryptedLength(::grpc::ServerContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response);
    virtual ::grpc::Status getAESdecryptedLength(::grpc::ServerContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response);
    virtual ::grpc::Status getEncryptedLen(::grpc::ServerContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response);
    virtual ::grpc::Status getDecryptedLen(::grpc::ServerContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response);
    virtual ::grpc::Status sign(::grpc::ServerContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response);
    virtual ::grpc::Status verify(::grpc::ServerContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response);
    virtual ::grpc::Status getPublicECCKeyByUserId(::grpc::ServerContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response);
    virtual ::grpc::Status getPublicRSAKeyByUserId(::grpc::ServerContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response);
    virtual ::grpc::Status ECCencrypt(::grpc::ServerContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response);
    virtual ::grpc::Status ECCdecrypt(::grpc::ServerContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response);
    virtual ::grpc::Status RSAencrypt(::grpc::ServerContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response);
    virtual ::grpc::Status RSAdecrypt(::grpc::ServerContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response);
    virtual ::grpc::Status AESencrypt(::grpc::ServerContext* context, const ::crypto::AESEncryptRequest* request, ::crypto::AESEncryptResponse* response);
    virtual ::grpc::Status AESdecrypt(::grpc::ServerContext* context, const ::crypto::AESDecryptRequest* request, ::crypto::AESDecryptResponse* response);
    virtual ::grpc::Status encrypt(::grpc::ServerContext* context, const ::crypto::EncryptRequest* request, ::crypto::EncryptResponse* response);
    virtual ::grpc::Status decrypt(::grpc::ServerContext* context, const ::crypto::DecryptRequest* request, ::crypto::DecryptResponse* response);
    virtual ::grpc::Status signUpdate(::grpc::ServerContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response);
    virtual ::grpc::Status signFinalize(::grpc::ServerContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response);
    virtual ::grpc::Status verifyUpdate(::grpc::ServerContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response);
    virtual ::grpc::Status verifyFinalize(::grpc::ServerContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_bootSystem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_bootSystem() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_bootSystem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bootSystem(::grpc::ServerContext* /*context*/, const ::crypto::BootSystemRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbootSystem(::grpc::ServerContext* context, ::crypto::BootSystemRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_addProccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_addProccess() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_addProccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addProccess(::grpc::ServerContext* /*context*/, const ::crypto::AddProcessRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestaddProccess(::grpc::ServerContext* context, ::crypto::AddProcessRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_configure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_configure() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_configure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status configure(::grpc::ServerContext* /*context*/, const ::crypto::ConfigureRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestconfigure(::grpc::ServerContext* context, ::crypto::ConfigureRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_generateAESKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_generateAESKey() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_generateAESKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateAESKey(::grpc::ServerContext* /*context*/, const ::crypto::GenerateAESKeyRequest* /*request*/, ::crypto::GenerateAESKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgenerateAESKey(::grpc::ServerContext* context, ::crypto::GenerateAESKeyRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::GenerateAESKeyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_generateRSAKeyPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_generateRSAKeyPair() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_generateRSAKeyPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateRSAKeyPair(::grpc::ServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgenerateRSAKeyPair(::grpc::ServerContext* context, ::crypto::GenerateKeyPairRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::GenerateKeyPairResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_generateECCKeyPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_generateECCKeyPair() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_generateECCKeyPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateECCKeyPair(::grpc::ServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgenerateECCKeyPair(::grpc::ServerContext* context, ::crypto::GenerateKeyPairRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::GenerateKeyPairResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getSignedDataLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getSignedDataLength() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_getSignedDataLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSignedDataLength(::grpc::ServerContext* /*context*/, const ::crypto::GetHashLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetSignedDataLength(::grpc::ServerContext* context, ::crypto::GetHashLengthRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::GetLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getECCencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getECCencryptedLength() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_getECCencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getECCencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetECCencryptedLength(::grpc::ServerContext* context, ::crypto::GetLengthRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::GetLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getECCDecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getECCDecryptedLength() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_getECCDecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getECCDecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetECCDecryptedLength(::grpc::ServerContext* context, ::crypto::GetLengthRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::GetLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRSAencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getRSAencryptedLength() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_getRSAencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRSAencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRSAencryptedLength(::grpc::ServerContext* context, ::crypto::GetLengthRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::GetLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getRSAdecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getRSAdecryptedLength() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_getRSAdecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRSAdecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRSAdecryptedLength(::grpc::ServerContext* context, ::crypto::GetLengthRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::GetLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getAESencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getAESencryptedLength() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_getAESencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAESencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAESencryptedLength(::grpc::ServerContext* context, ::crypto::GetAESLengthRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::GetLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getAESdecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getAESdecryptedLength() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_getAESdecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAESdecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAESdecryptedLength(::grpc::ServerContext* context, ::crypto::GetAESLengthRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::GetLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getEncryptedLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getEncryptedLen() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_getEncryptedLen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEncryptedLen(::grpc::ServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetEncryptedLen(::grpc::ServerContext* context, ::crypto::GetWholeLength* request, ::grpc::ServerAsyncResponseWriter< ::crypto::GetLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getDecryptedLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getDecryptedLen() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_getDecryptedLen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDecryptedLen(::grpc::ServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetDecryptedLen(::grpc::ServerContext* context, ::crypto::GetWholeLength* request, ::grpc::ServerAsyncResponseWriter< ::crypto::GetLengthResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_sign : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_sign() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_sign() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sign(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsign(::grpc::ServerContext* context, ::crypto::SignRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::SignResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_verify : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_verify() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_verify() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verify(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestverify(::grpc::ServerContext* context, ::crypto::VerifyRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::VerifyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getPublicECCKeyByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getPublicECCKeyByUserId() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_getPublicECCKeyByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPublicECCKeyByUserId(::grpc::ServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetPublicECCKeyByUserId(::grpc::ServerContext* context, ::crypto::KeyRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::KeyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_getPublicRSAKeyByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_getPublicRSAKeyByUserId() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_getPublicRSAKeyByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPublicRSAKeyByUserId(::grpc::ServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetPublicRSAKeyByUserId(::grpc::ServerContext* context, ::crypto::KeyRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::KeyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ECCencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ECCencrypt() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_ECCencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ECCencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestECCencrypt(::grpc::ServerContext* context, ::crypto::AsymetricEncryptRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::AsymetricEncryptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ECCdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ECCdecrypt() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_ECCdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ECCdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestECCdecrypt(::grpc::ServerContext* context, ::crypto::AsymetricDecryptRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::AsymetricDecryptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RSAencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RSAencrypt() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_RSAencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RSAencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRSAencrypt(::grpc::ServerContext* context, ::crypto::AsymetricEncryptRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::AsymetricEncryptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RSAdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RSAdecrypt() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_RSAdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RSAdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRSAdecrypt(::grpc::ServerContext* context, ::crypto::AsymetricDecryptRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::AsymetricDecryptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AESencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AESencrypt() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_AESencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AESencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AESEncryptRequest* /*request*/, ::crypto::AESEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAESencrypt(::grpc::ServerContext* context, ::crypto::AESEncryptRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::AESEncryptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AESdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AESdecrypt() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_AESdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AESdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AESDecryptRequest* /*request*/, ::crypto::AESDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAESdecrypt(::grpc::ServerContext* context, ::crypto::AESDecryptRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::AESDecryptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_encrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_encrypt() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_encrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status encrypt(::grpc::ServerContext* /*context*/, const ::crypto::EncryptRequest* /*request*/, ::crypto::EncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestencrypt(::grpc::ServerContext* context, ::crypto::EncryptRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::EncryptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_decrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_decrypt() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_decrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decrypt(::grpc::ServerContext* /*context*/, const ::crypto::DecryptRequest* /*request*/, ::crypto::DecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdecrypt(::grpc::ServerContext* context, ::crypto::DecryptRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::DecryptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_signUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_signUpdate() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_signUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status signUpdate(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsignUpdate(::grpc::ServerContext* context, ::crypto::SignRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::SignResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_signFinalize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_signFinalize() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_signFinalize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status signFinalize(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsignFinalize(::grpc::ServerContext* context, ::crypto::SignRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::SignResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_verifyUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_verifyUpdate() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_verifyUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verifyUpdate(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestverifyUpdate(::grpc::ServerContext* context, ::crypto::VerifyRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::VerifyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_verifyFinalize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_verifyFinalize() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_verifyFinalize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verifyFinalize(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestverifyFinalize(::grpc::ServerContext* context, ::crypto::VerifyRequest* request, ::grpc::ServerAsyncResponseWriter< ::crypto::VerifyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_bootSystem<WithAsyncMethod_addProccess<WithAsyncMethod_configure<WithAsyncMethod_generateAESKey<WithAsyncMethod_generateRSAKeyPair<WithAsyncMethod_generateECCKeyPair<WithAsyncMethod_getSignedDataLength<WithAsyncMethod_getECCencryptedLength<WithAsyncMethod_getECCDecryptedLength<WithAsyncMethod_getRSAencryptedLength<WithAsyncMethod_getRSAdecryptedLength<WithAsyncMethod_getAESencryptedLength<WithAsyncMethod_getAESdecryptedLength<WithAsyncMethod_getEncryptedLen<WithAsyncMethod_getDecryptedLen<WithAsyncMethod_sign<WithAsyncMethod_verify<WithAsyncMethod_getPublicECCKeyByUserId<WithAsyncMethod_getPublicRSAKeyByUserId<WithAsyncMethod_ECCencrypt<WithAsyncMethod_ECCdecrypt<WithAsyncMethod_RSAencrypt<WithAsyncMethod_RSAdecrypt<WithAsyncMethod_AESencrypt<WithAsyncMethod_AESdecrypt<WithAsyncMethod_encrypt<WithAsyncMethod_decrypt<WithAsyncMethod_signUpdate<WithAsyncMethod_signFinalize<WithAsyncMethod_verifyUpdate<WithAsyncMethod_verifyFinalize<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_bootSystem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_bootSystem() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::BootSystemRequest, ::crypto::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::BootSystemRequest* request, ::crypto::Empty* response) { return this->bootSystem(context, request, response); }));}
    void SetMessageAllocatorFor_bootSystem(
        ::grpc::MessageAllocator< ::crypto::BootSystemRequest, ::crypto::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::BootSystemRequest, ::crypto::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_bootSystem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bootSystem(::grpc::ServerContext* /*context*/, const ::crypto::BootSystemRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* bootSystem(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::BootSystemRequest* /*request*/, ::crypto::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_addProccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_addProccess() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::AddProcessRequest, ::crypto::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::AddProcessRequest* request, ::crypto::Empty* response) { return this->addProccess(context, request, response); }));}
    void SetMessageAllocatorFor_addProccess(
        ::grpc::MessageAllocator< ::crypto::AddProcessRequest, ::crypto::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::AddProcessRequest, ::crypto::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_addProccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addProccess(::grpc::ServerContext* /*context*/, const ::crypto::AddProcessRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* addProccess(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::AddProcessRequest* /*request*/, ::crypto::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_configure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_configure() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::ConfigureRequest, ::crypto::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::ConfigureRequest* request, ::crypto::Empty* response) { return this->configure(context, request, response); }));}
    void SetMessageAllocatorFor_configure(
        ::grpc::MessageAllocator< ::crypto::ConfigureRequest, ::crypto::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::ConfigureRequest, ::crypto::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_configure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status configure(::grpc::ServerContext* /*context*/, const ::crypto::ConfigureRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* configure(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::ConfigureRequest* /*request*/, ::crypto::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_generateAESKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_generateAESKey() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::GenerateAESKeyRequest, ::crypto::GenerateAESKeyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::GenerateAESKeyRequest* request, ::crypto::GenerateAESKeyResponse* response) { return this->generateAESKey(context, request, response); }));}
    void SetMessageAllocatorFor_generateAESKey(
        ::grpc::MessageAllocator< ::crypto::GenerateAESKeyRequest, ::crypto::GenerateAESKeyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::GenerateAESKeyRequest, ::crypto::GenerateAESKeyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_generateAESKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateAESKey(::grpc::ServerContext* /*context*/, const ::crypto::GenerateAESKeyRequest* /*request*/, ::crypto::GenerateAESKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* generateAESKey(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::GenerateAESKeyRequest* /*request*/, ::crypto::GenerateAESKeyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_generateRSAKeyPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_generateRSAKeyPair() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response) { return this->generateRSAKeyPair(context, request, response); }));}
    void SetMessageAllocatorFor_generateRSAKeyPair(
        ::grpc::MessageAllocator< ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_generateRSAKeyPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateRSAKeyPair(::grpc::ServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* generateRSAKeyPair(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_generateECCKeyPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_generateECCKeyPair() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::GenerateKeyPairRequest* request, ::crypto::GenerateKeyPairResponse* response) { return this->generateECCKeyPair(context, request, response); }));}
    void SetMessageAllocatorFor_generateECCKeyPair(
        ::grpc::MessageAllocator< ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_generateECCKeyPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateECCKeyPair(::grpc::ServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* generateECCKeyPair(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getSignedDataLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getSignedDataLength() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::GetHashLengthRequest, ::crypto::GetLengthResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::GetHashLengthRequest* request, ::crypto::GetLengthResponse* response) { return this->getSignedDataLength(context, request, response); }));}
    void SetMessageAllocatorFor_getSignedDataLength(
        ::grpc::MessageAllocator< ::crypto::GetHashLengthRequest, ::crypto::GetLengthResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::GetHashLengthRequest, ::crypto::GetLengthResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getSignedDataLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSignedDataLength(::grpc::ServerContext* /*context*/, const ::crypto::GetHashLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getSignedDataLength(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::GetHashLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getECCencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getECCencryptedLength() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response) { return this->getECCencryptedLength(context, request, response); }));}
    void SetMessageAllocatorFor_getECCencryptedLength(
        ::grpc::MessageAllocator< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getECCencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getECCencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getECCencryptedLength(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getECCDecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getECCDecryptedLength() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response) { return this->getECCDecryptedLength(context, request, response); }));}
    void SetMessageAllocatorFor_getECCDecryptedLength(
        ::grpc::MessageAllocator< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getECCDecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getECCDecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getECCDecryptedLength(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getRSAencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getRSAencryptedLength() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response) { return this->getRSAencryptedLength(context, request, response); }));}
    void SetMessageAllocatorFor_getRSAencryptedLength(
        ::grpc::MessageAllocator< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getRSAencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRSAencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRSAencryptedLength(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getRSAdecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getRSAdecryptedLength() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::GetLengthRequest* request, ::crypto::GetLengthResponse* response) { return this->getRSAdecryptedLength(context, request, response); }));}
    void SetMessageAllocatorFor_getRSAdecryptedLength(
        ::grpc::MessageAllocator< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getRSAdecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRSAdecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRSAdecryptedLength(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getAESencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getAESencryptedLength() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response) { return this->getAESencryptedLength(context, request, response); }));}
    void SetMessageAllocatorFor_getAESencryptedLength(
        ::grpc::MessageAllocator< ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getAESencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAESencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getAESencryptedLength(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getAESdecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getAESdecryptedLength() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::GetAESLengthRequest* request, ::crypto::GetLengthResponse* response) { return this->getAESdecryptedLength(context, request, response); }));}
    void SetMessageAllocatorFor_getAESdecryptedLength(
        ::grpc::MessageAllocator< ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getAESdecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAESdecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getAESdecryptedLength(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getEncryptedLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getEncryptedLen() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::GetWholeLength, ::crypto::GetLengthResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response) { return this->getEncryptedLen(context, request, response); }));}
    void SetMessageAllocatorFor_getEncryptedLen(
        ::grpc::MessageAllocator< ::crypto::GetWholeLength, ::crypto::GetLengthResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::GetWholeLength, ::crypto::GetLengthResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getEncryptedLen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEncryptedLen(::grpc::ServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getEncryptedLen(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getDecryptedLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getDecryptedLen() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::GetWholeLength, ::crypto::GetLengthResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::GetWholeLength* request, ::crypto::GetLengthResponse* response) { return this->getDecryptedLen(context, request, response); }));}
    void SetMessageAllocatorFor_getDecryptedLen(
        ::grpc::MessageAllocator< ::crypto::GetWholeLength, ::crypto::GetLengthResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::GetWholeLength, ::crypto::GetLengthResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getDecryptedLen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDecryptedLen(::grpc::ServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getDecryptedLen(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_sign : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_sign() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::SignRequest, ::crypto::SignResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response) { return this->sign(context, request, response); }));}
    void SetMessageAllocatorFor_sign(
        ::grpc::MessageAllocator< ::crypto::SignRequest, ::crypto::SignResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::SignRequest, ::crypto::SignResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_sign() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sign(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* sign(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_verify : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_verify() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::VerifyRequest, ::crypto::VerifyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response) { return this->verify(context, request, response); }));}
    void SetMessageAllocatorFor_verify(
        ::grpc::MessageAllocator< ::crypto::VerifyRequest, ::crypto::VerifyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::VerifyRequest, ::crypto::VerifyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_verify() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verify(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* verify(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getPublicECCKeyByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getPublicECCKeyByUserId() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::KeyRequest, ::crypto::KeyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response) { return this->getPublicECCKeyByUserId(context, request, response); }));}
    void SetMessageAllocatorFor_getPublicECCKeyByUserId(
        ::grpc::MessageAllocator< ::crypto::KeyRequest, ::crypto::KeyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::KeyRequest, ::crypto::KeyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getPublicECCKeyByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPublicECCKeyByUserId(::grpc::ServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getPublicECCKeyByUserId(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_getPublicRSAKeyByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_getPublicRSAKeyByUserId() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::KeyRequest, ::crypto::KeyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::KeyRequest* request, ::crypto::KeyResponse* response) { return this->getPublicRSAKeyByUserId(context, request, response); }));}
    void SetMessageAllocatorFor_getPublicRSAKeyByUserId(
        ::grpc::MessageAllocator< ::crypto::KeyRequest, ::crypto::KeyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::KeyRequest, ::crypto::KeyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_getPublicRSAKeyByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPublicRSAKeyByUserId(::grpc::ServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getPublicRSAKeyByUserId(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ECCencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ECCencrypt() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response) { return this->ECCencrypt(context, request, response); }));}
    void SetMessageAllocatorFor_ECCencrypt(
        ::grpc::MessageAllocator< ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ECCencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ECCencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ECCencrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ECCdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ECCdecrypt() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response) { return this->ECCdecrypt(context, request, response); }));}
    void SetMessageAllocatorFor_ECCdecrypt(
        ::grpc::MessageAllocator< ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ECCdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ECCdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ECCdecrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RSAencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RSAencrypt() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::AsymetricEncryptRequest* request, ::crypto::AsymetricEncryptResponse* response) { return this->RSAencrypt(context, request, response); }));}
    void SetMessageAllocatorFor_RSAencrypt(
        ::grpc::MessageAllocator< ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RSAencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RSAencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RSAencrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RSAdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RSAdecrypt() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::AsymetricDecryptRequest* request, ::crypto::AsymetricDecryptResponse* response) { return this->RSAdecrypt(context, request, response); }));}
    void SetMessageAllocatorFor_RSAdecrypt(
        ::grpc::MessageAllocator< ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RSAdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RSAdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RSAdecrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AESencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AESencrypt() {
      ::grpc::Service::MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::AESEncryptRequest, ::crypto::AESEncryptResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::AESEncryptRequest* request, ::crypto::AESEncryptResponse* response) { return this->AESencrypt(context, request, response); }));}
    void SetMessageAllocatorFor_AESencrypt(
        ::grpc::MessageAllocator< ::crypto::AESEncryptRequest, ::crypto::AESEncryptResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::AESEncryptRequest, ::crypto::AESEncryptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AESencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AESencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AESEncryptRequest* /*request*/, ::crypto::AESEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AESencrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::AESEncryptRequest* /*request*/, ::crypto::AESEncryptResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AESdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AESdecrypt() {
      ::grpc::Service::MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::AESDecryptRequest, ::crypto::AESDecryptResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::AESDecryptRequest* request, ::crypto::AESDecryptResponse* response) { return this->AESdecrypt(context, request, response); }));}
    void SetMessageAllocatorFor_AESdecrypt(
        ::grpc::MessageAllocator< ::crypto::AESDecryptRequest, ::crypto::AESDecryptResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::AESDecryptRequest, ::crypto::AESDecryptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AESdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AESdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AESDecryptRequest* /*request*/, ::crypto::AESDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AESdecrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::AESDecryptRequest* /*request*/, ::crypto::AESDecryptResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_encrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_encrypt() {
      ::grpc::Service::MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::EncryptRequest, ::crypto::EncryptResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::EncryptRequest* request, ::crypto::EncryptResponse* response) { return this->encrypt(context, request, response); }));}
    void SetMessageAllocatorFor_encrypt(
        ::grpc::MessageAllocator< ::crypto::EncryptRequest, ::crypto::EncryptResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::EncryptRequest, ::crypto::EncryptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_encrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status encrypt(::grpc::ServerContext* /*context*/, const ::crypto::EncryptRequest* /*request*/, ::crypto::EncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* encrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::EncryptRequest* /*request*/, ::crypto::EncryptResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_decrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_decrypt() {
      ::grpc::Service::MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::DecryptRequest, ::crypto::DecryptResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::DecryptRequest* request, ::crypto::DecryptResponse* response) { return this->decrypt(context, request, response); }));}
    void SetMessageAllocatorFor_decrypt(
        ::grpc::MessageAllocator< ::crypto::DecryptRequest, ::crypto::DecryptResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::DecryptRequest, ::crypto::DecryptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_decrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decrypt(::grpc::ServerContext* /*context*/, const ::crypto::DecryptRequest* /*request*/, ::crypto::DecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* decrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::DecryptRequest* /*request*/, ::crypto::DecryptResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_signUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_signUpdate() {
      ::grpc::Service::MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::SignRequest, ::crypto::SignResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response) { return this->signUpdate(context, request, response); }));}
    void SetMessageAllocatorFor_signUpdate(
        ::grpc::MessageAllocator< ::crypto::SignRequest, ::crypto::SignResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::SignRequest, ::crypto::SignResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_signUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status signUpdate(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* signUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_signFinalize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_signFinalize() {
      ::grpc::Service::MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::SignRequest, ::crypto::SignResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::SignRequest* request, ::crypto::SignResponse* response) { return this->signFinalize(context, request, response); }));}
    void SetMessageAllocatorFor_signFinalize(
        ::grpc::MessageAllocator< ::crypto::SignRequest, ::crypto::SignResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::SignRequest, ::crypto::SignResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_signFinalize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status signFinalize(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* signFinalize(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_verifyUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_verifyUpdate() {
      ::grpc::Service::MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::VerifyRequest, ::crypto::VerifyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response) { return this->verifyUpdate(context, request, response); }));}
    void SetMessageAllocatorFor_verifyUpdate(
        ::grpc::MessageAllocator< ::crypto::VerifyRequest, ::crypto::VerifyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::VerifyRequest, ::crypto::VerifyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_verifyUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verifyUpdate(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* verifyUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_verifyFinalize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_verifyFinalize() {
      ::grpc::Service::MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::crypto::VerifyRequest, ::crypto::VerifyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::crypto::VerifyRequest* request, ::crypto::VerifyResponse* response) { return this->verifyFinalize(context, request, response); }));}
    void SetMessageAllocatorFor_verifyFinalize(
        ::grpc::MessageAllocator< ::crypto::VerifyRequest, ::crypto::VerifyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::crypto::VerifyRequest, ::crypto::VerifyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_verifyFinalize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verifyFinalize(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* verifyFinalize(
      ::grpc::CallbackServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_bootSystem<WithCallbackMethod_addProccess<WithCallbackMethod_configure<WithCallbackMethod_generateAESKey<WithCallbackMethod_generateRSAKeyPair<WithCallbackMethod_generateECCKeyPair<WithCallbackMethod_getSignedDataLength<WithCallbackMethod_getECCencryptedLength<WithCallbackMethod_getECCDecryptedLength<WithCallbackMethod_getRSAencryptedLength<WithCallbackMethod_getRSAdecryptedLength<WithCallbackMethod_getAESencryptedLength<WithCallbackMethod_getAESdecryptedLength<WithCallbackMethod_getEncryptedLen<WithCallbackMethod_getDecryptedLen<WithCallbackMethod_sign<WithCallbackMethod_verify<WithCallbackMethod_getPublicECCKeyByUserId<WithCallbackMethod_getPublicRSAKeyByUserId<WithCallbackMethod_ECCencrypt<WithCallbackMethod_ECCdecrypt<WithCallbackMethod_RSAencrypt<WithCallbackMethod_RSAdecrypt<WithCallbackMethod_AESencrypt<WithCallbackMethod_AESdecrypt<WithCallbackMethod_encrypt<WithCallbackMethod_decrypt<WithCallbackMethod_signUpdate<WithCallbackMethod_signFinalize<WithCallbackMethod_verifyUpdate<WithCallbackMethod_verifyFinalize<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_bootSystem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_bootSystem() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_bootSystem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bootSystem(::grpc::ServerContext* /*context*/, const ::crypto::BootSystemRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_addProccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_addProccess() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_addProccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addProccess(::grpc::ServerContext* /*context*/, const ::crypto::AddProcessRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_configure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_configure() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_configure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status configure(::grpc::ServerContext* /*context*/, const ::crypto::ConfigureRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_generateAESKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_generateAESKey() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_generateAESKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateAESKey(::grpc::ServerContext* /*context*/, const ::crypto::GenerateAESKeyRequest* /*request*/, ::crypto::GenerateAESKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_generateRSAKeyPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_generateRSAKeyPair() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_generateRSAKeyPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateRSAKeyPair(::grpc::ServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_generateECCKeyPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_generateECCKeyPair() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_generateECCKeyPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateECCKeyPair(::grpc::ServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getSignedDataLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getSignedDataLength() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_getSignedDataLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSignedDataLength(::grpc::ServerContext* /*context*/, const ::crypto::GetHashLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getECCencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getECCencryptedLength() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_getECCencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getECCencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getECCDecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getECCDecryptedLength() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_getECCDecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getECCDecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRSAencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getRSAencryptedLength() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_getRSAencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRSAencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getRSAdecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getRSAdecryptedLength() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_getRSAdecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRSAdecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getAESencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getAESencryptedLength() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_getAESencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAESencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getAESdecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getAESdecryptedLength() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_getAESdecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAESdecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getEncryptedLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getEncryptedLen() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_getEncryptedLen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEncryptedLen(::grpc::ServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getDecryptedLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getDecryptedLen() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_getDecryptedLen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDecryptedLen(::grpc::ServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_sign : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_sign() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_sign() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sign(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_verify : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_verify() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_verify() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verify(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getPublicECCKeyByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getPublicECCKeyByUserId() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_getPublicECCKeyByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPublicECCKeyByUserId(::grpc::ServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_getPublicRSAKeyByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_getPublicRSAKeyByUserId() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_getPublicRSAKeyByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPublicRSAKeyByUserId(::grpc::ServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ECCencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ECCencrypt() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_ECCencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ECCencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ECCdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ECCdecrypt() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_ECCdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ECCdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RSAencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RSAencrypt() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_RSAencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RSAencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RSAdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RSAdecrypt() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_RSAdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RSAdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AESencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AESencrypt() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_AESencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AESencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AESEncryptRequest* /*request*/, ::crypto::AESEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AESdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AESdecrypt() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_AESdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AESdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AESDecryptRequest* /*request*/, ::crypto::AESDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_encrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_encrypt() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_encrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status encrypt(::grpc::ServerContext* /*context*/, const ::crypto::EncryptRequest* /*request*/, ::crypto::EncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_decrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_decrypt() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_decrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decrypt(::grpc::ServerContext* /*context*/, const ::crypto::DecryptRequest* /*request*/, ::crypto::DecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_signUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_signUpdate() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_signUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status signUpdate(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_signFinalize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_signFinalize() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_signFinalize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status signFinalize(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_verifyUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_verifyUpdate() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_verifyUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verifyUpdate(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_verifyFinalize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_verifyFinalize() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_verifyFinalize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verifyFinalize(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_bootSystem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_bootSystem() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_bootSystem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bootSystem(::grpc::ServerContext* /*context*/, const ::crypto::BootSystemRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestbootSystem(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_addProccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_addProccess() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_addProccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addProccess(::grpc::ServerContext* /*context*/, const ::crypto::AddProcessRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestaddProccess(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_configure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_configure() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_configure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status configure(::grpc::ServerContext* /*context*/, const ::crypto::ConfigureRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestconfigure(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_generateAESKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_generateAESKey() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_generateAESKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateAESKey(::grpc::ServerContext* /*context*/, const ::crypto::GenerateAESKeyRequest* /*request*/, ::crypto::GenerateAESKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgenerateAESKey(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_generateRSAKeyPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_generateRSAKeyPair() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_generateRSAKeyPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateRSAKeyPair(::grpc::ServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgenerateRSAKeyPair(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_generateECCKeyPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_generateECCKeyPair() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_generateECCKeyPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateECCKeyPair(::grpc::ServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgenerateECCKeyPair(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getSignedDataLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getSignedDataLength() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_getSignedDataLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSignedDataLength(::grpc::ServerContext* /*context*/, const ::crypto::GetHashLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetSignedDataLength(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getECCencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getECCencryptedLength() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_getECCencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getECCencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetECCencryptedLength(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getECCDecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getECCDecryptedLength() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_getECCDecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getECCDecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetECCDecryptedLength(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getRSAencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getRSAencryptedLength() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_getRSAencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRSAencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRSAencryptedLength(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getRSAdecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getRSAdecryptedLength() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_getRSAdecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRSAdecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetRSAdecryptedLength(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getAESencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getAESencryptedLength() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_getAESencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAESencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAESencryptedLength(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getAESdecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getAESdecryptedLength() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_getAESdecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAESdecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetAESdecryptedLength(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getEncryptedLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getEncryptedLen() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_getEncryptedLen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEncryptedLen(::grpc::ServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetEncryptedLen(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getDecryptedLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getDecryptedLen() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_getDecryptedLen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDecryptedLen(::grpc::ServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetDecryptedLen(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_sign : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_sign() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_sign() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sign(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestsign(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_verify : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_verify() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_verify() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verify(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestverify(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getPublicECCKeyByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getPublicECCKeyByUserId() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_getPublicECCKeyByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPublicECCKeyByUserId(::grpc::ServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetPublicECCKeyByUserId(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_getPublicRSAKeyByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_getPublicRSAKeyByUserId() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_getPublicRSAKeyByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPublicRSAKeyByUserId(::grpc::ServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestgetPublicRSAKeyByUserId(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ECCencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ECCencrypt() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_ECCencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ECCencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestECCencrypt(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ECCdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ECCdecrypt() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_ECCdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ECCdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestECCdecrypt(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RSAencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RSAencrypt() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_RSAencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RSAencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRSAencrypt(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RSAdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RSAdecrypt() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_RSAdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RSAdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRSAdecrypt(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AESencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AESencrypt() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_AESencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AESencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AESEncryptRequest* /*request*/, ::crypto::AESEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAESencrypt(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AESdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AESdecrypt() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_AESdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AESdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AESDecryptRequest* /*request*/, ::crypto::AESDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAESdecrypt(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_encrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_encrypt() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_encrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status encrypt(::grpc::ServerContext* /*context*/, const ::crypto::EncryptRequest* /*request*/, ::crypto::EncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestencrypt(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_decrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_decrypt() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_decrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decrypt(::grpc::ServerContext* /*context*/, const ::crypto::DecryptRequest* /*request*/, ::crypto::DecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void Requestdecrypt(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_signUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_signUpdate() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_signUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status signUpdate(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsignUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_signFinalize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_signFinalize() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_signFinalize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status signFinalize(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestsignFinalize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_verifyUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_verifyUpdate() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_verifyUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verifyUpdate(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestverifyUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_verifyFinalize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_verifyFinalize() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_verifyFinalize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verifyFinalize(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestverifyFinalize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_bootSystem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_bootSystem() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->bootSystem(context, request, response); }));
    }
    ~WithRawCallbackMethod_bootSystem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status bootSystem(::grpc::ServerContext* /*context*/, const ::crypto::BootSystemRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* bootSystem(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_addProccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_addProccess() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->addProccess(context, request, response); }));
    }
    ~WithRawCallbackMethod_addProccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status addProccess(::grpc::ServerContext* /*context*/, const ::crypto::AddProcessRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* addProccess(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_configure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_configure() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->configure(context, request, response); }));
    }
    ~WithRawCallbackMethod_configure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status configure(::grpc::ServerContext* /*context*/, const ::crypto::ConfigureRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* configure(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_generateAESKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_generateAESKey() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->generateAESKey(context, request, response); }));
    }
    ~WithRawCallbackMethod_generateAESKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateAESKey(::grpc::ServerContext* /*context*/, const ::crypto::GenerateAESKeyRequest* /*request*/, ::crypto::GenerateAESKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* generateAESKey(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_generateRSAKeyPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_generateRSAKeyPair() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->generateRSAKeyPair(context, request, response); }));
    }
    ~WithRawCallbackMethod_generateRSAKeyPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateRSAKeyPair(::grpc::ServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* generateRSAKeyPair(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_generateECCKeyPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_generateECCKeyPair() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->generateECCKeyPair(context, request, response); }));
    }
    ~WithRawCallbackMethod_generateECCKeyPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status generateECCKeyPair(::grpc::ServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* generateECCKeyPair(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getSignedDataLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getSignedDataLength() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getSignedDataLength(context, request, response); }));
    }
    ~WithRawCallbackMethod_getSignedDataLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getSignedDataLength(::grpc::ServerContext* /*context*/, const ::crypto::GetHashLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getSignedDataLength(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getECCencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getECCencryptedLength() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getECCencryptedLength(context, request, response); }));
    }
    ~WithRawCallbackMethod_getECCencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getECCencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getECCencryptedLength(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getECCDecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getECCDecryptedLength() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getECCDecryptedLength(context, request, response); }));
    }
    ~WithRawCallbackMethod_getECCDecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getECCDecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getECCDecryptedLength(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getRSAencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getRSAencryptedLength() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getRSAencryptedLength(context, request, response); }));
    }
    ~WithRawCallbackMethod_getRSAencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRSAencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRSAencryptedLength(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getRSAdecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getRSAdecryptedLength() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getRSAdecryptedLength(context, request, response); }));
    }
    ~WithRawCallbackMethod_getRSAdecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getRSAdecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getRSAdecryptedLength(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getAESencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getAESencryptedLength() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getAESencryptedLength(context, request, response); }));
    }
    ~WithRawCallbackMethod_getAESencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAESencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getAESencryptedLength(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getAESdecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getAESdecryptedLength() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getAESdecryptedLength(context, request, response); }));
    }
    ~WithRawCallbackMethod_getAESdecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getAESdecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getAESdecryptedLength(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getEncryptedLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getEncryptedLen() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getEncryptedLen(context, request, response); }));
    }
    ~WithRawCallbackMethod_getEncryptedLen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getEncryptedLen(::grpc::ServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getEncryptedLen(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getDecryptedLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getDecryptedLen() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getDecryptedLen(context, request, response); }));
    }
    ~WithRawCallbackMethod_getDecryptedLen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getDecryptedLen(::grpc::ServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getDecryptedLen(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_sign : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_sign() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->sign(context, request, response); }));
    }
    ~WithRawCallbackMethod_sign() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status sign(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* sign(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_verify : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_verify() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->verify(context, request, response); }));
    }
    ~WithRawCallbackMethod_verify() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verify(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* verify(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getPublicECCKeyByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getPublicECCKeyByUserId() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getPublicECCKeyByUserId(context, request, response); }));
    }
    ~WithRawCallbackMethod_getPublicECCKeyByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPublicECCKeyByUserId(::grpc::ServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getPublicECCKeyByUserId(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_getPublicRSAKeyByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_getPublicRSAKeyByUserId() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->getPublicRSAKeyByUserId(context, request, response); }));
    }
    ~WithRawCallbackMethod_getPublicRSAKeyByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status getPublicRSAKeyByUserId(::grpc::ServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* getPublicRSAKeyByUserId(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ECCencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ECCencrypt() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ECCencrypt(context, request, response); }));
    }
    ~WithRawCallbackMethod_ECCencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ECCencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ECCencrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ECCdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ECCdecrypt() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ECCdecrypt(context, request, response); }));
    }
    ~WithRawCallbackMethod_ECCdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ECCdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ECCdecrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RSAencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RSAencrypt() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RSAencrypt(context, request, response); }));
    }
    ~WithRawCallbackMethod_RSAencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RSAencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RSAencrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RSAdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RSAdecrypt() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RSAdecrypt(context, request, response); }));
    }
    ~WithRawCallbackMethod_RSAdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RSAdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RSAdecrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AESencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AESencrypt() {
      ::grpc::Service::MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AESencrypt(context, request, response); }));
    }
    ~WithRawCallbackMethod_AESencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AESencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AESEncryptRequest* /*request*/, ::crypto::AESEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AESencrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AESdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AESdecrypt() {
      ::grpc::Service::MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AESdecrypt(context, request, response); }));
    }
    ~WithRawCallbackMethod_AESdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AESdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AESDecryptRequest* /*request*/, ::crypto::AESDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AESdecrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_encrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_encrypt() {
      ::grpc::Service::MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->encrypt(context, request, response); }));
    }
    ~WithRawCallbackMethod_encrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status encrypt(::grpc::ServerContext* /*context*/, const ::crypto::EncryptRequest* /*request*/, ::crypto::EncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* encrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_decrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_decrypt() {
      ::grpc::Service::MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->decrypt(context, request, response); }));
    }
    ~WithRawCallbackMethod_decrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status decrypt(::grpc::ServerContext* /*context*/, const ::crypto::DecryptRequest* /*request*/, ::crypto::DecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* decrypt(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_signUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_signUpdate() {
      ::grpc::Service::MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->signUpdate(context, request, response); }));
    }
    ~WithRawCallbackMethod_signUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status signUpdate(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* signUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_signFinalize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_signFinalize() {
      ::grpc::Service::MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->signFinalize(context, request, response); }));
    }
    ~WithRawCallbackMethod_signFinalize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status signFinalize(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* signFinalize(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_verifyUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_verifyUpdate() {
      ::grpc::Service::MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->verifyUpdate(context, request, response); }));
    }
    ~WithRawCallbackMethod_verifyUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verifyUpdate(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* verifyUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_verifyFinalize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_verifyFinalize() {
      ::grpc::Service::MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->verifyFinalize(context, request, response); }));
    }
    ~WithRawCallbackMethod_verifyFinalize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status verifyFinalize(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* verifyFinalize(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_bootSystem : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_bootSystem() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::BootSystemRequest, ::crypto::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::BootSystemRequest, ::crypto::Empty>* streamer) {
                       return this->StreamedbootSystem(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_bootSystem() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status bootSystem(::grpc::ServerContext* /*context*/, const ::crypto::BootSystemRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedbootSystem(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::BootSystemRequest,::crypto::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_addProccess : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_addProccess() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::AddProcessRequest, ::crypto::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::AddProcessRequest, ::crypto::Empty>* streamer) {
                       return this->StreamedaddProccess(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_addProccess() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status addProccess(::grpc::ServerContext* /*context*/, const ::crypto::AddProcessRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedaddProccess(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::AddProcessRequest,::crypto::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_configure : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_configure() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::ConfigureRequest, ::crypto::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::ConfigureRequest, ::crypto::Empty>* streamer) {
                       return this->Streamedconfigure(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_configure() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status configure(::grpc::ServerContext* /*context*/, const ::crypto::ConfigureRequest* /*request*/, ::crypto::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedconfigure(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::ConfigureRequest,::crypto::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_generateAESKey : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_generateAESKey() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::GenerateAESKeyRequest, ::crypto::GenerateAESKeyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::GenerateAESKeyRequest, ::crypto::GenerateAESKeyResponse>* streamer) {
                       return this->StreamedgenerateAESKey(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_generateAESKey() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status generateAESKey(::grpc::ServerContext* /*context*/, const ::crypto::GenerateAESKeyRequest* /*request*/, ::crypto::GenerateAESKeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgenerateAESKey(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::GenerateAESKeyRequest,::crypto::GenerateAESKeyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_generateRSAKeyPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_generateRSAKeyPair() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse>* streamer) {
                       return this->StreamedgenerateRSAKeyPair(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_generateRSAKeyPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status generateRSAKeyPair(::grpc::ServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgenerateRSAKeyPair(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::GenerateKeyPairRequest,::crypto::GenerateKeyPairResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_generateECCKeyPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_generateECCKeyPair() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::GenerateKeyPairRequest, ::crypto::GenerateKeyPairResponse>* streamer) {
                       return this->StreamedgenerateECCKeyPair(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_generateECCKeyPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status generateECCKeyPair(::grpc::ServerContext* /*context*/, const ::crypto::GenerateKeyPairRequest* /*request*/, ::crypto::GenerateKeyPairResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgenerateECCKeyPair(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::GenerateKeyPairRequest,::crypto::GenerateKeyPairResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getSignedDataLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getSignedDataLength() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::GetHashLengthRequest, ::crypto::GetLengthResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::GetHashLengthRequest, ::crypto::GetLengthResponse>* streamer) {
                       return this->StreamedgetSignedDataLength(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getSignedDataLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getSignedDataLength(::grpc::ServerContext* /*context*/, const ::crypto::GetHashLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetSignedDataLength(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::GetHashLengthRequest,::crypto::GetLengthResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getECCencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getECCencryptedLength() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>* streamer) {
                       return this->StreamedgetECCencryptedLength(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getECCencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getECCencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetECCencryptedLength(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::GetLengthRequest,::crypto::GetLengthResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getECCDecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getECCDecryptedLength() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>* streamer) {
                       return this->StreamedgetECCDecryptedLength(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getECCDecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getECCDecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetECCDecryptedLength(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::GetLengthRequest,::crypto::GetLengthResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getRSAencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getRSAencryptedLength() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>* streamer) {
                       return this->StreamedgetRSAencryptedLength(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getRSAencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getRSAencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetRSAencryptedLength(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::GetLengthRequest,::crypto::GetLengthResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getRSAdecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getRSAdecryptedLength() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::GetLengthRequest, ::crypto::GetLengthResponse>* streamer) {
                       return this->StreamedgetRSAdecryptedLength(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getRSAdecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getRSAdecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetRSAdecryptedLength(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::GetLengthRequest,::crypto::GetLengthResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getAESencryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getAESencryptedLength() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse>* streamer) {
                       return this->StreamedgetAESencryptedLength(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getAESencryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getAESencryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetAESencryptedLength(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::GetAESLengthRequest,::crypto::GetLengthResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getAESdecryptedLength : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getAESdecryptedLength() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::GetAESLengthRequest, ::crypto::GetLengthResponse>* streamer) {
                       return this->StreamedgetAESdecryptedLength(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getAESdecryptedLength() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getAESdecryptedLength(::grpc::ServerContext* /*context*/, const ::crypto::GetAESLengthRequest* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetAESdecryptedLength(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::GetAESLengthRequest,::crypto::GetLengthResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getEncryptedLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getEncryptedLen() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::GetWholeLength, ::crypto::GetLengthResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::GetWholeLength, ::crypto::GetLengthResponse>* streamer) {
                       return this->StreamedgetEncryptedLen(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getEncryptedLen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getEncryptedLen(::grpc::ServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetEncryptedLen(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::GetWholeLength,::crypto::GetLengthResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getDecryptedLen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getDecryptedLen() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::GetWholeLength, ::crypto::GetLengthResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::GetWholeLength, ::crypto::GetLengthResponse>* streamer) {
                       return this->StreamedgetDecryptedLen(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getDecryptedLen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getDecryptedLen(::grpc::ServerContext* /*context*/, const ::crypto::GetWholeLength* /*request*/, ::crypto::GetLengthResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetDecryptedLen(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::GetWholeLength,::crypto::GetLengthResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_sign : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_sign() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::SignRequest, ::crypto::SignResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::SignRequest, ::crypto::SignResponse>* streamer) {
                       return this->Streamedsign(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_sign() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status sign(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedsign(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::SignRequest,::crypto::SignResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_verify : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_verify() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::VerifyRequest, ::crypto::VerifyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::VerifyRequest, ::crypto::VerifyResponse>* streamer) {
                       return this->Streamedverify(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_verify() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status verify(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedverify(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::VerifyRequest,::crypto::VerifyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getPublicECCKeyByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getPublicECCKeyByUserId() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::KeyRequest, ::crypto::KeyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::KeyRequest, ::crypto::KeyResponse>* streamer) {
                       return this->StreamedgetPublicECCKeyByUserId(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getPublicECCKeyByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getPublicECCKeyByUserId(::grpc::ServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetPublicECCKeyByUserId(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::KeyRequest,::crypto::KeyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_getPublicRSAKeyByUserId : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_getPublicRSAKeyByUserId() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::KeyRequest, ::crypto::KeyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::KeyRequest, ::crypto::KeyResponse>* streamer) {
                       return this->StreamedgetPublicRSAKeyByUserId(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_getPublicRSAKeyByUserId() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status getPublicRSAKeyByUserId(::grpc::ServerContext* /*context*/, const ::crypto::KeyRequest* /*request*/, ::crypto::KeyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedgetPublicRSAKeyByUserId(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::KeyRequest,::crypto::KeyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ECCencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ECCencrypt() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse>* streamer) {
                       return this->StreamedECCencrypt(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ECCencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ECCencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedECCencrypt(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::AsymetricEncryptRequest,::crypto::AsymetricEncryptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ECCdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ECCdecrypt() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse>* streamer) {
                       return this->StreamedECCdecrypt(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ECCdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ECCdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedECCdecrypt(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::AsymetricDecryptRequest,::crypto::AsymetricDecryptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RSAencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RSAencrypt() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::AsymetricEncryptRequest, ::crypto::AsymetricEncryptResponse>* streamer) {
                       return this->StreamedRSAencrypt(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RSAencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RSAencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricEncryptRequest* /*request*/, ::crypto::AsymetricEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRSAencrypt(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::AsymetricEncryptRequest,::crypto::AsymetricEncryptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RSAdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RSAdecrypt() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::AsymetricDecryptRequest, ::crypto::AsymetricDecryptResponse>* streamer) {
                       return this->StreamedRSAdecrypt(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RSAdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RSAdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AsymetricDecryptRequest* /*request*/, ::crypto::AsymetricDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRSAdecrypt(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::AsymetricDecryptRequest,::crypto::AsymetricDecryptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AESencrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AESencrypt() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::AESEncryptRequest, ::crypto::AESEncryptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::AESEncryptRequest, ::crypto::AESEncryptResponse>* streamer) {
                       return this->StreamedAESencrypt(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AESencrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AESencrypt(::grpc::ServerContext* /*context*/, const ::crypto::AESEncryptRequest* /*request*/, ::crypto::AESEncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAESencrypt(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::AESEncryptRequest,::crypto::AESEncryptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AESdecrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AESdecrypt() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::AESDecryptRequest, ::crypto::AESDecryptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::AESDecryptRequest, ::crypto::AESDecryptResponse>* streamer) {
                       return this->StreamedAESdecrypt(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AESdecrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AESdecrypt(::grpc::ServerContext* /*context*/, const ::crypto::AESDecryptRequest* /*request*/, ::crypto::AESDecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAESdecrypt(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::AESDecryptRequest,::crypto::AESDecryptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_encrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_encrypt() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::EncryptRequest, ::crypto::EncryptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::EncryptRequest, ::crypto::EncryptResponse>* streamer) {
                       return this->Streamedencrypt(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_encrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status encrypt(::grpc::ServerContext* /*context*/, const ::crypto::EncryptRequest* /*request*/, ::crypto::EncryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streamedencrypt(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::EncryptRequest,::crypto::EncryptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_decrypt : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_decrypt() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::DecryptRequest, ::crypto::DecryptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::DecryptRequest, ::crypto::DecryptResponse>* streamer) {
                       return this->Streameddecrypt(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_decrypt() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status decrypt(::grpc::ServerContext* /*context*/, const ::crypto::DecryptRequest* /*request*/, ::crypto::DecryptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status Streameddecrypt(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::DecryptRequest,::crypto::DecryptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_signUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_signUpdate() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::SignRequest, ::crypto::SignResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::SignRequest, ::crypto::SignResponse>* streamer) {
                       return this->StreamedsignUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_signUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status signUpdate(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsignUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::SignRequest,::crypto::SignResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_signFinalize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_signFinalize() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::SignRequest, ::crypto::SignResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::SignRequest, ::crypto::SignResponse>* streamer) {
                       return this->StreamedsignFinalize(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_signFinalize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status signFinalize(::grpc::ServerContext* /*context*/, const ::crypto::SignRequest* /*request*/, ::crypto::SignResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedsignFinalize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::SignRequest,::crypto::SignResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_verifyUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_verifyUpdate() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::VerifyRequest, ::crypto::VerifyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::VerifyRequest, ::crypto::VerifyResponse>* streamer) {
                       return this->StreamedverifyUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_verifyUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status verifyUpdate(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedverifyUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::VerifyRequest,::crypto::VerifyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_verifyFinalize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_verifyFinalize() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::crypto::VerifyRequest, ::crypto::VerifyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::crypto::VerifyRequest, ::crypto::VerifyResponse>* streamer) {
                       return this->StreamedverifyFinalize(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_verifyFinalize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status verifyFinalize(::grpc::ServerContext* /*context*/, const ::crypto::VerifyRequest* /*request*/, ::crypto::VerifyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedverifyFinalize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::crypto::VerifyRequest,::crypto::VerifyResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_bootSystem<WithStreamedUnaryMethod_addProccess<WithStreamedUnaryMethod_configure<WithStreamedUnaryMethod_generateAESKey<WithStreamedUnaryMethod_generateRSAKeyPair<WithStreamedUnaryMethod_generateECCKeyPair<WithStreamedUnaryMethod_getSignedDataLength<WithStreamedUnaryMethod_getECCencryptedLength<WithStreamedUnaryMethod_getECCDecryptedLength<WithStreamedUnaryMethod_getRSAencryptedLength<WithStreamedUnaryMethod_getRSAdecryptedLength<WithStreamedUnaryMethod_getAESencryptedLength<WithStreamedUnaryMethod_getAESdecryptedLength<WithStreamedUnaryMethod_getEncryptedLen<WithStreamedUnaryMethod_getDecryptedLen<WithStreamedUnaryMethod_sign<WithStreamedUnaryMethod_verify<WithStreamedUnaryMethod_getPublicECCKeyByUserId<WithStreamedUnaryMethod_getPublicRSAKeyByUserId<WithStreamedUnaryMethod_ECCencrypt<WithStreamedUnaryMethod_ECCdecrypt<WithStreamedUnaryMethod_RSAencrypt<WithStreamedUnaryMethod_RSAdecrypt<WithStreamedUnaryMethod_AESencrypt<WithStreamedUnaryMethod_AESdecrypt<WithStreamedUnaryMethod_encrypt<WithStreamedUnaryMethod_decrypt<WithStreamedUnaryMethod_signUpdate<WithStreamedUnaryMethod_signFinalize<WithStreamedUnaryMethod_verifyUpdate<WithStreamedUnaryMethod_verifyFinalize<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_bootSystem<WithStreamedUnaryMethod_addProccess<WithStreamedUnaryMethod_configure<WithStreamedUnaryMethod_generateAESKey<WithStreamedUnaryMethod_generateRSAKeyPair<WithStreamedUnaryMethod_generateECCKeyPair<WithStreamedUnaryMethod_getSignedDataLength<WithStreamedUnaryMethod_getECCencryptedLength<WithStreamedUnaryMethod_getECCDecryptedLength<WithStreamedUnaryMethod_getRSAencryptedLength<WithStreamedUnaryMethod_getRSAdecryptedLength<WithStreamedUnaryMethod_getAESencryptedLength<WithStreamedUnaryMethod_getAESdecryptedLength<WithStreamedUnaryMethod_getEncryptedLen<WithStreamedUnaryMethod_getDecryptedLen<WithStreamedUnaryMethod_sign<WithStreamedUnaryMethod_verify<WithStreamedUnaryMethod_getPublicECCKeyByUserId<WithStreamedUnaryMethod_getPublicRSAKeyByUserId<WithStreamedUnaryMethod_ECCencrypt<WithStreamedUnaryMethod_ECCdecrypt<WithStreamedUnaryMethod_RSAencrypt<WithStreamedUnaryMethod_RSAdecrypt<WithStreamedUnaryMethod_AESencrypt<WithStreamedUnaryMethod_AESdecrypt<WithStreamedUnaryMethod_encrypt<WithStreamedUnaryMethod_decrypt<WithStreamedUnaryMethod_signUpdate<WithStreamedUnaryMethod_signFinalize<WithStreamedUnaryMethod_verifyUpdate<WithStreamedUnaryMethod_verifyFinalize<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace crypto


#endif  // GRPC_encryption_2eproto__INCLUDED
