// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/encryption.proto

#include "encryption.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace crypto {
constexpr AsymetricEncryptRequest::AsymetricEncryptRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : keyid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0){}
struct AsymetricEncryptRequestDefaultTypeInternal {
  constexpr AsymetricEncryptRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AsymetricEncryptRequestDefaultTypeInternal() {}
  union {
    AsymetricEncryptRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AsymetricEncryptRequestDefaultTypeInternal _AsymetricEncryptRequest_default_instance_;
constexpr AsymetricEncryptResponse::AsymetricEncryptResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : encrypteddata_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AsymetricEncryptResponseDefaultTypeInternal {
  constexpr AsymetricEncryptResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AsymetricEncryptResponseDefaultTypeInternal() {}
  union {
    AsymetricEncryptResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AsymetricEncryptResponseDefaultTypeInternal _AsymetricEncryptResponse_default_instance_;
constexpr AsymetricDecryptRequest::AsymetricDecryptRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : keyid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0)
  , receiverid_(0){}
struct AsymetricDecryptRequestDefaultTypeInternal {
  constexpr AsymetricDecryptRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AsymetricDecryptRequestDefaultTypeInternal() {}
  union {
    AsymetricDecryptRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AsymetricDecryptRequestDefaultTypeInternal _AsymetricDecryptRequest_default_instance_;
constexpr GetHashLengthRequest::GetHashLengthRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0)
  , func_(0)

  , datalen_(0){}
struct GetHashLengthRequestDefaultTypeInternal {
  constexpr GetHashLengthRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetHashLengthRequestDefaultTypeInternal() {}
  union {
    GetHashLengthRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetHashLengthRequestDefaultTypeInternal _GetHashLengthRequest_default_instance_;
constexpr GetAESLengthRequest::GetAESLengthRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0)
  , datalen_(0)
  , isfirst_(false)
  , chainingmode_(0)
{}
struct GetAESLengthRequestDefaultTypeInternal {
  constexpr GetAESLengthRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetAESLengthRequestDefaultTypeInternal() {}
  union {
    GetAESLengthRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetAESLengthRequestDefaultTypeInternal _GetAESLengthRequest_default_instance_;
constexpr AsymetricDecryptResponse::AsymetricDecryptResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : decrypteddata_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , decryptedlength_(0){}
struct AsymetricDecryptResponseDefaultTypeInternal {
  constexpr AsymetricDecryptResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AsymetricDecryptResponseDefaultTypeInternal() {}
  union {
    AsymetricDecryptResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AsymetricDecryptResponseDefaultTypeInternal _AsymetricDecryptResponse_default_instance_;
constexpr GetLengthRequest::GetLengthRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0)
  , inlen_(0){}
struct GetLengthRequestDefaultTypeInternal {
  constexpr GetLengthRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetLengthRequestDefaultTypeInternal() {}
  union {
    GetLengthRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetLengthRequestDefaultTypeInternal _GetLengthRequest_default_instance_;
constexpr GetLengthResponse::GetLengthResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : length_(0){}
struct GetLengthResponseDefaultTypeInternal {
  constexpr GetLengthResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetLengthResponseDefaultTypeInternal() {}
  union {
    GetLengthResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetLengthResponseDefaultTypeInternal _GetLengthResponse_default_instance_;
constexpr GetWholeLength::GetWholeLength(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0)
  , inlen_(0)
  , isfirst_(false)
  , userid_(0){}
struct GetWholeLengthDefaultTypeInternal {
  constexpr GetWholeLengthDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GetWholeLengthDefaultTypeInternal() {}
  union {
    GetWholeLength _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GetWholeLengthDefaultTypeInternal _GetWholeLength_default_instance_;
constexpr GenerateAESKeyRequest::GenerateAESKeyRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : permissions_()
  , _permissions_cached_byte_size_(0)
  , messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , userid_(0)
  , keylength_(0)

  , destuserid_(0){}
struct GenerateAESKeyRequestDefaultTypeInternal {
  constexpr GenerateAESKeyRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GenerateAESKeyRequestDefaultTypeInternal() {}
  union {
    GenerateAESKeyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GenerateAESKeyRequestDefaultTypeInternal _GenerateAESKeyRequest_default_instance_;
constexpr GenerateAESKeyResponse::GenerateAESKeyResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : aeskey_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct GenerateAESKeyResponseDefaultTypeInternal {
  constexpr GenerateAESKeyResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GenerateAESKeyResponseDefaultTypeInternal() {}
  union {
    GenerateAESKeyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GenerateAESKeyResponseDefaultTypeInternal _GenerateAESKeyResponse_default_instance_;
constexpr GenerateKeyPairRequest::GenerateKeyPairRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : permissions_()
  , _permissions_cached_byte_size_(0)
  , messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , userid_(0){}
struct GenerateKeyPairRequestDefaultTypeInternal {
  constexpr GenerateKeyPairRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GenerateKeyPairRequestDefaultTypeInternal() {}
  union {
    GenerateKeyPairRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GenerateKeyPairRequestDefaultTypeInternal _GenerateKeyPairRequest_default_instance_;
constexpr GenerateKeyPairResponse::GenerateKeyPairResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : publickey_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , privatekey_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct GenerateKeyPairResponseDefaultTypeInternal {
  constexpr GenerateKeyPairResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GenerateKeyPairResponseDefaultTypeInternal() {}
  union {
    GenerateKeyPairResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GenerateKeyPairResponseDefaultTypeInternal _GenerateKeyPairResponse_default_instance_;
constexpr SignRequest::SignRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , keyid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0)
  , hashfunc_(0)

  , counter_(int64_t{0}){}
struct SignRequestDefaultTypeInternal {
  constexpr SignRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SignRequestDefaultTypeInternal() {}
  union {
    SignRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SignRequestDefaultTypeInternal _SignRequest_default_instance_;
constexpr SignResponse::SignResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct SignResponseDefaultTypeInternal {
  constexpr SignResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SignResponseDefaultTypeInternal() {}
  union {
    SignResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SignResponseDefaultTypeInternal _SignResponse_default_instance_;
constexpr VerifyRequest::VerifyRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , keyid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0)
  , receiverid_(0)
  , hashfunc_(0)

  , counter_(0){}
struct VerifyRequestDefaultTypeInternal {
  constexpr VerifyRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VerifyRequestDefaultTypeInternal() {}
  union {
    VerifyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VerifyRequestDefaultTypeInternal _VerifyRequest_default_instance_;
constexpr VerifyResponse::VerifyResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : out_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , valid_(false){}
struct VerifyResponseDefaultTypeInternal {
  constexpr VerifyResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~VerifyResponseDefaultTypeInternal() {}
  union {
    VerifyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT VerifyResponseDefaultTypeInternal _VerifyResponse_default_instance_;
constexpr KeyRequest::KeyRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0)
  , userid_(0){}
struct KeyRequestDefaultTypeInternal {
  constexpr KeyRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeyRequestDefaultTypeInternal() {}
  union {
    KeyRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeyRequestDefaultTypeInternal _KeyRequest_default_instance_;
constexpr KeyResponse::KeyResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct KeyResponseDefaultTypeInternal {
  constexpr KeyResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~KeyResponseDefaultTypeInternal() {}
  union {
    KeyResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT KeyResponseDefaultTypeInternal _KeyResponse_default_instance_;
constexpr UserKeyPermissions::UserKeyPermissions(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : permissions_()
  , _permissions_cached_byte_size_(0)
  , userid_(0){}
struct UserKeyPermissionsDefaultTypeInternal {
  constexpr UserKeyPermissionsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UserKeyPermissionsDefaultTypeInternal() {}
  union {
    UserKeyPermissions _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UserKeyPermissionsDefaultTypeInternal _UserKeyPermissions_default_instance_;
constexpr BootSystemRequest::BootSystemRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : usersidspermissions_()
  , messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct BootSystemRequestDefaultTypeInternal {
  constexpr BootSystemRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~BootSystemRequestDefaultTypeInternal() {}
  union {
    BootSystemRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT BootSystemRequestDefaultTypeInternal _BootSystemRequest_default_instance_;
constexpr Empty::Empty(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct EmptyDefaultTypeInternal {
  constexpr EmptyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EmptyDefaultTypeInternal() {}
  union {
    Empty _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EmptyDefaultTypeInternal _Empty_default_instance_;
constexpr CryptoConfig::CryptoConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , hashfunction_(0)

  , aeskeylength_(0)

  , aeschainingmode_(0)

  , asymmetricfunction_(0)
{}
struct CryptoConfigDefaultTypeInternal {
  constexpr CryptoConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CryptoConfigDefaultTypeInternal() {}
  union {
    CryptoConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CryptoConfigDefaultTypeInternal _CryptoConfig_default_instance_;
constexpr ConfigureRequest::ConfigureRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , config_(nullptr)
  , userid_(0){}
struct ConfigureRequestDefaultTypeInternal {
  constexpr ConfigureRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ConfigureRequestDefaultTypeInternal() {}
  union {
    ConfigureRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ConfigureRequestDefaultTypeInternal _ConfigureRequest_default_instance_;
constexpr AddProcessRequest::AddProcessRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : permissions_()
  , _permissions_cached_byte_size_(0)
  , messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , userid_(0){}
struct AddProcessRequestDefaultTypeInternal {
  constexpr AddProcessRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AddProcessRequestDefaultTypeInternal() {}
  union {
    AddProcessRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AddProcessRequestDefaultTypeInternal _AddProcessRequest_default_instance_;
constexpr EncryptRequest::EncryptRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0)
  , receiverid_(0)
  , counter_(int64_t{0})
  , isfirst_(false){}
struct EncryptRequestDefaultTypeInternal {
  constexpr EncryptRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EncryptRequestDefaultTypeInternal() {}
  union {
    EncryptRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EncryptRequestDefaultTypeInternal _EncryptRequest_default_instance_;
constexpr EncryptResponse::EncryptResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : encrypteddata_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct EncryptResponseDefaultTypeInternal {
  constexpr EncryptResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EncryptResponseDefaultTypeInternal() {}
  union {
    EncryptResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EncryptResponseDefaultTypeInternal _EncryptResponse_default_instance_;
constexpr DecryptRequest::DecryptRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : encrypteddata_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0)
  , receiverid_(0)
  , counter_(int64_t{0})
  , isfirst_(false){}
struct DecryptRequestDefaultTypeInternal {
  constexpr DecryptRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DecryptRequestDefaultTypeInternal() {}
  union {
    DecryptRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DecryptRequestDefaultTypeInternal _DecryptRequest_default_instance_;
constexpr DecryptResponse::DecryptResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : decrypteddata_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , decryptedlength_(0){}
struct DecryptResponseDefaultTypeInternal {
  constexpr DecryptResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DecryptResponseDefaultTypeInternal() {}
  union {
    DecryptResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DecryptResponseDefaultTypeInternal _DecryptResponse_default_instance_;
constexpr AESEncryptRequest::AESEncryptRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , keyid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0)
  , receiverid_(0)
  , counter_(int64_t{0})
  , func_(0)

  , keylength_(0)

  , chainingmode_(0)

  , isfirst_(false){}
struct AESEncryptRequestDefaultTypeInternal {
  constexpr AESEncryptRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AESEncryptRequestDefaultTypeInternal() {}
  union {
    AESEncryptRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AESEncryptRequestDefaultTypeInternal _AESEncryptRequest_default_instance_;
constexpr AESEncryptResponse::AESEncryptResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : encrypteddata_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct AESEncryptResponseDefaultTypeInternal {
  constexpr AESEncryptResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AESEncryptResponseDefaultTypeInternal() {}
  union {
    AESEncryptResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AESEncryptResponseDefaultTypeInternal _AESEncryptResponse_default_instance_;
constexpr AESDecryptRequest::AESDecryptRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : datain_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , dataout_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , keyid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , messageid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , senderid_(0)
  , receiverid_(0)
  , inlen_(0)
  , func_(0)

  , keylength_(0)

  , chainingmode_(0)

  , counter_(int64_t{0})
  , isfirst_(false)
  , userid_(0){}
struct AESDecryptRequestDefaultTypeInternal {
  constexpr AESDecryptRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AESDecryptRequestDefaultTypeInternal() {}
  union {
    AESDecryptRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AESDecryptRequestDefaultTypeInternal _AESDecryptRequest_default_instance_;
constexpr AESDecryptResponse::AESDecryptResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : decrypteddata_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , decryptedlength_(0){}
struct AESDecryptResponseDefaultTypeInternal {
  constexpr AESDecryptResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AESDecryptResponseDefaultTypeInternal() {}
  union {
    AESDecryptResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AESDecryptResponseDefaultTypeInternal _AESDecryptResponse_default_instance_;
}  // namespace crypto
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_proto_2fencryption_2eproto[33];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_proto_2fencryption_2eproto[5];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_proto_2fencryption_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_proto_2fencryption_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricEncryptRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricEncryptRequest, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricEncryptRequest, keyid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricEncryptRequest, data_),
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricEncryptRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricEncryptResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricEncryptResponse, encrypteddata_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptRequest, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptRequest, receiverid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptRequest, keyid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptRequest, data_),
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GetHashLengthRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GetHashLengthRequest, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetHashLengthRequest, func_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetHashLengthRequest, datalen_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetHashLengthRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GetAESLengthRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GetAESLengthRequest, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetAESLengthRequest, datalen_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetAESLengthRequest, isfirst_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetAESLengthRequest, chainingmode_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetAESLengthRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptResponse, decrypteddata_),
  PROTOBUF_FIELD_OFFSET(::crypto::AsymetricDecryptResponse, decryptedlength_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GetLengthRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GetLengthRequest, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetLengthRequest, inlen_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetLengthRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GetLengthResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GetLengthResponse, length_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GetWholeLength, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GetWholeLength, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetWholeLength, inlen_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetWholeLength, isfirst_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetWholeLength, messageid_),
  PROTOBUF_FIELD_OFFSET(::crypto::GetWholeLength, userid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyRequest, userid_),
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyRequest, permissions_),
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyRequest, keylength_),
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyRequest, destuserid_),
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateAESKeyResponse, aeskey_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateKeyPairRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateKeyPairRequest, userid_),
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateKeyPairRequest, permissions_),
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateKeyPairRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateKeyPairResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateKeyPairResponse, publickey_),
  PROTOBUF_FIELD_OFFSET(::crypto::GenerateKeyPairResponse, privatekey_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::SignRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::SignRequest, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::SignRequest, data_),
  PROTOBUF_FIELD_OFFSET(::crypto::SignRequest, hashfunc_),
  PROTOBUF_FIELD_OFFSET(::crypto::SignRequest, counter_),
  PROTOBUF_FIELD_OFFSET(::crypto::SignRequest, keyid_),
  PROTOBUF_FIELD_OFFSET(::crypto::SignRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::SignResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::SignResponse, signature_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, receiverid_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, data_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, signature_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, hashfunc_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, keyid_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, counter_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyResponse, valid_),
  PROTOBUF_FIELD_OFFSET(::crypto::VerifyResponse, out_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::KeyRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::KeyRequest, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::KeyRequest, userid_),
  PROTOBUF_FIELD_OFFSET(::crypto::KeyRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::KeyResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::KeyResponse, key_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::UserKeyPermissions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::UserKeyPermissions, userid_),
  PROTOBUF_FIELD_OFFSET(::crypto::UserKeyPermissions, permissions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::BootSystemRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::BootSystemRequest, usersidspermissions_),
  PROTOBUF_FIELD_OFFSET(::crypto::BootSystemRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::Empty, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::CryptoConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::CryptoConfig, hashfunction_),
  PROTOBUF_FIELD_OFFSET(::crypto::CryptoConfig, aeskeylength_),
  PROTOBUF_FIELD_OFFSET(::crypto::CryptoConfig, aeschainingmode_),
  PROTOBUF_FIELD_OFFSET(::crypto::CryptoConfig, asymmetricfunction_),
  PROTOBUF_FIELD_OFFSET(::crypto::CryptoConfig, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::ConfigureRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::ConfigureRequest, userid_),
  PROTOBUF_FIELD_OFFSET(::crypto::ConfigureRequest, config_),
  PROTOBUF_FIELD_OFFSET(::crypto::ConfigureRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AddProcessRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AddProcessRequest, userid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AddProcessRequest, permissions_),
  PROTOBUF_FIELD_OFFSET(::crypto::AddProcessRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptRequest, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptRequest, receiverid_),
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptRequest, data_),
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptRequest, counter_),
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptRequest, isfirst_),
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptResponse, encrypteddata_),
  PROTOBUF_FIELD_OFFSET(::crypto::EncryptResponse, signature_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, receiverid_),
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, encrypteddata_),
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, counter_),
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, signature_),
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, isfirst_),
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptResponse, decrypteddata_),
  PROTOBUF_FIELD_OFFSET(::crypto::DecryptResponse, decryptedlength_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, receiverid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, data_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, func_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, counter_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, keyid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, keylength_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, chainingmode_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, isfirst_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptRequest, messageid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AESEncryptResponse, encrypteddata_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, senderid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, receiverid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, datain_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, inlen_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, dataout_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, func_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, keylength_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, chainingmode_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, counter_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, keyid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, isfirst_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, messageid_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptRequest, userid_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptResponse, decrypteddata_),
  PROTOBUF_FIELD_OFFSET(::crypto::AESDecryptResponse, decryptedlength_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::crypto::AsymetricEncryptRequest)},
  { 10, -1, -1, sizeof(::crypto::AsymetricEncryptResponse)},
  { 17, -1, -1, sizeof(::crypto::AsymetricDecryptRequest)},
  { 28, -1, -1, sizeof(::crypto::GetHashLengthRequest)},
  { 38, -1, -1, sizeof(::crypto::GetAESLengthRequest)},
  { 49, -1, -1, sizeof(::crypto::AsymetricDecryptResponse)},
  { 57, -1, -1, sizeof(::crypto::GetLengthRequest)},
  { 66, -1, -1, sizeof(::crypto::GetLengthResponse)},
  { 73, -1, -1, sizeof(::crypto::GetWholeLength)},
  { 84, -1, -1, sizeof(::crypto::GenerateAESKeyRequest)},
  { 95, -1, -1, sizeof(::crypto::GenerateAESKeyResponse)},
  { 102, -1, -1, sizeof(::crypto::GenerateKeyPairRequest)},
  { 111, -1, -1, sizeof(::crypto::GenerateKeyPairResponse)},
  { 119, -1, -1, sizeof(::crypto::SignRequest)},
  { 131, -1, -1, sizeof(::crypto::SignResponse)},
  { 138, -1, -1, sizeof(::crypto::VerifyRequest)},
  { 152, -1, -1, sizeof(::crypto::VerifyResponse)},
  { 160, -1, -1, sizeof(::crypto::KeyRequest)},
  { 169, -1, -1, sizeof(::crypto::KeyResponse)},
  { 176, -1, -1, sizeof(::crypto::UserKeyPermissions)},
  { 184, -1, -1, sizeof(::crypto::BootSystemRequest)},
  { 192, -1, -1, sizeof(::crypto::Empty)},
  { 198, -1, -1, sizeof(::crypto::CryptoConfig)},
  { 209, -1, -1, sizeof(::crypto::ConfigureRequest)},
  { 218, -1, -1, sizeof(::crypto::AddProcessRequest)},
  { 227, -1, -1, sizeof(::crypto::EncryptRequest)},
  { 239, -1, -1, sizeof(::crypto::EncryptResponse)},
  { 247, -1, -1, sizeof(::crypto::DecryptRequest)},
  { 260, -1, -1, sizeof(::crypto::DecryptResponse)},
  { 268, -1, -1, sizeof(::crypto::AESEncryptRequest)},
  { 284, -1, -1, sizeof(::crypto::AESEncryptResponse)},
  { 291, -1, -1, sizeof(::crypto::AESDecryptRequest)},
  { 310, -1, -1, sizeof(::crypto::AESDecryptResponse)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AsymetricEncryptRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AsymetricEncryptResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AsymetricDecryptRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GetHashLengthRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GetAESLengthRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AsymetricDecryptResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GetLengthRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GetLengthResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GetWholeLength_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GenerateAESKeyRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GenerateAESKeyResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GenerateKeyPairRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_GenerateKeyPairResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_SignRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_SignResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_VerifyRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_VerifyResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_KeyRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_KeyResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_UserKeyPermissions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_BootSystemRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_Empty_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_CryptoConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_ConfigureRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AddProcessRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_EncryptRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_EncryptResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_DecryptRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_DecryptResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AESEncryptRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AESEncryptResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AESDecryptRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::crypto::_AESDecryptResponse_default_instance_),
};

const char descriptor_table_protodef_proto_2fencryption_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\026proto/encryption.proto\022\006crypto\"[\n\027Asym"
  "etricEncryptRequest\022\020\n\010senderId\030\001 \001(\005\022\r\n"
  "\005keyId\030\002 \001(\t\022\014\n\004data\030\003 \001(\014\022\021\n\tmessageId\030"
  "\004 \001(\t\"1\n\030AsymetricEncryptResponse\022\025\n\renc"
  "ryptedData\030\001 \001(\014\"o\n\027AsymetricDecryptRequ"
  "est\022\020\n\010senderId\030\001 \001(\005\022\022\n\nreceiverId\030\002 \001("
  "\005\022\r\n\005keyId\030\003 \001(\t\022\014\n\004data\030\004 \001(\014\022\021\n\tmessag"
  "eId\030\005 \001(\t\"p\n\024GetHashLengthRequest\022\020\n\010sen"
  "derId\030\001 \001(\005\022\"\n\004func\030\002 \001(\0162\024.crypto.SHAAl"
  "gorithm\022\017\n\007dataLen\030\003 \001(\005\022\021\n\tmessageId\030\004 "
  "\001(\t\"\213\001\n\023GetAESLengthRequest\022\020\n\010senderId\030"
  "\001 \001(\005\022\017\n\007dataLen\030\002 \001(\005\022\017\n\007isFirst\030\003 \001(\010\022"
  "-\n\014chainingMode\030\004 \001(\0162\027.crypto.AESChaini"
  "ngMode\022\021\n\tmessageId\030\005 \001(\t\"J\n\030AsymetricDe"
  "cryptResponse\022\025\n\rdecryptedData\030\001 \001(\014\022\027\n\017"
  "decryptedLength\030\002 \001(\005\"F\n\020GetLengthReques"
  "t\022\020\n\010senderId\030\001 \001(\005\022\r\n\005inLen\030\002 \001(\005\022\021\n\tme"
  "ssageId\030\003 \001(\t\"#\n\021GetLengthResponse\022\016\n\006le"
  "ngth\030\001 \001(\005\"e\n\016GetWholeLength\022\020\n\010senderId"
  "\030\001 \001(\005\022\r\n\005inLen\030\002 \001(\005\022\017\n\007isFirst\030\003 \001(\010\022\021"
  "\n\tmessageId\030\004 \001(\t\022\016\n\006userId\030\005 \001(\005\"\243\001\n\025Ge"
  "nerateAESKeyRequest\022\016\n\006userId\030\001 \001(\005\022*\n\013p"
  "ermissions\030\002 \003(\0162\025.crypto.KeyPermission\022"
  "\'\n\tkeyLength\030\003 \001(\0162\024.crypto.AESKeyLength"
  "\022\022\n\ndestUserId\030\004 \001(\005\022\021\n\tmessageId\030\005 \001(\t\""
  "(\n\026GenerateAESKeyResponse\022\016\n\006aesKey\030\001 \001("
  "\t\"g\n\026GenerateKeyPairRequest\022\016\n\006userId\030\001 "
  "\001(\005\022*\n\013permissions\030\002 \003(\0162\025.crypto.KeyPer"
  "mission\022\021\n\tmessageId\030\003 \001(\t\"@\n\027GenerateKe"
  "yPairResponse\022\021\n\tpublicKey\030\001 \001(\t\022\022\n\npriv"
  "ateKey\030\002 \001(\t\"\210\001\n\013SignRequest\022\020\n\010senderId"
  "\030\001 \001(\005\022\014\n\004data\030\002 \001(\014\022&\n\010hashFunc\030\003 \001(\0162\024"
  ".crypto.SHAAlgorithm\022\017\n\007counter\030\005 \001(\003\022\r\n"
  "\005keyId\030\006 \001(\t\022\021\n\tmessageId\030\007 \001(\t\"!\n\014SignR"
  "esponse\022\021\n\tsignature\030\001 \001(\014\"\261\001\n\rVerifyReq"
  "uest\022\020\n\010senderId\030\001 \001(\005\022\022\n\nreceiverId\030\002 \001"
  "(\005\022\014\n\004data\030\003 \001(\014\022\021\n\tsignature\030\004 \001(\014\022&\n\010h"
  "ashFunc\030\005 \001(\0162\024.crypto.SHAAlgorithm\022\r\n\005k"
  "eyId\030\006 \001(\t\022\017\n\007counter\030\007 \001(\005\022\021\n\tmessageId"
  "\030\010 \001(\t\",\n\016VerifyResponse\022\r\n\005valid\030\001 \001(\010\022"
  "\013\n\003out\030\002 \001(\014\"A\n\nKeyRequest\022\020\n\010senderId\030\001"
  " \001(\005\022\016\n\006userId\030\002 \001(\005\022\021\n\tmessageId\030\003 \001(\t\""
  "\032\n\013KeyResponse\022\013\n\003key\030\001 \001(\t\"P\n\022UserKeyPe"
  "rmissions\022\016\n\006userId\030\001 \001(\005\022*\n\013permissions"
  "\030\002 \003(\0162\025.crypto.KeyPermission\"_\n\021BootSys"
  "temRequest\0227\n\023usersIdsPermissions\030\001 \003(\0132"
  "\032.crypto.UserKeyPermissions\022\021\n\tmessageId"
  "\030\005 \001(\t\"\007\n\005Empty\"\343\001\n\014CryptoConfig\022*\n\014hash"
  "Function\030\001 \001(\0162\024.crypto.SHAAlgorithm\022*\n\014"
  "aesKeyLength\030\002 \001(\0162\024.crypto.AESKeyLength"
  "\0220\n\017aesChainingMode\030\003 \001(\0162\027.crypto.AESCh"
  "ainingMode\0226\n\022asymmetricFunction\030\004 \001(\0162\032"
  ".crypto.AsymmetricFunction\022\021\n\tmessageId\030"
  "\005 \001(\t\"[\n\020ConfigureRequest\022\016\n\006userId\030\001 \001("
  "\005\022$\n\006config\030\002 \001(\0132\024.crypto.CryptoConfig\022"
  "\021\n\tmessageId\030\003 \001(\t\"b\n\021AddProcessRequest\022"
  "\016\n\006userId\030\001 \001(\005\022*\n\013permissions\030\002 \003(\0162\025.c"
  "rypto.KeyPermission\022\021\n\tmessageId\030\004 \001(\t\"y"
  "\n\016EncryptRequest\022\020\n\010senderId\030\001 \001(\005\022\022\n\nre"
  "ceiverId\030\002 \001(\005\022\014\n\004data\030\003 \001(\014\022\017\n\007counter\030"
  "\004 \001(\003\022\017\n\007isFirst\030\005 \001(\010\022\021\n\tmessageId\030\006 \001("
  "\t\";\n\017EncryptResponse\022\025\n\rencryptedData\030\001 "
  "\001(\014\022\021\n\tsignature\030\002 \001(\014\"\225\001\n\016DecryptReques"
  "t\022\020\n\010senderId\030\001 \001(\005\022\022\n\nreceiverId\030\002 \001(\005\022"
  "\025\n\rencryptedData\030\003 \001(\014\022\017\n\007counter\030\004 \001(\003\022"
  "\021\n\tsignature\030\005 \001(\014\022\017\n\007isFirst\030\006 \001(\010\022\021\n\tm"
  "essageId\030\007 \001(\t\"A\n\017DecryptResponse\022\025\n\rdec"
  "ryptedData\030\001 \001(\014\022\027\n\017decryptedLength\030\002 \001("
  "\005\"\215\002\n\021AESEncryptRequest\022\020\n\010senderId\030\001 \001("
  "\005\022\022\n\nreceiverId\030\002 \001(\005\022\014\n\004data\030\003 \001(\014\022(\n\004f"
  "unc\030\004 \001(\0162\032.crypto.AsymmetricFunction\022\017\n"
  "\007counter\030\005 \001(\003\022\r\n\005keyId\030\006 \001(\t\022\'\n\tkeyLeng"
  "th\030\007 \001(\0162\024.crypto.AESKeyLength\022-\n\014chaini"
  "ngMode\030\010 \001(\0162\027.crypto.AESChainingMode\022\017\n"
  "\007isFirst\030\t \001(\010\022\021\n\tmessageId\030\n \001(\t\"+\n\022AES"
  "EncryptResponse\022\025\n\rencryptedData\030\001 \001(\014\"\277"
  "\002\n\021AESDecryptRequest\022\020\n\010senderId\030\001 \001(\005\022\022"
  "\n\nreceiverId\030\002 \001(\005\022\016\n\006dataIn\030\003 \001(\014\022\r\n\005in"
  "Len\030\004 \001(\005\022\017\n\007dataOut\030\005 \001(\014\022(\n\004func\030\006 \001(\016"
  "2\032.crypto.AsymmetricFunction\022\'\n\tkeyLengt"
  "h\030\007 \001(\0162\024.crypto.AESKeyLength\022-\n\014chainin"
  "gMode\030\010 \001(\0162\027.crypto.AESChainingMode\022\017\n\007"
  "counter\030\t \001(\003\022\r\n\005keyId\030\n \001(\t\022\017\n\007isFirst\030"
  "\013 \001(\010\022\021\n\tmessageId\030\014 \001(\t\022\016\n\006userId\030\r \001(\005"
  "\"D\n\022AESDecryptResponse\022\025\n\rdecrypteddata\030"
  "\001 \001(\014\022\027\n\017decryptedLength\030\002 \001(\005*O\n\rKeyPer"
  "mission\022\n\n\006VERIFY\020\000\022\010\n\004SIGN\020\001\022\013\n\007ENCRYPT"
  "\020\002\022\013\n\007DECRYPT\020\003\022\016\n\nEXPORTABLE\020\004*>\n\017AESCh"
  "ainingMode\022\007\n\003ECB\020\000\022\007\n\003CBC\020\001\022\007\n\003CFB\020\002\022\007\n"
  "\003OFB\020\003\022\007\n\003CTR\020\004*&\n\022AsymmetricFunction\022\007\n"
  "\003RSA\020\000\022\007\n\003ECC\020\001*(\n\014SHAAlgorithm\022\n\n\006SHA25"
  "6\020\000\022\014\n\010SHA3_512\020\001*5\n\014AESKeyLength\022\013\n\007AES"
  "_128\020\000\022\013\n\007AES_192\020\001\022\013\n\007AES_256\020\0022\231\021\n\rCry"
  "ptoService\0226\n\nbootSystem\022\031.crypto.BootSy"
  "stemRequest\032\r.crypto.Empty\0227\n\013addProcces"
  "s\022\031.crypto.AddProcessRequest\032\r.crypto.Em"
  "pty\0224\n\tconfigure\022\030.crypto.ConfigureReque"
  "st\032\r.crypto.Empty\022O\n\016generateAESKey\022\035.cr"
  "ypto.GenerateAESKeyRequest\032\036.crypto.Gene"
  "rateAESKeyResponse\022U\n\022generateRSAKeyPair"
  "\022\036.crypto.GenerateKeyPairRequest\032\037.crypt"
  "o.GenerateKeyPairResponse\022U\n\022generateECC"
  "KeyPair\022\036.crypto.GenerateKeyPairRequest\032"
  "\037.crypto.GenerateKeyPairResponse\022N\n\023getS"
  "ignedDataLength\022\034.crypto.GetHashLengthRe"
  "quest\032\031.crypto.GetLengthResponse\022L\n\025getE"
  "CCencryptedLength\022\030.crypto.GetLengthRequ"
  "est\032\031.crypto.GetLengthResponse\022L\n\025getECC"
  "DecryptedLength\022\030.crypto.GetLengthReques"
  "t\032\031.crypto.GetLengthResponse\022L\n\025getRSAen"
  "cryptedLength\022\030.crypto.GetLengthRequest\032"
  "\031.crypto.GetLengthResponse\022L\n\025getRSAdecr"
  "yptedLength\022\030.crypto.GetLengthRequest\032\031."
  "crypto.GetLengthResponse\022O\n\025getAESencryp"
  "tedLength\022\033.crypto.GetAESLengthRequest\032\031"
  ".crypto.GetLengthResponse\022O\n\025getAESdecry"
  "ptedLength\022\033.crypto.GetAESLengthRequest\032"
  "\031.crypto.GetLengthResponse\022D\n\017getEncrypt"
  "edLen\022\026.crypto.GetWholeLength\032\031.crypto.G"
  "etLengthResponse\022D\n\017getDecryptedLen\022\026.cr"
  "ypto.GetWholeLength\032\031.crypto.GetLengthRe"
  "sponse\0221\n\004sign\022\023.crypto.SignRequest\032\024.cr"
  "ypto.SignResponse\0227\n\006verify\022\025.crypto.Ver"
  "ifyRequest\032\026.crypto.VerifyResponse\022B\n\027ge"
  "tPublicECCKeyByUserId\022\022.crypto.KeyReques"
  "t\032\023.crypto.KeyResponse\022B\n\027getPublicRSAKe"
  "yByUserId\022\022.crypto.KeyRequest\032\023.crypto.K"
  "eyResponse\022O\n\nECCencrypt\022\037.crypto.Asymet"
  "ricEncryptRequest\032 .crypto.AsymetricEncr"
  "yptResponse\022O\n\nECCdecrypt\022\037.crypto.Asyme"
  "tricDecryptRequest\032 .crypto.AsymetricDec"
  "ryptResponse\022O\n\nRSAencrypt\022\037.crypto.Asym"
  "etricEncryptRequest\032 .crypto.AsymetricEn"
  "cryptResponse\022O\n\nRSAdecrypt\022\037.crypto.Asy"
  "metricDecryptRequest\032 .crypto.AsymetricD"
  "ecryptResponse\022C\n\nAESencrypt\022\031.crypto.AE"
  "SEncryptRequest\032\032.crypto.AESEncryptRespo"
  "nse\022C\n\nAESdecrypt\022\031.crypto.AESDecryptReq"
  "uest\032\032.crypto.AESDecryptResponse\022:\n\007encr"
  "ypt\022\026.crypto.EncryptRequest\032\027.crypto.Enc"
  "ryptResponse\022:\n\007decrypt\022\026.crypto.Decrypt"
  "Request\032\027.crypto.DecryptResponse\0227\n\nsign"
  "Update\022\023.crypto.SignRequest\032\024.crypto.Sig"
  "nResponse\0229\n\014signFinalize\022\023.crypto.SignR"
  "equest\032\024.crypto.SignResponse\022=\n\014verifyUp"
  "date\022\025.crypto.VerifyRequest\032\026.crypto.Ver"
  "ifyResponse\022\?\n\016verifyFinalize\022\025.crypto.V"
  "erifyRequest\032\026.crypto.VerifyResponseb\006pr"
  "oto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_proto_2fencryption_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fencryption_2eproto = {
  false, false, 5924, descriptor_table_protodef_proto_2fencryption_2eproto, "proto/encryption.proto", 
  &descriptor_table_proto_2fencryption_2eproto_once, nullptr, 0, 33,
  schemas, file_default_instances, TableStruct_proto_2fencryption_2eproto::offsets,
  file_level_metadata_proto_2fencryption_2eproto, file_level_enum_descriptors_proto_2fencryption_2eproto, file_level_service_descriptors_proto_2fencryption_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_proto_2fencryption_2eproto_getter() {
  return &descriptor_table_proto_2fencryption_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_proto_2fencryption_2eproto(&descriptor_table_proto_2fencryption_2eproto);
namespace crypto {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeyPermission_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fencryption_2eproto);
  return file_level_enum_descriptors_proto_2fencryption_2eproto[0];
}
bool KeyPermission_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AESChainingMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fencryption_2eproto);
  return file_level_enum_descriptors_proto_2fencryption_2eproto[1];
}
bool AESChainingMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsymmetricFunction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fencryption_2eproto);
  return file_level_enum_descriptors_proto_2fencryption_2eproto[2];
}
bool AsymmetricFunction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SHAAlgorithm_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fencryption_2eproto);
  return file_level_enum_descriptors_proto_2fencryption_2eproto[3];
}
bool SHAAlgorithm_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AESKeyLength_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_proto_2fencryption_2eproto);
  return file_level_enum_descriptors_proto_2fencryption_2eproto[4];
}
bool AESKeyLength_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class AsymetricEncryptRequest::_Internal {
 public:
};

AsymetricEncryptRequest::AsymetricEncryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AsymetricEncryptRequest)
}
AsymetricEncryptRequest::AsymetricEncryptRequest(const AsymetricEncryptRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_keyid().empty()) {
    keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_keyid(), 
      GetArenaForAllocation());
  }
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data().empty()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  senderid_ = from.senderid_;
  // @@protoc_insertion_point(copy_constructor:crypto.AsymetricEncryptRequest)
}

void AsymetricEncryptRequest::SharedCtor() {
keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
senderid_ = 0;
}

AsymetricEncryptRequest::~AsymetricEncryptRequest() {
  // @@protoc_insertion_point(destructor:crypto.AsymetricEncryptRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AsymetricEncryptRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  keyid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AsymetricEncryptRequest::ArenaDtor(void* object) {
  AsymetricEncryptRequest* _this = reinterpret_cast< AsymetricEncryptRequest* >(object);
  (void)_this;
}
void AsymetricEncryptRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AsymetricEncryptRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AsymetricEncryptRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AsymetricEncryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  keyid_.ClearToEmpty();
  data_.ClearToEmpty();
  messageid_.ClearToEmpty();
  senderid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AsymetricEncryptRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string keyId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_keyid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.AsymetricEncryptRequest.keyId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.AsymetricEncryptRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AsymetricEncryptRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AsymetricEncryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // string keyId = 2;
  if (!this->_internal_keyid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_keyid().data(), static_cast<int>(this->_internal_keyid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.AsymetricEncryptRequest.keyId");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_keyid(), target);
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // string messageId = 4;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.AsymetricEncryptRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AsymetricEncryptRequest)
  return target;
}

size_t AsymetricEncryptRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AsymetricEncryptRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string keyId = 2;
  if (!this->_internal_keyid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_keyid());
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // string messageId = 4;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AsymetricEncryptRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AsymetricEncryptRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AsymetricEncryptRequest::GetClassData() const { return &_class_data_; }

void AsymetricEncryptRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AsymetricEncryptRequest *>(to)->MergeFrom(
      static_cast<const AsymetricEncryptRequest &>(from));
}


void AsymetricEncryptRequest::MergeFrom(const AsymetricEncryptRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AsymetricEncryptRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_keyid().empty()) {
    _internal_set_keyid(from._internal_keyid());
  }
  if (!from._internal_data().empty()) {
    _internal_set_data(from._internal_data());
  }
  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AsymetricEncryptRequest::CopyFrom(const AsymetricEncryptRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AsymetricEncryptRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymetricEncryptRequest::IsInitialized() const {
  return true;
}

void AsymetricEncryptRequest::InternalSwap(AsymetricEncryptRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &keyid_, lhs_arena,
      &other->keyid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  swap(senderid_, other->senderid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AsymetricEncryptRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[0]);
}

// ===================================================================

class AsymetricEncryptResponse::_Internal {
 public:
};

AsymetricEncryptResponse::AsymetricEncryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AsymetricEncryptResponse)
}
AsymetricEncryptResponse::AsymetricEncryptResponse(const AsymetricEncryptResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  encrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_encrypteddata().empty()) {
    encrypteddata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encrypteddata(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.AsymetricEncryptResponse)
}

void AsymetricEncryptResponse::SharedCtor() {
encrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

AsymetricEncryptResponse::~AsymetricEncryptResponse() {
  // @@protoc_insertion_point(destructor:crypto.AsymetricEncryptResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AsymetricEncryptResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encrypteddata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AsymetricEncryptResponse::ArenaDtor(void* object) {
  AsymetricEncryptResponse* _this = reinterpret_cast< AsymetricEncryptResponse* >(object);
  (void)_this;
}
void AsymetricEncryptResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AsymetricEncryptResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AsymetricEncryptResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AsymetricEncryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  encrypteddata_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AsymetricEncryptResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes encryptedData = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_encrypteddata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AsymetricEncryptResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AsymetricEncryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes encryptedData = 1;
  if (!this->_internal_encrypteddata().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_encrypteddata(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AsymetricEncryptResponse)
  return target;
}

size_t AsymetricEncryptResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AsymetricEncryptResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes encryptedData = 1;
  if (!this->_internal_encrypteddata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encrypteddata());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AsymetricEncryptResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AsymetricEncryptResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AsymetricEncryptResponse::GetClassData() const { return &_class_data_; }

void AsymetricEncryptResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AsymetricEncryptResponse *>(to)->MergeFrom(
      static_cast<const AsymetricEncryptResponse &>(from));
}


void AsymetricEncryptResponse::MergeFrom(const AsymetricEncryptResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AsymetricEncryptResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_encrypteddata().empty()) {
    _internal_set_encrypteddata(from._internal_encrypteddata());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AsymetricEncryptResponse::CopyFrom(const AsymetricEncryptResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AsymetricEncryptResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymetricEncryptResponse::IsInitialized() const {
  return true;
}

void AsymetricEncryptResponse::InternalSwap(AsymetricEncryptResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encrypteddata_, lhs_arena,
      &other->encrypteddata_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AsymetricEncryptResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[1]);
}

// ===================================================================

class AsymetricDecryptRequest::_Internal {
 public:
};

AsymetricDecryptRequest::AsymetricDecryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AsymetricDecryptRequest)
}
AsymetricDecryptRequest::AsymetricDecryptRequest(const AsymetricDecryptRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_keyid().empty()) {
    keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_keyid(), 
      GetArenaForAllocation());
  }
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data().empty()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&senderid_, &from.senderid_,
    static_cast<size_t>(reinterpret_cast<char*>(&receiverid_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(receiverid_));
  // @@protoc_insertion_point(copy_constructor:crypto.AsymetricDecryptRequest)
}

void AsymetricDecryptRequest::SharedCtor() {
keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&senderid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&receiverid_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(receiverid_));
}

AsymetricDecryptRequest::~AsymetricDecryptRequest() {
  // @@protoc_insertion_point(destructor:crypto.AsymetricDecryptRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AsymetricDecryptRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  keyid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AsymetricDecryptRequest::ArenaDtor(void* object) {
  AsymetricDecryptRequest* _this = reinterpret_cast< AsymetricDecryptRequest* >(object);
  (void)_this;
}
void AsymetricDecryptRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AsymetricDecryptRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AsymetricDecryptRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AsymetricDecryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  keyid_.ClearToEmpty();
  data_.ClearToEmpty();
  messageid_.ClearToEmpty();
  ::memset(&senderid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&receiverid_) -
      reinterpret_cast<char*>(&senderid_)) + sizeof(receiverid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AsymetricDecryptRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 receiverId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          receiverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string keyId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_keyid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.AsymetricDecryptRequest.keyId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.AsymetricDecryptRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AsymetricDecryptRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AsymetricDecryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // int32 receiverId = 2;
  if (this->_internal_receiverid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_receiverid(), target);
  }

  // string keyId = 3;
  if (!this->_internal_keyid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_keyid().data(), static_cast<int>(this->_internal_keyid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.AsymetricDecryptRequest.keyId");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_keyid(), target);
  }

  // bytes data = 4;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_data(), target);
  }

  // string messageId = 5;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.AsymetricDecryptRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AsymetricDecryptRequest)
  return target;
}

size_t AsymetricDecryptRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AsymetricDecryptRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string keyId = 3;
  if (!this->_internal_keyid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_keyid());
  }

  // bytes data = 4;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // string messageId = 5;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  // int32 receiverId = 2;
  if (this->_internal_receiverid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiverid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AsymetricDecryptRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AsymetricDecryptRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AsymetricDecryptRequest::GetClassData() const { return &_class_data_; }

void AsymetricDecryptRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AsymetricDecryptRequest *>(to)->MergeFrom(
      static_cast<const AsymetricDecryptRequest &>(from));
}


void AsymetricDecryptRequest::MergeFrom(const AsymetricDecryptRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AsymetricDecryptRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_keyid().empty()) {
    _internal_set_keyid(from._internal_keyid());
  }
  if (!from._internal_data().empty()) {
    _internal_set_data(from._internal_data());
  }
  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  if (from._internal_receiverid() != 0) {
    _internal_set_receiverid(from._internal_receiverid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AsymetricDecryptRequest::CopyFrom(const AsymetricDecryptRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AsymetricDecryptRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymetricDecryptRequest::IsInitialized() const {
  return true;
}

void AsymetricDecryptRequest::InternalSwap(AsymetricDecryptRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &keyid_, lhs_arena,
      &other->keyid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AsymetricDecryptRequest, receiverid_)
      + sizeof(AsymetricDecryptRequest::receiverid_)
      - PROTOBUF_FIELD_OFFSET(AsymetricDecryptRequest, senderid_)>(
          reinterpret_cast<char*>(&senderid_),
          reinterpret_cast<char*>(&other->senderid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AsymetricDecryptRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[2]);
}

// ===================================================================

class GetHashLengthRequest::_Internal {
 public:
};

GetHashLengthRequest::GetHashLengthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GetHashLengthRequest)
}
GetHashLengthRequest::GetHashLengthRequest(const GetHashLengthRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&senderid_, &from.senderid_,
    static_cast<size_t>(reinterpret_cast<char*>(&datalen_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(datalen_));
  // @@protoc_insertion_point(copy_constructor:crypto.GetHashLengthRequest)
}

void GetHashLengthRequest::SharedCtor() {
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&senderid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&datalen_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(datalen_));
}

GetHashLengthRequest::~GetHashLengthRequest() {
  // @@protoc_insertion_point(destructor:crypto.GetHashLengthRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetHashLengthRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetHashLengthRequest::ArenaDtor(void* object) {
  GetHashLengthRequest* _this = reinterpret_cast< GetHashLengthRequest* >(object);
  (void)_this;
}
void GetHashLengthRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetHashLengthRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetHashLengthRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GetHashLengthRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  messageid_.ClearToEmpty();
  ::memset(&senderid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&datalen_) -
      reinterpret_cast<char*>(&senderid_)) + sizeof(datalen_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetHashLengthRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.SHAAlgorithm func = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_func(static_cast<::crypto::SHAAlgorithm>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 dataLen = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          datalen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.GetHashLengthRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetHashLengthRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GetHashLengthRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // .crypto.SHAAlgorithm func = 2;
  if (this->_internal_func() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_func(), target);
  }

  // int32 dataLen = 3;
  if (this->_internal_datalen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_datalen(), target);
  }

  // string messageId = 4;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.GetHashLengthRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GetHashLengthRequest)
  return target;
}

size_t GetHashLengthRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GetHashLengthRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string messageId = 4;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  // .crypto.SHAAlgorithm func = 2;
  if (this->_internal_func() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_func());
  }

  // int32 dataLen = 3;
  if (this->_internal_datalen() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_datalen());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetHashLengthRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetHashLengthRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetHashLengthRequest::GetClassData() const { return &_class_data_; }

void GetHashLengthRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetHashLengthRequest *>(to)->MergeFrom(
      static_cast<const GetHashLengthRequest &>(from));
}


void GetHashLengthRequest::MergeFrom(const GetHashLengthRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GetHashLengthRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  if (from._internal_func() != 0) {
    _internal_set_func(from._internal_func());
  }
  if (from._internal_datalen() != 0) {
    _internal_set_datalen(from._internal_datalen());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetHashLengthRequest::CopyFrom(const GetHashLengthRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GetHashLengthRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetHashLengthRequest::IsInitialized() const {
  return true;
}

void GetHashLengthRequest::InternalSwap(GetHashLengthRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetHashLengthRequest, datalen_)
      + sizeof(GetHashLengthRequest::datalen_)
      - PROTOBUF_FIELD_OFFSET(GetHashLengthRequest, senderid_)>(
          reinterpret_cast<char*>(&senderid_),
          reinterpret_cast<char*>(&other->senderid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetHashLengthRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[3]);
}

// ===================================================================

class GetAESLengthRequest::_Internal {
 public:
};

GetAESLengthRequest::GetAESLengthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GetAESLengthRequest)
}
GetAESLengthRequest::GetAESLengthRequest(const GetAESLengthRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&senderid_, &from.senderid_,
    static_cast<size_t>(reinterpret_cast<char*>(&chainingmode_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(chainingmode_));
  // @@protoc_insertion_point(copy_constructor:crypto.GetAESLengthRequest)
}

void GetAESLengthRequest::SharedCtor() {
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&senderid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&chainingmode_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(chainingmode_));
}

GetAESLengthRequest::~GetAESLengthRequest() {
  // @@protoc_insertion_point(destructor:crypto.GetAESLengthRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetAESLengthRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetAESLengthRequest::ArenaDtor(void* object) {
  GetAESLengthRequest* _this = reinterpret_cast< GetAESLengthRequest* >(object);
  (void)_this;
}
void GetAESLengthRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetAESLengthRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetAESLengthRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GetAESLengthRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  messageid_.ClearToEmpty();
  ::memset(&senderid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&chainingmode_) -
      reinterpret_cast<char*>(&senderid_)) + sizeof(chainingmode_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetAESLengthRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dataLen = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          datalen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isFirst = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          isfirst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESChainingMode chainingMode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_chainingmode(static_cast<::crypto::AESChainingMode>(val));
        } else
          goto handle_unusual;
        continue;
      // string messageId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.GetAESLengthRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetAESLengthRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GetAESLengthRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // int32 dataLen = 2;
  if (this->_internal_datalen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_datalen(), target);
  }

  // bool isFirst = 3;
  if (this->_internal_isfirst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_isfirst(), target);
  }

  // .crypto.AESChainingMode chainingMode = 4;
  if (this->_internal_chainingmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_chainingmode(), target);
  }

  // string messageId = 5;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.GetAESLengthRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GetAESLengthRequest)
  return target;
}

size_t GetAESLengthRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GetAESLengthRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string messageId = 5;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  // int32 dataLen = 2;
  if (this->_internal_datalen() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_datalen());
  }

  // bool isFirst = 3;
  if (this->_internal_isfirst() != 0) {
    total_size += 1 + 1;
  }

  // .crypto.AESChainingMode chainingMode = 4;
  if (this->_internal_chainingmode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_chainingmode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetAESLengthRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetAESLengthRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetAESLengthRequest::GetClassData() const { return &_class_data_; }

void GetAESLengthRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetAESLengthRequest *>(to)->MergeFrom(
      static_cast<const GetAESLengthRequest &>(from));
}


void GetAESLengthRequest::MergeFrom(const GetAESLengthRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GetAESLengthRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  if (from._internal_datalen() != 0) {
    _internal_set_datalen(from._internal_datalen());
  }
  if (from._internal_isfirst() != 0) {
    _internal_set_isfirst(from._internal_isfirst());
  }
  if (from._internal_chainingmode() != 0) {
    _internal_set_chainingmode(from._internal_chainingmode());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetAESLengthRequest::CopyFrom(const GetAESLengthRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GetAESLengthRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetAESLengthRequest::IsInitialized() const {
  return true;
}

void GetAESLengthRequest::InternalSwap(GetAESLengthRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetAESLengthRequest, chainingmode_)
      + sizeof(GetAESLengthRequest::chainingmode_)
      - PROTOBUF_FIELD_OFFSET(GetAESLengthRequest, senderid_)>(
          reinterpret_cast<char*>(&senderid_),
          reinterpret_cast<char*>(&other->senderid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetAESLengthRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[4]);
}

// ===================================================================

class AsymetricDecryptResponse::_Internal {
 public:
};

AsymetricDecryptResponse::AsymetricDecryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AsymetricDecryptResponse)
}
AsymetricDecryptResponse::AsymetricDecryptResponse(const AsymetricDecryptResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  decrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_decrypteddata().empty()) {
    decrypteddata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_decrypteddata(), 
      GetArenaForAllocation());
  }
  decryptedlength_ = from.decryptedlength_;
  // @@protoc_insertion_point(copy_constructor:crypto.AsymetricDecryptResponse)
}

void AsymetricDecryptResponse::SharedCtor() {
decrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
decryptedlength_ = 0;
}

AsymetricDecryptResponse::~AsymetricDecryptResponse() {
  // @@protoc_insertion_point(destructor:crypto.AsymetricDecryptResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AsymetricDecryptResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  decrypteddata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AsymetricDecryptResponse::ArenaDtor(void* object) {
  AsymetricDecryptResponse* _this = reinterpret_cast< AsymetricDecryptResponse* >(object);
  (void)_this;
}
void AsymetricDecryptResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AsymetricDecryptResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AsymetricDecryptResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AsymetricDecryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  decrypteddata_.ClearToEmpty();
  decryptedlength_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AsymetricDecryptResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes decryptedData = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_decrypteddata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 decryptedLength = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          decryptedlength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AsymetricDecryptResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AsymetricDecryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes decryptedData = 1;
  if (!this->_internal_decrypteddata().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_decrypteddata(), target);
  }

  // int32 decryptedLength = 2;
  if (this->_internal_decryptedlength() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_decryptedlength(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AsymetricDecryptResponse)
  return target;
}

size_t AsymetricDecryptResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AsymetricDecryptResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes decryptedData = 1;
  if (!this->_internal_decrypteddata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_decrypteddata());
  }

  // int32 decryptedLength = 2;
  if (this->_internal_decryptedlength() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_decryptedlength());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AsymetricDecryptResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AsymetricDecryptResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AsymetricDecryptResponse::GetClassData() const { return &_class_data_; }

void AsymetricDecryptResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AsymetricDecryptResponse *>(to)->MergeFrom(
      static_cast<const AsymetricDecryptResponse &>(from));
}


void AsymetricDecryptResponse::MergeFrom(const AsymetricDecryptResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AsymetricDecryptResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_decrypteddata().empty()) {
    _internal_set_decrypteddata(from._internal_decrypteddata());
  }
  if (from._internal_decryptedlength() != 0) {
    _internal_set_decryptedlength(from._internal_decryptedlength());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AsymetricDecryptResponse::CopyFrom(const AsymetricDecryptResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AsymetricDecryptResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AsymetricDecryptResponse::IsInitialized() const {
  return true;
}

void AsymetricDecryptResponse::InternalSwap(AsymetricDecryptResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &decrypteddata_, lhs_arena,
      &other->decrypteddata_, rhs_arena
  );
  swap(decryptedlength_, other->decryptedlength_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AsymetricDecryptResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[5]);
}

// ===================================================================

class GetLengthRequest::_Internal {
 public:
};

GetLengthRequest::GetLengthRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GetLengthRequest)
}
GetLengthRequest::GetLengthRequest(const GetLengthRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&senderid_, &from.senderid_,
    static_cast<size_t>(reinterpret_cast<char*>(&inlen_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(inlen_));
  // @@protoc_insertion_point(copy_constructor:crypto.GetLengthRequest)
}

void GetLengthRequest::SharedCtor() {
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&senderid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&inlen_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(inlen_));
}

GetLengthRequest::~GetLengthRequest() {
  // @@protoc_insertion_point(destructor:crypto.GetLengthRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetLengthRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetLengthRequest::ArenaDtor(void* object) {
  GetLengthRequest* _this = reinterpret_cast< GetLengthRequest* >(object);
  (void)_this;
}
void GetLengthRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetLengthRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetLengthRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GetLengthRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  messageid_.ClearToEmpty();
  ::memset(&senderid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&inlen_) -
      reinterpret_cast<char*>(&senderid_)) + sizeof(inlen_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetLengthRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 inLen = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          inlen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.GetLengthRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetLengthRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GetLengthRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // int32 inLen = 2;
  if (this->_internal_inlen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_inlen(), target);
  }

  // string messageId = 3;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.GetLengthRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GetLengthRequest)
  return target;
}

size_t GetLengthRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GetLengthRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string messageId = 3;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  // int32 inLen = 2;
  if (this->_internal_inlen() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_inlen());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetLengthRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetLengthRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetLengthRequest::GetClassData() const { return &_class_data_; }

void GetLengthRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetLengthRequest *>(to)->MergeFrom(
      static_cast<const GetLengthRequest &>(from));
}


void GetLengthRequest::MergeFrom(const GetLengthRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GetLengthRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  if (from._internal_inlen() != 0) {
    _internal_set_inlen(from._internal_inlen());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetLengthRequest::CopyFrom(const GetLengthRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GetLengthRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetLengthRequest::IsInitialized() const {
  return true;
}

void GetLengthRequest::InternalSwap(GetLengthRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetLengthRequest, inlen_)
      + sizeof(GetLengthRequest::inlen_)
      - PROTOBUF_FIELD_OFFSET(GetLengthRequest, senderid_)>(
          reinterpret_cast<char*>(&senderid_),
          reinterpret_cast<char*>(&other->senderid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetLengthRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[6]);
}

// ===================================================================

class GetLengthResponse::_Internal {
 public:
};

GetLengthResponse::GetLengthResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GetLengthResponse)
}
GetLengthResponse::GetLengthResponse(const GetLengthResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  length_ = from.length_;
  // @@protoc_insertion_point(copy_constructor:crypto.GetLengthResponse)
}

void GetLengthResponse::SharedCtor() {
length_ = 0;
}

GetLengthResponse::~GetLengthResponse() {
  // @@protoc_insertion_point(destructor:crypto.GetLengthResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetLengthResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetLengthResponse::ArenaDtor(void* object) {
  GetLengthResponse* _this = reinterpret_cast< GetLengthResponse* >(object);
  (void)_this;
}
void GetLengthResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetLengthResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetLengthResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GetLengthResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  length_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetLengthResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 length = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetLengthResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GetLengthResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 length = 1;
  if (this->_internal_length() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GetLengthResponse)
  return target;
}

size_t GetLengthResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GetLengthResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 length = 1;
  if (this->_internal_length() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_length());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetLengthResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetLengthResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetLengthResponse::GetClassData() const { return &_class_data_; }

void GetLengthResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetLengthResponse *>(to)->MergeFrom(
      static_cast<const GetLengthResponse &>(from));
}


void GetLengthResponse::MergeFrom(const GetLengthResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GetLengthResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_length() != 0) {
    _internal_set_length(from._internal_length());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetLengthResponse::CopyFrom(const GetLengthResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GetLengthResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetLengthResponse::IsInitialized() const {
  return true;
}

void GetLengthResponse::InternalSwap(GetLengthResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(length_, other->length_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetLengthResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[7]);
}

// ===================================================================

class GetWholeLength::_Internal {
 public:
};

GetWholeLength::GetWholeLength(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GetWholeLength)
}
GetWholeLength::GetWholeLength(const GetWholeLength& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&senderid_, &from.senderid_,
    static_cast<size_t>(reinterpret_cast<char*>(&userid_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(userid_));
  // @@protoc_insertion_point(copy_constructor:crypto.GetWholeLength)
}

void GetWholeLength::SharedCtor() {
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&senderid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&userid_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(userid_));
}

GetWholeLength::~GetWholeLength() {
  // @@protoc_insertion_point(destructor:crypto.GetWholeLength)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GetWholeLength::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GetWholeLength::ArenaDtor(void* object) {
  GetWholeLength* _this = reinterpret_cast< GetWholeLength* >(object);
  (void)_this;
}
void GetWholeLength::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GetWholeLength::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetWholeLength::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GetWholeLength)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  messageid_.ClearToEmpty();
  ::memset(&senderid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&userid_) -
      reinterpret_cast<char*>(&senderid_)) + sizeof(userid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetWholeLength::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 inLen = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          inlen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isFirst = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          isfirst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.GetWholeLength.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 userId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          userid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GetWholeLength::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GetWholeLength)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // int32 inLen = 2;
  if (this->_internal_inlen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_inlen(), target);
  }

  // bool isFirst = 3;
  if (this->_internal_isfirst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_isfirst(), target);
  }

  // string messageId = 4;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.GetWholeLength.messageId");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_messageid(), target);
  }

  // int32 userId = 5;
  if (this->_internal_userid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_userid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GetWholeLength)
  return target;
}

size_t GetWholeLength::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GetWholeLength)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string messageId = 4;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  // int32 inLen = 2;
  if (this->_internal_inlen() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_inlen());
  }

  // bool isFirst = 3;
  if (this->_internal_isfirst() != 0) {
    total_size += 1 + 1;
  }

  // int32 userId = 5;
  if (this->_internal_userid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetWholeLength::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GetWholeLength::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetWholeLength::GetClassData() const { return &_class_data_; }

void GetWholeLength::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GetWholeLength *>(to)->MergeFrom(
      static_cast<const GetWholeLength &>(from));
}


void GetWholeLength::MergeFrom(const GetWholeLength& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GetWholeLength)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  if (from._internal_inlen() != 0) {
    _internal_set_inlen(from._internal_inlen());
  }
  if (from._internal_isfirst() != 0) {
    _internal_set_isfirst(from._internal_isfirst());
  }
  if (from._internal_userid() != 0) {
    _internal_set_userid(from._internal_userid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetWholeLength::CopyFrom(const GetWholeLength& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GetWholeLength)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetWholeLength::IsInitialized() const {
  return true;
}

void GetWholeLength::InternalSwap(GetWholeLength* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetWholeLength, userid_)
      + sizeof(GetWholeLength::userid_)
      - PROTOBUF_FIELD_OFFSET(GetWholeLength, senderid_)>(
          reinterpret_cast<char*>(&senderid_),
          reinterpret_cast<char*>(&other->senderid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetWholeLength::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[8]);
}

// ===================================================================

class GenerateAESKeyRequest::_Internal {
 public:
};

GenerateAESKeyRequest::GenerateAESKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  permissions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GenerateAESKeyRequest)
}
GenerateAESKeyRequest::GenerateAESKeyRequest(const GenerateAESKeyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      permissions_(from.permissions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&userid_, &from.userid_,
    static_cast<size_t>(reinterpret_cast<char*>(&destuserid_) -
    reinterpret_cast<char*>(&userid_)) + sizeof(destuserid_));
  // @@protoc_insertion_point(copy_constructor:crypto.GenerateAESKeyRequest)
}

void GenerateAESKeyRequest::SharedCtor() {
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&userid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&destuserid_) -
    reinterpret_cast<char*>(&userid_)) + sizeof(destuserid_));
}

GenerateAESKeyRequest::~GenerateAESKeyRequest() {
  // @@protoc_insertion_point(destructor:crypto.GenerateAESKeyRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GenerateAESKeyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GenerateAESKeyRequest::ArenaDtor(void* object) {
  GenerateAESKeyRequest* _this = reinterpret_cast< GenerateAESKeyRequest* >(object);
  (void)_this;
}
void GenerateAESKeyRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GenerateAESKeyRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenerateAESKeyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GenerateAESKeyRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permissions_.Clear();
  messageid_.ClearToEmpty();
  ::memset(&userid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&destuserid_) -
      reinterpret_cast<char*>(&userid_)) + sizeof(destuserid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GenerateAESKeyRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          userid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .crypto.KeyPermission permissions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_permissions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_permissions(static_cast<::crypto::KeyPermission>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESKeyLength keyLength = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_keylength(static_cast<::crypto::AESKeyLength>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 destUserId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          destuserid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.GenerateAESKeyRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GenerateAESKeyRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GenerateAESKeyRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_userid(), target);
  }

  // repeated .crypto.KeyPermission permissions = 2;
  {
    int byte_size = _permissions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, permissions_, byte_size, target);
    }
  }

  // .crypto.AESKeyLength keyLength = 3;
  if (this->_internal_keylength() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_keylength(), target);
  }

  // int32 destUserId = 4;
  if (this->_internal_destuserid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_destuserid(), target);
  }

  // string messageId = 5;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.GenerateAESKeyRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GenerateAESKeyRequest)
  return target;
}

size_t GenerateAESKeyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GenerateAESKeyRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .crypto.KeyPermission permissions = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_permissions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_permissions(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _permissions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string messageId = 5;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_userid());
  }

  // .crypto.AESKeyLength keyLength = 3;
  if (this->_internal_keylength() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_keylength());
  }

  // int32 destUserId = 4;
  if (this->_internal_destuserid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_destuserid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GenerateAESKeyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GenerateAESKeyRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GenerateAESKeyRequest::GetClassData() const { return &_class_data_; }

void GenerateAESKeyRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GenerateAESKeyRequest *>(to)->MergeFrom(
      static_cast<const GenerateAESKeyRequest &>(from));
}


void GenerateAESKeyRequest::MergeFrom(const GenerateAESKeyRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GenerateAESKeyRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permissions_.MergeFrom(from.permissions_);
  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_userid() != 0) {
    _internal_set_userid(from._internal_userid());
  }
  if (from._internal_keylength() != 0) {
    _internal_set_keylength(from._internal_keylength());
  }
  if (from._internal_destuserid() != 0) {
    _internal_set_destuserid(from._internal_destuserid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GenerateAESKeyRequest::CopyFrom(const GenerateAESKeyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GenerateAESKeyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenerateAESKeyRequest::IsInitialized() const {
  return true;
}

void GenerateAESKeyRequest::InternalSwap(GenerateAESKeyRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  permissions_.InternalSwap(&other->permissions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GenerateAESKeyRequest, destuserid_)
      + sizeof(GenerateAESKeyRequest::destuserid_)
      - PROTOBUF_FIELD_OFFSET(GenerateAESKeyRequest, userid_)>(
          reinterpret_cast<char*>(&userid_),
          reinterpret_cast<char*>(&other->userid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GenerateAESKeyRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[9]);
}

// ===================================================================

class GenerateAESKeyResponse::_Internal {
 public:
};

GenerateAESKeyResponse::GenerateAESKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GenerateAESKeyResponse)
}
GenerateAESKeyResponse::GenerateAESKeyResponse(const GenerateAESKeyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  aeskey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_aeskey().empty()) {
    aeskey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_aeskey(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.GenerateAESKeyResponse)
}

void GenerateAESKeyResponse::SharedCtor() {
aeskey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

GenerateAESKeyResponse::~GenerateAESKeyResponse() {
  // @@protoc_insertion_point(destructor:crypto.GenerateAESKeyResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GenerateAESKeyResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  aeskey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GenerateAESKeyResponse::ArenaDtor(void* object) {
  GenerateAESKeyResponse* _this = reinterpret_cast< GenerateAESKeyResponse* >(object);
  (void)_this;
}
void GenerateAESKeyResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GenerateAESKeyResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenerateAESKeyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GenerateAESKeyResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  aeskey_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GenerateAESKeyResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string aesKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_aeskey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.GenerateAESKeyResponse.aesKey"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GenerateAESKeyResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GenerateAESKeyResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string aesKey = 1;
  if (!this->_internal_aeskey().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_aeskey().data(), static_cast<int>(this->_internal_aeskey().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.GenerateAESKeyResponse.aesKey");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_aeskey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GenerateAESKeyResponse)
  return target;
}

size_t GenerateAESKeyResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GenerateAESKeyResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string aesKey = 1;
  if (!this->_internal_aeskey().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_aeskey());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GenerateAESKeyResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GenerateAESKeyResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GenerateAESKeyResponse::GetClassData() const { return &_class_data_; }

void GenerateAESKeyResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GenerateAESKeyResponse *>(to)->MergeFrom(
      static_cast<const GenerateAESKeyResponse &>(from));
}


void GenerateAESKeyResponse::MergeFrom(const GenerateAESKeyResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GenerateAESKeyResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_aeskey().empty()) {
    _internal_set_aeskey(from._internal_aeskey());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GenerateAESKeyResponse::CopyFrom(const GenerateAESKeyResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GenerateAESKeyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenerateAESKeyResponse::IsInitialized() const {
  return true;
}

void GenerateAESKeyResponse::InternalSwap(GenerateAESKeyResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &aeskey_, lhs_arena,
      &other->aeskey_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GenerateAESKeyResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[10]);
}

// ===================================================================

class GenerateKeyPairRequest::_Internal {
 public:
};

GenerateKeyPairRequest::GenerateKeyPairRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  permissions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GenerateKeyPairRequest)
}
GenerateKeyPairRequest::GenerateKeyPairRequest(const GenerateKeyPairRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      permissions_(from.permissions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  userid_ = from.userid_;
  // @@protoc_insertion_point(copy_constructor:crypto.GenerateKeyPairRequest)
}

void GenerateKeyPairRequest::SharedCtor() {
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
userid_ = 0;
}

GenerateKeyPairRequest::~GenerateKeyPairRequest() {
  // @@protoc_insertion_point(destructor:crypto.GenerateKeyPairRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GenerateKeyPairRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GenerateKeyPairRequest::ArenaDtor(void* object) {
  GenerateKeyPairRequest* _this = reinterpret_cast< GenerateKeyPairRequest* >(object);
  (void)_this;
}
void GenerateKeyPairRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GenerateKeyPairRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenerateKeyPairRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GenerateKeyPairRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permissions_.Clear();
  messageid_.ClearToEmpty();
  userid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GenerateKeyPairRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          userid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .crypto.KeyPermission permissions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_permissions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_permissions(static_cast<::crypto::KeyPermission>(val));
        } else
          goto handle_unusual;
        continue;
      // string messageId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.GenerateKeyPairRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GenerateKeyPairRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GenerateKeyPairRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_userid(), target);
  }

  // repeated .crypto.KeyPermission permissions = 2;
  {
    int byte_size = _permissions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, permissions_, byte_size, target);
    }
  }

  // string messageId = 3;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.GenerateKeyPairRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GenerateKeyPairRequest)
  return target;
}

size_t GenerateKeyPairRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GenerateKeyPairRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .crypto.KeyPermission permissions = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_permissions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_permissions(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _permissions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string messageId = 3;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GenerateKeyPairRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GenerateKeyPairRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GenerateKeyPairRequest::GetClassData() const { return &_class_data_; }

void GenerateKeyPairRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GenerateKeyPairRequest *>(to)->MergeFrom(
      static_cast<const GenerateKeyPairRequest &>(from));
}


void GenerateKeyPairRequest::MergeFrom(const GenerateKeyPairRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GenerateKeyPairRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permissions_.MergeFrom(from.permissions_);
  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_userid() != 0) {
    _internal_set_userid(from._internal_userid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GenerateKeyPairRequest::CopyFrom(const GenerateKeyPairRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GenerateKeyPairRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenerateKeyPairRequest::IsInitialized() const {
  return true;
}

void GenerateKeyPairRequest::InternalSwap(GenerateKeyPairRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  permissions_.InternalSwap(&other->permissions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  swap(userid_, other->userid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GenerateKeyPairRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[11]);
}

// ===================================================================

class GenerateKeyPairResponse::_Internal {
 public:
};

GenerateKeyPairResponse::GenerateKeyPairResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.GenerateKeyPairResponse)
}
GenerateKeyPairResponse::GenerateKeyPairResponse(const GenerateKeyPairResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_publickey().empty()) {
    publickey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_publickey(), 
      GetArenaForAllocation());
  }
  privatekey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_privatekey().empty()) {
    privatekey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_privatekey(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.GenerateKeyPairResponse)
}

void GenerateKeyPairResponse::SharedCtor() {
publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
privatekey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

GenerateKeyPairResponse::~GenerateKeyPairResponse() {
  // @@protoc_insertion_point(destructor:crypto.GenerateKeyPairResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GenerateKeyPairResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  publickey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  privatekey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void GenerateKeyPairResponse::ArenaDtor(void* object) {
  GenerateKeyPairResponse* _this = reinterpret_cast< GenerateKeyPairResponse* >(object);
  (void)_this;
}
void GenerateKeyPairResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GenerateKeyPairResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GenerateKeyPairResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.GenerateKeyPairResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  publickey_.ClearToEmpty();
  privatekey_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GenerateKeyPairResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string publicKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_publickey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.GenerateKeyPairResponse.publicKey"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string privateKey = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_privatekey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.GenerateKeyPairResponse.privateKey"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* GenerateKeyPairResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.GenerateKeyPairResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string publicKey = 1;
  if (!this->_internal_publickey().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_publickey().data(), static_cast<int>(this->_internal_publickey().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.GenerateKeyPairResponse.publicKey");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_publickey(), target);
  }

  // string privateKey = 2;
  if (!this->_internal_privatekey().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_privatekey().data(), static_cast<int>(this->_internal_privatekey().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.GenerateKeyPairResponse.privateKey");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_privatekey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.GenerateKeyPairResponse)
  return target;
}

size_t GenerateKeyPairResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.GenerateKeyPairResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string publicKey = 1;
  if (!this->_internal_publickey().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_publickey());
  }

  // string privateKey = 2;
  if (!this->_internal_privatekey().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_privatekey());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GenerateKeyPairResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GenerateKeyPairResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GenerateKeyPairResponse::GetClassData() const { return &_class_data_; }

void GenerateKeyPairResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GenerateKeyPairResponse *>(to)->MergeFrom(
      static_cast<const GenerateKeyPairResponse &>(from));
}


void GenerateKeyPairResponse::MergeFrom(const GenerateKeyPairResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.GenerateKeyPairResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_publickey().empty()) {
    _internal_set_publickey(from._internal_publickey());
  }
  if (!from._internal_privatekey().empty()) {
    _internal_set_privatekey(from._internal_privatekey());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GenerateKeyPairResponse::CopyFrom(const GenerateKeyPairResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.GenerateKeyPairResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GenerateKeyPairResponse::IsInitialized() const {
  return true;
}

void GenerateKeyPairResponse::InternalSwap(GenerateKeyPairResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &publickey_, lhs_arena,
      &other->publickey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &privatekey_, lhs_arena,
      &other->privatekey_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GenerateKeyPairResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[12]);
}

// ===================================================================

class SignRequest::_Internal {
 public:
};

SignRequest::SignRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.SignRequest)
}
SignRequest::SignRequest(const SignRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data().empty()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_keyid().empty()) {
    keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_keyid(), 
      GetArenaForAllocation());
  }
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&senderid_, &from.senderid_,
    static_cast<size_t>(reinterpret_cast<char*>(&counter_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(counter_));
  // @@protoc_insertion_point(copy_constructor:crypto.SignRequest)
}

void SignRequest::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&senderid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&counter_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(counter_));
}

SignRequest::~SignRequest() {
  // @@protoc_insertion_point(destructor:crypto.SignRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SignRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  keyid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SignRequest::ArenaDtor(void* object) {
  SignRequest* _this = reinterpret_cast< SignRequest* >(object);
  (void)_this;
}
void SignRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SignRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SignRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.SignRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.ClearToEmpty();
  keyid_.ClearToEmpty();
  messageid_.ClearToEmpty();
  ::memset(&senderid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&counter_) -
      reinterpret_cast<char*>(&senderid_)) + sizeof(counter_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.SHAAlgorithm hashFunc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hashfunc(static_cast<::crypto::SHAAlgorithm>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 counter = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string keyId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_keyid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.SignRequest.keyId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.SignRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SignRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.SignRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  // .crypto.SHAAlgorithm hashFunc = 3;
  if (this->_internal_hashfunc() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_hashfunc(), target);
  }

  // int64 counter = 5;
  if (this->_internal_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_counter(), target);
  }

  // string keyId = 6;
  if (!this->_internal_keyid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_keyid().data(), static_cast<int>(this->_internal_keyid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.SignRequest.keyId");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_keyid(), target);
  }

  // string messageId = 7;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.SignRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.SignRequest)
  return target;
}

size_t SignRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.SignRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 2;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // string keyId = 6;
  if (!this->_internal_keyid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_keyid());
  }

  // string messageId = 7;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  // .crypto.SHAAlgorithm hashFunc = 3;
  if (this->_internal_hashfunc() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_hashfunc());
  }

  // int64 counter = 5;
  if (this->_internal_counter() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_counter());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SignRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignRequest::GetClassData() const { return &_class_data_; }

void SignRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SignRequest *>(to)->MergeFrom(
      static_cast<const SignRequest &>(from));
}


void SignRequest::MergeFrom(const SignRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.SignRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _internal_set_data(from._internal_data());
  }
  if (!from._internal_keyid().empty()) {
    _internal_set_keyid(from._internal_keyid());
  }
  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  if (from._internal_hashfunc() != 0) {
    _internal_set_hashfunc(from._internal_hashfunc());
  }
  if (from._internal_counter() != 0) {
    _internal_set_counter(from._internal_counter());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignRequest::CopyFrom(const SignRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.SignRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignRequest::IsInitialized() const {
  return true;
}

void SignRequest::InternalSwap(SignRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &keyid_, lhs_arena,
      &other->keyid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SignRequest, counter_)
      + sizeof(SignRequest::counter_)
      - PROTOBUF_FIELD_OFFSET(SignRequest, senderid_)>(
          reinterpret_cast<char*>(&senderid_),
          reinterpret_cast<char*>(&other->senderid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SignRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[13]);
}

// ===================================================================

class SignResponse::_Internal {
 public:
};

SignResponse::SignResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.SignResponse)
}
SignResponse::SignResponse(const SignResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_signature().empty()) {
    signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signature(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.SignResponse)
}

void SignResponse::SharedCtor() {
signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

SignResponse::~SignResponse() {
  // @@protoc_insertion_point(destructor:crypto.SignResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SignResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SignResponse::ArenaDtor(void* object) {
  SignResponse* _this = reinterpret_cast< SignResponse* >(object);
  (void)_this;
}
void SignResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SignResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SignResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.SignResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  signature_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SignResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes signature = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SignResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.SignResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes signature = 1;
  if (!this->_internal_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.SignResponse)
  return target;
}

size_t SignResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.SignResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes signature = 1;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SignResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SignResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SignResponse::GetClassData() const { return &_class_data_; }

void SignResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SignResponse *>(to)->MergeFrom(
      static_cast<const SignResponse &>(from));
}


void SignResponse::MergeFrom(const SignResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.SignResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_signature().empty()) {
    _internal_set_signature(from._internal_signature());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SignResponse::CopyFrom(const SignResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.SignResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SignResponse::IsInitialized() const {
  return true;
}

void SignResponse::InternalSwap(SignResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SignResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[14]);
}

// ===================================================================

class VerifyRequest::_Internal {
 public:
};

VerifyRequest::VerifyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.VerifyRequest)
}
VerifyRequest::VerifyRequest(const VerifyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data().empty()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_signature().empty()) {
    signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signature(), 
      GetArenaForAllocation());
  }
  keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_keyid().empty()) {
    keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_keyid(), 
      GetArenaForAllocation());
  }
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&senderid_, &from.senderid_,
    static_cast<size_t>(reinterpret_cast<char*>(&counter_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(counter_));
  // @@protoc_insertion_point(copy_constructor:crypto.VerifyRequest)
}

void VerifyRequest::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&senderid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&counter_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(counter_));
}

VerifyRequest::~VerifyRequest() {
  // @@protoc_insertion_point(destructor:crypto.VerifyRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VerifyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  keyid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void VerifyRequest::ArenaDtor(void* object) {
  VerifyRequest* _this = reinterpret_cast< VerifyRequest* >(object);
  (void)_this;
}
void VerifyRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VerifyRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VerifyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.VerifyRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.ClearToEmpty();
  signature_.ClearToEmpty();
  keyid_.ClearToEmpty();
  messageid_.ClearToEmpty();
  ::memset(&senderid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&counter_) -
      reinterpret_cast<char*>(&senderid_)) + sizeof(counter_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerifyRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 receiverId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          receiverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes signature = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.SHAAlgorithm hashFunc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hashfunc(static_cast<::crypto::SHAAlgorithm>(val));
        } else
          goto handle_unusual;
        continue;
      // string keyId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_keyid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.VerifyRequest.keyId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 counter = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.VerifyRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* VerifyRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.VerifyRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // int32 receiverId = 2;
  if (this->_internal_receiverid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_receiverid(), target);
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // bytes signature = 4;
  if (!this->_internal_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_signature(), target);
  }

  // .crypto.SHAAlgorithm hashFunc = 5;
  if (this->_internal_hashfunc() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_hashfunc(), target);
  }

  // string keyId = 6;
  if (!this->_internal_keyid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_keyid().data(), static_cast<int>(this->_internal_keyid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.VerifyRequest.keyId");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_keyid(), target);
  }

  // int32 counter = 7;
  if (this->_internal_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_counter(), target);
  }

  // string messageId = 8;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.VerifyRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.VerifyRequest)
  return target;
}

size_t VerifyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.VerifyRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // bytes signature = 4;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  // string keyId = 6;
  if (!this->_internal_keyid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_keyid());
  }

  // string messageId = 8;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  // int32 receiverId = 2;
  if (this->_internal_receiverid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiverid());
  }

  // .crypto.SHAAlgorithm hashFunc = 5;
  if (this->_internal_hashfunc() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_hashfunc());
  }

  // int32 counter = 7;
  if (this->_internal_counter() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_counter());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerifyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VerifyRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerifyRequest::GetClassData() const { return &_class_data_; }

void VerifyRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VerifyRequest *>(to)->MergeFrom(
      static_cast<const VerifyRequest &>(from));
}


void VerifyRequest::MergeFrom(const VerifyRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.VerifyRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _internal_set_data(from._internal_data());
  }
  if (!from._internal_signature().empty()) {
    _internal_set_signature(from._internal_signature());
  }
  if (!from._internal_keyid().empty()) {
    _internal_set_keyid(from._internal_keyid());
  }
  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  if (from._internal_receiverid() != 0) {
    _internal_set_receiverid(from._internal_receiverid());
  }
  if (from._internal_hashfunc() != 0) {
    _internal_set_hashfunc(from._internal_hashfunc());
  }
  if (from._internal_counter() != 0) {
    _internal_set_counter(from._internal_counter());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerifyRequest::CopyFrom(const VerifyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.VerifyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerifyRequest::IsInitialized() const {
  return true;
}

void VerifyRequest::InternalSwap(VerifyRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &keyid_, lhs_arena,
      &other->keyid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerifyRequest, counter_)
      + sizeof(VerifyRequest::counter_)
      - PROTOBUF_FIELD_OFFSET(VerifyRequest, senderid_)>(
          reinterpret_cast<char*>(&senderid_),
          reinterpret_cast<char*>(&other->senderid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VerifyRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[15]);
}

// ===================================================================

class VerifyResponse::_Internal {
 public:
};

VerifyResponse::VerifyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.VerifyResponse)
}
VerifyResponse::VerifyResponse(const VerifyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  out_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_out().empty()) {
    out_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_out(), 
      GetArenaForAllocation());
  }
  valid_ = from.valid_;
  // @@protoc_insertion_point(copy_constructor:crypto.VerifyResponse)
}

void VerifyResponse::SharedCtor() {
out_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
valid_ = false;
}

VerifyResponse::~VerifyResponse() {
  // @@protoc_insertion_point(destructor:crypto.VerifyResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void VerifyResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  out_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void VerifyResponse::ArenaDtor(void* object) {
  VerifyResponse* _this = reinterpret_cast< VerifyResponse* >(object);
  (void)_this;
}
void VerifyResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void VerifyResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VerifyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.VerifyResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  out_.ClearToEmpty();
  valid_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerifyResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool valid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          valid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes out = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_out();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* VerifyResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.VerifyResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool valid = 1;
  if (this->_internal_valid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_valid(), target);
  }

  // bytes out = 2;
  if (!this->_internal_out().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_out(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.VerifyResponse)
  return target;
}

size_t VerifyResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.VerifyResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes out = 2;
  if (!this->_internal_out().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_out());
  }

  // bool valid = 1;
  if (this->_internal_valid() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerifyResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    VerifyResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerifyResponse::GetClassData() const { return &_class_data_; }

void VerifyResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<VerifyResponse *>(to)->MergeFrom(
      static_cast<const VerifyResponse &>(from));
}


void VerifyResponse::MergeFrom(const VerifyResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.VerifyResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_out().empty()) {
    _internal_set_out(from._internal_out());
  }
  if (from._internal_valid() != 0) {
    _internal_set_valid(from._internal_valid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerifyResponse::CopyFrom(const VerifyResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.VerifyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerifyResponse::IsInitialized() const {
  return true;
}

void VerifyResponse::InternalSwap(VerifyResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &out_, lhs_arena,
      &other->out_, rhs_arena
  );
  swap(valid_, other->valid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata VerifyResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[16]);
}

// ===================================================================

class KeyRequest::_Internal {
 public:
};

KeyRequest::KeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.KeyRequest)
}
KeyRequest::KeyRequest(const KeyRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&senderid_, &from.senderid_,
    static_cast<size_t>(reinterpret_cast<char*>(&userid_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(userid_));
  // @@protoc_insertion_point(copy_constructor:crypto.KeyRequest)
}

void KeyRequest::SharedCtor() {
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&senderid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&userid_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(userid_));
}

KeyRequest::~KeyRequest() {
  // @@protoc_insertion_point(destructor:crypto.KeyRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KeyRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void KeyRequest::ArenaDtor(void* object) {
  KeyRequest* _this = reinterpret_cast< KeyRequest* >(object);
  (void)_this;
}
void KeyRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeyRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeyRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.KeyRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  messageid_.ClearToEmpty();
  ::memset(&senderid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&userid_) -
      reinterpret_cast<char*>(&senderid_)) + sizeof(userid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 userId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          userid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.KeyRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* KeyRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.KeyRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // int32 userId = 2;
  if (this->_internal_userid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_userid(), target);
  }

  // string messageId = 3;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.KeyRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.KeyRequest)
  return target;
}

size_t KeyRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.KeyRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string messageId = 3;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  // int32 userId = 2;
  if (this->_internal_userid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KeyRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyRequest::GetClassData() const { return &_class_data_; }

void KeyRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KeyRequest *>(to)->MergeFrom(
      static_cast<const KeyRequest &>(from));
}


void KeyRequest::MergeFrom(const KeyRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.KeyRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  if (from._internal_userid() != 0) {
    _internal_set_userid(from._internal_userid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyRequest::CopyFrom(const KeyRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.KeyRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyRequest::IsInitialized() const {
  return true;
}

void KeyRequest::InternalSwap(KeyRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(KeyRequest, userid_)
      + sizeof(KeyRequest::userid_)
      - PROTOBUF_FIELD_OFFSET(KeyRequest, senderid_)>(
          reinterpret_cast<char*>(&senderid_),
          reinterpret_cast<char*>(&other->senderid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[17]);
}

// ===================================================================

class KeyResponse::_Internal {
 public:
};

KeyResponse::KeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.KeyResponse)
}
KeyResponse::KeyResponse(const KeyResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_key().empty()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.KeyResponse)
}

void KeyResponse::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

KeyResponse::~KeyResponse() {
  // @@protoc_insertion_point(destructor:crypto.KeyResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void KeyResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void KeyResponse::ArenaDtor(void* object) {
  KeyResponse* _this = reinterpret_cast< KeyResponse* >(object);
  (void)_this;
}
void KeyResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void KeyResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void KeyResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.KeyResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  key_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* KeyResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.KeyResponse.key"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* KeyResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.KeyResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.KeyResponse.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.KeyResponse)
  return target;
}

size_t KeyResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.KeyResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string key = 1;
  if (!this->_internal_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData KeyResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    KeyResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*KeyResponse::GetClassData() const { return &_class_data_; }

void KeyResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<KeyResponse *>(to)->MergeFrom(
      static_cast<const KeyResponse &>(from));
}


void KeyResponse::MergeFrom(const KeyResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.KeyResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_key().empty()) {
    _internal_set_key(from._internal_key());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void KeyResponse::CopyFrom(const KeyResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.KeyResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyResponse::IsInitialized() const {
  return true;
}

void KeyResponse::InternalSwap(KeyResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata KeyResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[18]);
}

// ===================================================================

class UserKeyPermissions::_Internal {
 public:
};

UserKeyPermissions::UserKeyPermissions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  permissions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.UserKeyPermissions)
}
UserKeyPermissions::UserKeyPermissions(const UserKeyPermissions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      permissions_(from.permissions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  userid_ = from.userid_;
  // @@protoc_insertion_point(copy_constructor:crypto.UserKeyPermissions)
}

void UserKeyPermissions::SharedCtor() {
userid_ = 0;
}

UserKeyPermissions::~UserKeyPermissions() {
  // @@protoc_insertion_point(destructor:crypto.UserKeyPermissions)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UserKeyPermissions::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void UserKeyPermissions::ArenaDtor(void* object) {
  UserKeyPermissions* _this = reinterpret_cast< UserKeyPermissions* >(object);
  (void)_this;
}
void UserKeyPermissions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UserKeyPermissions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserKeyPermissions::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.UserKeyPermissions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permissions_.Clear();
  userid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserKeyPermissions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          userid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .crypto.KeyPermission permissions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_permissions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_permissions(static_cast<::crypto::KeyPermission>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* UserKeyPermissions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.UserKeyPermissions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_userid(), target);
  }

  // repeated .crypto.KeyPermission permissions = 2;
  {
    int byte_size = _permissions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, permissions_, byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.UserKeyPermissions)
  return target;
}

size_t UserKeyPermissions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.UserKeyPermissions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .crypto.KeyPermission permissions = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_permissions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_permissions(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _permissions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserKeyPermissions::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UserKeyPermissions::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserKeyPermissions::GetClassData() const { return &_class_data_; }

void UserKeyPermissions::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UserKeyPermissions *>(to)->MergeFrom(
      static_cast<const UserKeyPermissions &>(from));
}


void UserKeyPermissions::MergeFrom(const UserKeyPermissions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.UserKeyPermissions)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permissions_.MergeFrom(from.permissions_);
  if (from._internal_userid() != 0) {
    _internal_set_userid(from._internal_userid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserKeyPermissions::CopyFrom(const UserKeyPermissions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.UserKeyPermissions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserKeyPermissions::IsInitialized() const {
  return true;
}

void UserKeyPermissions::InternalSwap(UserKeyPermissions* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  permissions_.InternalSwap(&other->permissions_);
  swap(userid_, other->userid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UserKeyPermissions::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[19]);
}

// ===================================================================

class BootSystemRequest::_Internal {
 public:
};

BootSystemRequest::BootSystemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  usersidspermissions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.BootSystemRequest)
}
BootSystemRequest::BootSystemRequest(const BootSystemRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      usersidspermissions_(from.usersidspermissions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.BootSystemRequest)
}

void BootSystemRequest::SharedCtor() {
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

BootSystemRequest::~BootSystemRequest() {
  // @@protoc_insertion_point(destructor:crypto.BootSystemRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void BootSystemRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BootSystemRequest::ArenaDtor(void* object) {
  BootSystemRequest* _this = reinterpret_cast< BootSystemRequest* >(object);
  (void)_this;
}
void BootSystemRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BootSystemRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BootSystemRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.BootSystemRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  usersidspermissions_.Clear();
  messageid_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BootSystemRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .crypto.UserKeyPermissions usersIdsPermissions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_usersidspermissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // string messageId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.BootSystemRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BootSystemRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.BootSystemRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .crypto.UserKeyPermissions usersIdsPermissions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_usersidspermissions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_usersidspermissions(i), target, stream);
  }

  // string messageId = 5;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.BootSystemRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.BootSystemRequest)
  return target;
}

size_t BootSystemRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.BootSystemRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .crypto.UserKeyPermissions usersIdsPermissions = 1;
  total_size += 1UL * this->_internal_usersidspermissions_size();
  for (const auto& msg : this->usersidspermissions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string messageId = 5;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BootSystemRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    BootSystemRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BootSystemRequest::GetClassData() const { return &_class_data_; }

void BootSystemRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<BootSystemRequest *>(to)->MergeFrom(
      static_cast<const BootSystemRequest &>(from));
}


void BootSystemRequest::MergeFrom(const BootSystemRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.BootSystemRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  usersidspermissions_.MergeFrom(from.usersidspermissions_);
  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BootSystemRequest::CopyFrom(const BootSystemRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.BootSystemRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BootSystemRequest::IsInitialized() const {
  return true;
}

void BootSystemRequest::InternalSwap(BootSystemRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  usersidspermissions_.InternalSwap(&other->usersidspermissions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata BootSystemRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[20]);
}

// ===================================================================

class Empty::_Internal {
 public:
};

Empty::Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:crypto.Empty)
}
Empty::Empty(const Empty& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:crypto.Empty)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Empty::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Empty::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Empty::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[21]);
}

// ===================================================================

class CryptoConfig::_Internal {
 public:
};

CryptoConfig::CryptoConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.CryptoConfig)
}
CryptoConfig::CryptoConfig(const CryptoConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&hashfunction_, &from.hashfunction_,
    static_cast<size_t>(reinterpret_cast<char*>(&asymmetricfunction_) -
    reinterpret_cast<char*>(&hashfunction_)) + sizeof(asymmetricfunction_));
  // @@protoc_insertion_point(copy_constructor:crypto.CryptoConfig)
}

void CryptoConfig::SharedCtor() {
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&hashfunction_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&asymmetricfunction_) -
    reinterpret_cast<char*>(&hashfunction_)) + sizeof(asymmetricfunction_));
}

CryptoConfig::~CryptoConfig() {
  // @@protoc_insertion_point(destructor:crypto.CryptoConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CryptoConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CryptoConfig::ArenaDtor(void* object) {
  CryptoConfig* _this = reinterpret_cast< CryptoConfig* >(object);
  (void)_this;
}
void CryptoConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CryptoConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CryptoConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.CryptoConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  messageid_.ClearToEmpty();
  ::memset(&hashfunction_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&asymmetricfunction_) -
      reinterpret_cast<char*>(&hashfunction_)) + sizeof(asymmetricfunction_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CryptoConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .crypto.SHAAlgorithm hashFunction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_hashfunction(static_cast<::crypto::SHAAlgorithm>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESKeyLength aesKeyLength = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_aeskeylength(static_cast<::crypto::AESKeyLength>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESChainingMode aesChainingMode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_aeschainingmode(static_cast<::crypto::AESChainingMode>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AsymmetricFunction asymmetricFunction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_asymmetricfunction(static_cast<::crypto::AsymmetricFunction>(val));
        } else
          goto handle_unusual;
        continue;
      // string messageId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.CryptoConfig.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* CryptoConfig::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.CryptoConfig)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .crypto.SHAAlgorithm hashFunction = 1;
  if (this->_internal_hashfunction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_hashfunction(), target);
  }

  // .crypto.AESKeyLength aesKeyLength = 2;
  if (this->_internal_aeskeylength() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_aeskeylength(), target);
  }

  // .crypto.AESChainingMode aesChainingMode = 3;
  if (this->_internal_aeschainingmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_aeschainingmode(), target);
  }

  // .crypto.AsymmetricFunction asymmetricFunction = 4;
  if (this->_internal_asymmetricfunction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_asymmetricfunction(), target);
  }

  // string messageId = 5;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.CryptoConfig.messageId");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.CryptoConfig)
  return target;
}

size_t CryptoConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.CryptoConfig)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string messageId = 5;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // .crypto.SHAAlgorithm hashFunction = 1;
  if (this->_internal_hashfunction() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_hashfunction());
  }

  // .crypto.AESKeyLength aesKeyLength = 2;
  if (this->_internal_aeskeylength() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_aeskeylength());
  }

  // .crypto.AESChainingMode aesChainingMode = 3;
  if (this->_internal_aeschainingmode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_aeschainingmode());
  }

  // .crypto.AsymmetricFunction asymmetricFunction = 4;
  if (this->_internal_asymmetricfunction() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_asymmetricfunction());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CryptoConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CryptoConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CryptoConfig::GetClassData() const { return &_class_data_; }

void CryptoConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CryptoConfig *>(to)->MergeFrom(
      static_cast<const CryptoConfig &>(from));
}


void CryptoConfig::MergeFrom(const CryptoConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.CryptoConfig)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_hashfunction() != 0) {
    _internal_set_hashfunction(from._internal_hashfunction());
  }
  if (from._internal_aeskeylength() != 0) {
    _internal_set_aeskeylength(from._internal_aeskeylength());
  }
  if (from._internal_aeschainingmode() != 0) {
    _internal_set_aeschainingmode(from._internal_aeschainingmode());
  }
  if (from._internal_asymmetricfunction() != 0) {
    _internal_set_asymmetricfunction(from._internal_asymmetricfunction());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CryptoConfig::CopyFrom(const CryptoConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.CryptoConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CryptoConfig::IsInitialized() const {
  return true;
}

void CryptoConfig::InternalSwap(CryptoConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CryptoConfig, asymmetricfunction_)
      + sizeof(CryptoConfig::asymmetricfunction_)
      - PROTOBUF_FIELD_OFFSET(CryptoConfig, hashfunction_)>(
          reinterpret_cast<char*>(&hashfunction_),
          reinterpret_cast<char*>(&other->hashfunction_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CryptoConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[22]);
}

// ===================================================================

class ConfigureRequest::_Internal {
 public:
  static const ::crypto::CryptoConfig& config(const ConfigureRequest* msg);
};

const ::crypto::CryptoConfig&
ConfigureRequest::_Internal::config(const ConfigureRequest* msg) {
  return *msg->config_;
}
ConfigureRequest::ConfigureRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.ConfigureRequest)
}
ConfigureRequest::ConfigureRequest(const ConfigureRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_config()) {
    config_ = new ::crypto::CryptoConfig(*from.config_);
  } else {
    config_ = nullptr;
  }
  userid_ = from.userid_;
  // @@protoc_insertion_point(copy_constructor:crypto.ConfigureRequest)
}

void ConfigureRequest::SharedCtor() {
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&userid_) -
    reinterpret_cast<char*>(&config_)) + sizeof(userid_));
}

ConfigureRequest::~ConfigureRequest() {
  // @@protoc_insertion_point(destructor:crypto.ConfigureRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ConfigureRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete config_;
}

void ConfigureRequest::ArenaDtor(void* object) {
  ConfigureRequest* _this = reinterpret_cast< ConfigureRequest* >(object);
  (void)_this;
}
void ConfigureRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ConfigureRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ConfigureRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.ConfigureRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  messageid_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && config_ != nullptr) {
    delete config_;
  }
  config_ = nullptr;
  userid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigureRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          userid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.CryptoConfig config = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.ConfigureRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ConfigureRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.ConfigureRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_userid(), target);
  }

  // .crypto.CryptoConfig config = 2;
  if (this->_internal_has_config()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::config(this), target, stream);
  }

  // string messageId = 3;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.ConfigureRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.ConfigureRequest)
  return target;
}

size_t ConfigureRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.ConfigureRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string messageId = 3;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // .crypto.CryptoConfig config = 2;
  if (this->_internal_has_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *config_);
  }

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigureRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ConfigureRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigureRequest::GetClassData() const { return &_class_data_; }

void ConfigureRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ConfigureRequest *>(to)->MergeFrom(
      static_cast<const ConfigureRequest &>(from));
}


void ConfigureRequest::MergeFrom(const ConfigureRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.ConfigureRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_has_config()) {
    _internal_mutable_config()->::crypto::CryptoConfig::MergeFrom(from._internal_config());
  }
  if (from._internal_userid() != 0) {
    _internal_set_userid(from._internal_userid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigureRequest::CopyFrom(const ConfigureRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.ConfigureRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigureRequest::IsInitialized() const {
  return true;
}

void ConfigureRequest::InternalSwap(ConfigureRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigureRequest, userid_)
      + sizeof(ConfigureRequest::userid_)
      - PROTOBUF_FIELD_OFFSET(ConfigureRequest, config_)>(
          reinterpret_cast<char*>(&config_),
          reinterpret_cast<char*>(&other->config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigureRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[23]);
}

// ===================================================================

class AddProcessRequest::_Internal {
 public:
};

AddProcessRequest::AddProcessRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  permissions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AddProcessRequest)
}
AddProcessRequest::AddProcessRequest(const AddProcessRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      permissions_(from.permissions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  userid_ = from.userid_;
  // @@protoc_insertion_point(copy_constructor:crypto.AddProcessRequest)
}

void AddProcessRequest::SharedCtor() {
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
userid_ = 0;
}

AddProcessRequest::~AddProcessRequest() {
  // @@protoc_insertion_point(destructor:crypto.AddProcessRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AddProcessRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AddProcessRequest::ArenaDtor(void* object) {
  AddProcessRequest* _this = reinterpret_cast< AddProcessRequest* >(object);
  (void)_this;
}
void AddProcessRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AddProcessRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AddProcessRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AddProcessRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permissions_.Clear();
  messageid_.ClearToEmpty();
  userid_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AddProcessRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 userId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          userid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .crypto.KeyPermission permissions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(_internal_mutable_permissions(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_add_permissions(static_cast<::crypto::KeyPermission>(val));
        } else
          goto handle_unusual;
        continue;
      // string messageId = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.AddProcessRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AddProcessRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AddProcessRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_userid(), target);
  }

  // repeated .crypto.KeyPermission permissions = 2;
  {
    int byte_size = _permissions_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteEnumPacked(
          2, permissions_, byte_size, target);
    }
  }

  // string messageId = 4;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.AddProcessRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AddProcessRequest)
  return target;
}

size_t AddProcessRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AddProcessRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .crypto.KeyPermission permissions = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_permissions_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_permissions(static_cast<int>(i)));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
            static_cast<::PROTOBUF_NAMESPACE_ID::int32>(data_size));
    }
    int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(data_size);
    _permissions_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // string messageId = 4;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 userId = 1;
  if (this->_internal_userid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AddProcessRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AddProcessRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AddProcessRequest::GetClassData() const { return &_class_data_; }

void AddProcessRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AddProcessRequest *>(to)->MergeFrom(
      static_cast<const AddProcessRequest &>(from));
}


void AddProcessRequest::MergeFrom(const AddProcessRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AddProcessRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permissions_.MergeFrom(from.permissions_);
  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_userid() != 0) {
    _internal_set_userid(from._internal_userid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AddProcessRequest::CopyFrom(const AddProcessRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AddProcessRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AddProcessRequest::IsInitialized() const {
  return true;
}

void AddProcessRequest::InternalSwap(AddProcessRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  permissions_.InternalSwap(&other->permissions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  swap(userid_, other->userid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AddProcessRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[24]);
}

// ===================================================================

class EncryptRequest::_Internal {
 public:
};

EncryptRequest::EncryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.EncryptRequest)
}
EncryptRequest::EncryptRequest(const EncryptRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data().empty()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&senderid_, &from.senderid_,
    static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(isfirst_));
  // @@protoc_insertion_point(copy_constructor:crypto.EncryptRequest)
}

void EncryptRequest::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&senderid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(isfirst_));
}

EncryptRequest::~EncryptRequest() {
  // @@protoc_insertion_point(destructor:crypto.EncryptRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void EncryptRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void EncryptRequest::ArenaDtor(void* object) {
  EncryptRequest* _this = reinterpret_cast< EncryptRequest* >(object);
  (void)_this;
}
void EncryptRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EncryptRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EncryptRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.EncryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.ClearToEmpty();
  messageid_.ClearToEmpty();
  ::memset(&senderid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isfirst_) -
      reinterpret_cast<char*>(&senderid_)) + sizeof(isfirst_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EncryptRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 receiverId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          receiverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 counter = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isFirst = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          isfirst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.EncryptRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EncryptRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.EncryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // int32 receiverId = 2;
  if (this->_internal_receiverid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_receiverid(), target);
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // int64 counter = 4;
  if (this->_internal_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_counter(), target);
  }

  // bool isFirst = 5;
  if (this->_internal_isfirst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_isfirst(), target);
  }

  // string messageId = 6;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.EncryptRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.EncryptRequest)
  return target;
}

size_t EncryptRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.EncryptRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // string messageId = 6;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  // int32 receiverId = 2;
  if (this->_internal_receiverid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiverid());
  }

  // int64 counter = 4;
  if (this->_internal_counter() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_counter());
  }

  // bool isFirst = 5;
  if (this->_internal_isfirst() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EncryptRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EncryptRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EncryptRequest::GetClassData() const { return &_class_data_; }

void EncryptRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EncryptRequest *>(to)->MergeFrom(
      static_cast<const EncryptRequest &>(from));
}


void EncryptRequest::MergeFrom(const EncryptRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.EncryptRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _internal_set_data(from._internal_data());
  }
  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  if (from._internal_receiverid() != 0) {
    _internal_set_receiverid(from._internal_receiverid());
  }
  if (from._internal_counter() != 0) {
    _internal_set_counter(from._internal_counter());
  }
  if (from._internal_isfirst() != 0) {
    _internal_set_isfirst(from._internal_isfirst());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EncryptRequest::CopyFrom(const EncryptRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.EncryptRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncryptRequest::IsInitialized() const {
  return true;
}

void EncryptRequest::InternalSwap(EncryptRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EncryptRequest, isfirst_)
      + sizeof(EncryptRequest::isfirst_)
      - PROTOBUF_FIELD_OFFSET(EncryptRequest, senderid_)>(
          reinterpret_cast<char*>(&senderid_),
          reinterpret_cast<char*>(&other->senderid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EncryptRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[25]);
}

// ===================================================================

class EncryptResponse::_Internal {
 public:
};

EncryptResponse::EncryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.EncryptResponse)
}
EncryptResponse::EncryptResponse(const EncryptResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  encrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_encrypteddata().empty()) {
    encrypteddata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encrypteddata(), 
      GetArenaForAllocation());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_signature().empty()) {
    signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signature(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.EncryptResponse)
}

void EncryptResponse::SharedCtor() {
encrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

EncryptResponse::~EncryptResponse() {
  // @@protoc_insertion_point(destructor:crypto.EncryptResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void EncryptResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encrypteddata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void EncryptResponse::ArenaDtor(void* object) {
  EncryptResponse* _this = reinterpret_cast< EncryptResponse* >(object);
  (void)_this;
}
void EncryptResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EncryptResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EncryptResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.EncryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  encrypteddata_.ClearToEmpty();
  signature_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EncryptResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes encryptedData = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_encrypteddata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes signature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EncryptResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.EncryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes encryptedData = 1;
  if (!this->_internal_encrypteddata().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_encrypteddata(), target);
  }

  // bytes signature = 2;
  if (!this->_internal_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.EncryptResponse)
  return target;
}

size_t EncryptResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.EncryptResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes encryptedData = 1;
  if (!this->_internal_encrypteddata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encrypteddata());
  }

  // bytes signature = 2;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EncryptResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    EncryptResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EncryptResponse::GetClassData() const { return &_class_data_; }

void EncryptResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<EncryptResponse *>(to)->MergeFrom(
      static_cast<const EncryptResponse &>(from));
}


void EncryptResponse::MergeFrom(const EncryptResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.EncryptResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_encrypteddata().empty()) {
    _internal_set_encrypteddata(from._internal_encrypteddata());
  }
  if (!from._internal_signature().empty()) {
    _internal_set_signature(from._internal_signature());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EncryptResponse::CopyFrom(const EncryptResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.EncryptResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EncryptResponse::IsInitialized() const {
  return true;
}

void EncryptResponse::InternalSwap(EncryptResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encrypteddata_, lhs_arena,
      &other->encrypteddata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata EncryptResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[26]);
}

// ===================================================================

class DecryptRequest::_Internal {
 public:
};

DecryptRequest::DecryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.DecryptRequest)
}
DecryptRequest::DecryptRequest(const DecryptRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  encrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_encrypteddata().empty()) {
    encrypteddata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encrypteddata(), 
      GetArenaForAllocation());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_signature().empty()) {
    signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signature(), 
      GetArenaForAllocation());
  }
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&senderid_, &from.senderid_,
    static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(isfirst_));
  // @@protoc_insertion_point(copy_constructor:crypto.DecryptRequest)
}

void DecryptRequest::SharedCtor() {
encrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&senderid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(isfirst_));
}

DecryptRequest::~DecryptRequest() {
  // @@protoc_insertion_point(destructor:crypto.DecryptRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DecryptRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encrypteddata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DecryptRequest::ArenaDtor(void* object) {
  DecryptRequest* _this = reinterpret_cast< DecryptRequest* >(object);
  (void)_this;
}
void DecryptRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DecryptRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DecryptRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.DecryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  encrypteddata_.ClearToEmpty();
  signature_.ClearToEmpty();
  messageid_.ClearToEmpty();
  ::memset(&senderid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isfirst_) -
      reinterpret_cast<char*>(&senderid_)) + sizeof(isfirst_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DecryptRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 receiverId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          receiverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes encryptedData = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_encrypteddata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 counter = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isFirst = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          isfirst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.DecryptRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DecryptRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.DecryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // int32 receiverId = 2;
  if (this->_internal_receiverid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_receiverid(), target);
  }

  // bytes encryptedData = 3;
  if (!this->_internal_encrypteddata().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_encrypteddata(), target);
  }

  // int64 counter = 4;
  if (this->_internal_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_counter(), target);
  }

  // bytes signature = 5;
  if (!this->_internal_signature().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_signature(), target);
  }

  // bool isFirst = 6;
  if (this->_internal_isfirst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_isfirst(), target);
  }

  // string messageId = 7;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.DecryptRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.DecryptRequest)
  return target;
}

size_t DecryptRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.DecryptRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes encryptedData = 3;
  if (!this->_internal_encrypteddata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encrypteddata());
  }

  // bytes signature = 5;
  if (!this->_internal_signature().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  // string messageId = 7;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  // int32 receiverId = 2;
  if (this->_internal_receiverid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiverid());
  }

  // int64 counter = 4;
  if (this->_internal_counter() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_counter());
  }

  // bool isFirst = 6;
  if (this->_internal_isfirst() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DecryptRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DecryptRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DecryptRequest::GetClassData() const { return &_class_data_; }

void DecryptRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DecryptRequest *>(to)->MergeFrom(
      static_cast<const DecryptRequest &>(from));
}


void DecryptRequest::MergeFrom(const DecryptRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.DecryptRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_encrypteddata().empty()) {
    _internal_set_encrypteddata(from._internal_encrypteddata());
  }
  if (!from._internal_signature().empty()) {
    _internal_set_signature(from._internal_signature());
  }
  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  if (from._internal_receiverid() != 0) {
    _internal_set_receiverid(from._internal_receiverid());
  }
  if (from._internal_counter() != 0) {
    _internal_set_counter(from._internal_counter());
  }
  if (from._internal_isfirst() != 0) {
    _internal_set_isfirst(from._internal_isfirst());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DecryptRequest::CopyFrom(const DecryptRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.DecryptRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecryptRequest::IsInitialized() const {
  return true;
}

void DecryptRequest::InternalSwap(DecryptRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encrypteddata_, lhs_arena,
      &other->encrypteddata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DecryptRequest, isfirst_)
      + sizeof(DecryptRequest::isfirst_)
      - PROTOBUF_FIELD_OFFSET(DecryptRequest, senderid_)>(
          reinterpret_cast<char*>(&senderid_),
          reinterpret_cast<char*>(&other->senderid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata DecryptRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[27]);
}

// ===================================================================

class DecryptResponse::_Internal {
 public:
};

DecryptResponse::DecryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.DecryptResponse)
}
DecryptResponse::DecryptResponse(const DecryptResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  decrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_decrypteddata().empty()) {
    decrypteddata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_decrypteddata(), 
      GetArenaForAllocation());
  }
  decryptedlength_ = from.decryptedlength_;
  // @@protoc_insertion_point(copy_constructor:crypto.DecryptResponse)
}

void DecryptResponse::SharedCtor() {
decrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
decryptedlength_ = 0;
}

DecryptResponse::~DecryptResponse() {
  // @@protoc_insertion_point(destructor:crypto.DecryptResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DecryptResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  decrypteddata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DecryptResponse::ArenaDtor(void* object) {
  DecryptResponse* _this = reinterpret_cast< DecryptResponse* >(object);
  (void)_this;
}
void DecryptResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DecryptResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DecryptResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.DecryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  decrypteddata_.ClearToEmpty();
  decryptedlength_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DecryptResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes decryptedData = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_decrypteddata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 decryptedLength = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          decryptedlength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* DecryptResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.DecryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes decryptedData = 1;
  if (!this->_internal_decrypteddata().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_decrypteddata(), target);
  }

  // int32 decryptedLength = 2;
  if (this->_internal_decryptedlength() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_decryptedlength(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.DecryptResponse)
  return target;
}

size_t DecryptResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.DecryptResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes decryptedData = 1;
  if (!this->_internal_decrypteddata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_decrypteddata());
  }

  // int32 decryptedLength = 2;
  if (this->_internal_decryptedlength() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_decryptedlength());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DecryptResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DecryptResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DecryptResponse::GetClassData() const { return &_class_data_; }

void DecryptResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DecryptResponse *>(to)->MergeFrom(
      static_cast<const DecryptResponse &>(from));
}


void DecryptResponse::MergeFrom(const DecryptResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.DecryptResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_decrypteddata().empty()) {
    _internal_set_decrypteddata(from._internal_decrypteddata());
  }
  if (from._internal_decryptedlength() != 0) {
    _internal_set_decryptedlength(from._internal_decryptedlength());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DecryptResponse::CopyFrom(const DecryptResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.DecryptResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecryptResponse::IsInitialized() const {
  return true;
}

void DecryptResponse::InternalSwap(DecryptResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &decrypteddata_, lhs_arena,
      &other->decrypteddata_, rhs_arena
  );
  swap(decryptedlength_, other->decryptedlength_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DecryptResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[28]);
}

// ===================================================================

class AESEncryptRequest::_Internal {
 public:
};

AESEncryptRequest::AESEncryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AESEncryptRequest)
}
AESEncryptRequest::AESEncryptRequest(const AESEncryptRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_data().empty()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_keyid().empty()) {
    keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_keyid(), 
      GetArenaForAllocation());
  }
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&senderid_, &from.senderid_,
    static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(isfirst_));
  // @@protoc_insertion_point(copy_constructor:crypto.AESEncryptRequest)
}

void AESEncryptRequest::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&senderid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&isfirst_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(isfirst_));
}

AESEncryptRequest::~AESEncryptRequest() {
  // @@protoc_insertion_point(destructor:crypto.AESEncryptRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AESEncryptRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  keyid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AESEncryptRequest::ArenaDtor(void* object) {
  AESEncryptRequest* _this = reinterpret_cast< AESEncryptRequest* >(object);
  (void)_this;
}
void AESEncryptRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AESEncryptRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AESEncryptRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AESEncryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  data_.ClearToEmpty();
  keyid_.ClearToEmpty();
  messageid_.ClearToEmpty();
  ::memset(&senderid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&isfirst_) -
      reinterpret_cast<char*>(&senderid_)) + sizeof(isfirst_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AESEncryptRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 receiverId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          receiverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.AsymmetricFunction func = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_func(static_cast<::crypto::AsymmetricFunction>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 counter = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string keyId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_keyid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.AESEncryptRequest.keyId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESKeyLength keyLength = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_keylength(static_cast<::crypto::AESKeyLength>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESChainingMode chainingMode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_chainingmode(static_cast<::crypto::AESChainingMode>(val));
        } else
          goto handle_unusual;
        continue;
      // bool isFirst = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          isfirst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.AESEncryptRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AESEncryptRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AESEncryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // int32 receiverId = 2;
  if (this->_internal_receiverid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_receiverid(), target);
  }

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // .crypto.AsymmetricFunction func = 4;
  if (this->_internal_func() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_func(), target);
  }

  // int64 counter = 5;
  if (this->_internal_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(5, this->_internal_counter(), target);
  }

  // string keyId = 6;
  if (!this->_internal_keyid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_keyid().data(), static_cast<int>(this->_internal_keyid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.AESEncryptRequest.keyId");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_keyid(), target);
  }

  // .crypto.AESKeyLength keyLength = 7;
  if (this->_internal_keylength() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_keylength(), target);
  }

  // .crypto.AESChainingMode chainingMode = 8;
  if (this->_internal_chainingmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_chainingmode(), target);
  }

  // bool isFirst = 9;
  if (this->_internal_isfirst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_isfirst(), target);
  }

  // string messageId = 10;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.AESEncryptRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_messageid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AESEncryptRequest)
  return target;
}

size_t AESEncryptRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AESEncryptRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 3;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  // string keyId = 6;
  if (!this->_internal_keyid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_keyid());
  }

  // string messageId = 10;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  // int32 receiverId = 2;
  if (this->_internal_receiverid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiverid());
  }

  // int64 counter = 5;
  if (this->_internal_counter() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_counter());
  }

  // .crypto.AsymmetricFunction func = 4;
  if (this->_internal_func() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_func());
  }

  // .crypto.AESKeyLength keyLength = 7;
  if (this->_internal_keylength() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_keylength());
  }

  // .crypto.AESChainingMode chainingMode = 8;
  if (this->_internal_chainingmode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_chainingmode());
  }

  // bool isFirst = 9;
  if (this->_internal_isfirst() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AESEncryptRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AESEncryptRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AESEncryptRequest::GetClassData() const { return &_class_data_; }

void AESEncryptRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AESEncryptRequest *>(to)->MergeFrom(
      static_cast<const AESEncryptRequest &>(from));
}


void AESEncryptRequest::MergeFrom(const AESEncryptRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AESEncryptRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _internal_set_data(from._internal_data());
  }
  if (!from._internal_keyid().empty()) {
    _internal_set_keyid(from._internal_keyid());
  }
  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  if (from._internal_receiverid() != 0) {
    _internal_set_receiverid(from._internal_receiverid());
  }
  if (from._internal_counter() != 0) {
    _internal_set_counter(from._internal_counter());
  }
  if (from._internal_func() != 0) {
    _internal_set_func(from._internal_func());
  }
  if (from._internal_keylength() != 0) {
    _internal_set_keylength(from._internal_keylength());
  }
  if (from._internal_chainingmode() != 0) {
    _internal_set_chainingmode(from._internal_chainingmode());
  }
  if (from._internal_isfirst() != 0) {
    _internal_set_isfirst(from._internal_isfirst());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AESEncryptRequest::CopyFrom(const AESEncryptRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AESEncryptRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AESEncryptRequest::IsInitialized() const {
  return true;
}

void AESEncryptRequest::InternalSwap(AESEncryptRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &keyid_, lhs_arena,
      &other->keyid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AESEncryptRequest, isfirst_)
      + sizeof(AESEncryptRequest::isfirst_)
      - PROTOBUF_FIELD_OFFSET(AESEncryptRequest, senderid_)>(
          reinterpret_cast<char*>(&senderid_),
          reinterpret_cast<char*>(&other->senderid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AESEncryptRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[29]);
}

// ===================================================================

class AESEncryptResponse::_Internal {
 public:
};

AESEncryptResponse::AESEncryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AESEncryptResponse)
}
AESEncryptResponse::AESEncryptResponse(const AESEncryptResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  encrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_encrypteddata().empty()) {
    encrypteddata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encrypteddata(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:crypto.AESEncryptResponse)
}

void AESEncryptResponse::SharedCtor() {
encrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

AESEncryptResponse::~AESEncryptResponse() {
  // @@protoc_insertion_point(destructor:crypto.AESEncryptResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AESEncryptResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encrypteddata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AESEncryptResponse::ArenaDtor(void* object) {
  AESEncryptResponse* _this = reinterpret_cast< AESEncryptResponse* >(object);
  (void)_this;
}
void AESEncryptResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AESEncryptResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AESEncryptResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AESEncryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  encrypteddata_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AESEncryptResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes encryptedData = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_encrypteddata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AESEncryptResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AESEncryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes encryptedData = 1;
  if (!this->_internal_encrypteddata().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_encrypteddata(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AESEncryptResponse)
  return target;
}

size_t AESEncryptResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AESEncryptResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes encryptedData = 1;
  if (!this->_internal_encrypteddata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encrypteddata());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AESEncryptResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AESEncryptResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AESEncryptResponse::GetClassData() const { return &_class_data_; }

void AESEncryptResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AESEncryptResponse *>(to)->MergeFrom(
      static_cast<const AESEncryptResponse &>(from));
}


void AESEncryptResponse::MergeFrom(const AESEncryptResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AESEncryptResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_encrypteddata().empty()) {
    _internal_set_encrypteddata(from._internal_encrypteddata());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AESEncryptResponse::CopyFrom(const AESEncryptResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AESEncryptResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AESEncryptResponse::IsInitialized() const {
  return true;
}

void AESEncryptResponse::InternalSwap(AESEncryptResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encrypteddata_, lhs_arena,
      &other->encrypteddata_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata AESEncryptResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[30]);
}

// ===================================================================

class AESDecryptRequest::_Internal {
 public:
};

AESDecryptRequest::AESDecryptRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AESDecryptRequest)
}
AESDecryptRequest::AESDecryptRequest(const AESDecryptRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  datain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_datain().empty()) {
    datain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_datain(), 
      GetArenaForAllocation());
  }
  dataout_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_dataout().empty()) {
    dataout_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_dataout(), 
      GetArenaForAllocation());
  }
  keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_keyid().empty()) {
    keyid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_keyid(), 
      GetArenaForAllocation());
  }
  messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_messageid().empty()) {
    messageid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_messageid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&senderid_, &from.senderid_,
    static_cast<size_t>(reinterpret_cast<char*>(&userid_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(userid_));
  // @@protoc_insertion_point(copy_constructor:crypto.AESDecryptRequest)
}

void AESDecryptRequest::SharedCtor() {
datain_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
dataout_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
keyid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
messageid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&senderid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&userid_) -
    reinterpret_cast<char*>(&senderid_)) + sizeof(userid_));
}

AESDecryptRequest::~AESDecryptRequest() {
  // @@protoc_insertion_point(destructor:crypto.AESDecryptRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AESDecryptRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  datain_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  dataout_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  keyid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  messageid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AESDecryptRequest::ArenaDtor(void* object) {
  AESDecryptRequest* _this = reinterpret_cast< AESDecryptRequest* >(object);
  (void)_this;
}
void AESDecryptRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AESDecryptRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AESDecryptRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AESDecryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  datain_.ClearToEmpty();
  dataout_.ClearToEmpty();
  keyid_.ClearToEmpty();
  messageid_.ClearToEmpty();
  ::memset(&senderid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&userid_) -
      reinterpret_cast<char*>(&senderid_)) + sizeof(userid_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AESDecryptRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 senderId = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          senderid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 receiverId = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          receiverid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes dataIn = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_datain();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 inLen = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          inlen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes dataOut = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_dataout();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .crypto.AsymmetricFunction func = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_func(static_cast<::crypto::AsymmetricFunction>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESKeyLength keyLength = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_keylength(static_cast<::crypto::AESKeyLength>(val));
        } else
          goto handle_unusual;
        continue;
      // .crypto.AESChainingMode chainingMode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_chainingmode(static_cast<::crypto::AESChainingMode>(val));
        } else
          goto handle_unusual;
        continue;
      // int64 counter = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string keyId = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          auto str = _internal_mutable_keyid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.AESDecryptRequest.keyId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool isFirst = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          isfirst_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string messageId = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 98)) {
          auto str = _internal_mutable_messageid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "crypto.AESDecryptRequest.messageId"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 userId = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          userid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AESDecryptRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AESDecryptRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_senderid(), target);
  }

  // int32 receiverId = 2;
  if (this->_internal_receiverid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_receiverid(), target);
  }

  // bytes dataIn = 3;
  if (!this->_internal_datain().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_datain(), target);
  }

  // int32 inLen = 4;
  if (this->_internal_inlen() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_inlen(), target);
  }

  // bytes dataOut = 5;
  if (!this->_internal_dataout().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_dataout(), target);
  }

  // .crypto.AsymmetricFunction func = 6;
  if (this->_internal_func() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_func(), target);
  }

  // .crypto.AESKeyLength keyLength = 7;
  if (this->_internal_keylength() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_keylength(), target);
  }

  // .crypto.AESChainingMode chainingMode = 8;
  if (this->_internal_chainingmode() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      8, this->_internal_chainingmode(), target);
  }

  // int64 counter = 9;
  if (this->_internal_counter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(9, this->_internal_counter(), target);
  }

  // string keyId = 10;
  if (!this->_internal_keyid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_keyid().data(), static_cast<int>(this->_internal_keyid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.AESDecryptRequest.keyId");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_keyid(), target);
  }

  // bool isFirst = 11;
  if (this->_internal_isfirst() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_isfirst(), target);
  }

  // string messageId = 12;
  if (!this->_internal_messageid().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_messageid().data(), static_cast<int>(this->_internal_messageid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "crypto.AESDecryptRequest.messageId");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_messageid(), target);
  }

  // int32 userId = 13;
  if (this->_internal_userid() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(13, this->_internal_userid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AESDecryptRequest)
  return target;
}

size_t AESDecryptRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AESDecryptRequest)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes dataIn = 3;
  if (!this->_internal_datain().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_datain());
  }

  // bytes dataOut = 5;
  if (!this->_internal_dataout().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_dataout());
  }

  // string keyId = 10;
  if (!this->_internal_keyid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_keyid());
  }

  // string messageId = 12;
  if (!this->_internal_messageid().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_messageid());
  }

  // int32 senderId = 1;
  if (this->_internal_senderid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_senderid());
  }

  // int32 receiverId = 2;
  if (this->_internal_receiverid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_receiverid());
  }

  // int32 inLen = 4;
  if (this->_internal_inlen() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_inlen());
  }

  // .crypto.AsymmetricFunction func = 6;
  if (this->_internal_func() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_func());
  }

  // .crypto.AESKeyLength keyLength = 7;
  if (this->_internal_keylength() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_keylength());
  }

  // .crypto.AESChainingMode chainingMode = 8;
  if (this->_internal_chainingmode() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_chainingmode());
  }

  // int64 counter = 9;
  if (this->_internal_counter() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_counter());
  }

  // bool isFirst = 11;
  if (this->_internal_isfirst() != 0) {
    total_size += 1 + 1;
  }

  // int32 userId = 13;
  if (this->_internal_userid() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_userid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AESDecryptRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AESDecryptRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AESDecryptRequest::GetClassData() const { return &_class_data_; }

void AESDecryptRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AESDecryptRequest *>(to)->MergeFrom(
      static_cast<const AESDecryptRequest &>(from));
}


void AESDecryptRequest::MergeFrom(const AESDecryptRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AESDecryptRequest)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_datain().empty()) {
    _internal_set_datain(from._internal_datain());
  }
  if (!from._internal_dataout().empty()) {
    _internal_set_dataout(from._internal_dataout());
  }
  if (!from._internal_keyid().empty()) {
    _internal_set_keyid(from._internal_keyid());
  }
  if (!from._internal_messageid().empty()) {
    _internal_set_messageid(from._internal_messageid());
  }
  if (from._internal_senderid() != 0) {
    _internal_set_senderid(from._internal_senderid());
  }
  if (from._internal_receiverid() != 0) {
    _internal_set_receiverid(from._internal_receiverid());
  }
  if (from._internal_inlen() != 0) {
    _internal_set_inlen(from._internal_inlen());
  }
  if (from._internal_func() != 0) {
    _internal_set_func(from._internal_func());
  }
  if (from._internal_keylength() != 0) {
    _internal_set_keylength(from._internal_keylength());
  }
  if (from._internal_chainingmode() != 0) {
    _internal_set_chainingmode(from._internal_chainingmode());
  }
  if (from._internal_counter() != 0) {
    _internal_set_counter(from._internal_counter());
  }
  if (from._internal_isfirst() != 0) {
    _internal_set_isfirst(from._internal_isfirst());
  }
  if (from._internal_userid() != 0) {
    _internal_set_userid(from._internal_userid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AESDecryptRequest::CopyFrom(const AESDecryptRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AESDecryptRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AESDecryptRequest::IsInitialized() const {
  return true;
}

void AESDecryptRequest::InternalSwap(AESDecryptRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &datain_, lhs_arena,
      &other->datain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &dataout_, lhs_arena,
      &other->dataout_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &keyid_, lhs_arena,
      &other->keyid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &messageid_, lhs_arena,
      &other->messageid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AESDecryptRequest, userid_)
      + sizeof(AESDecryptRequest::userid_)
      - PROTOBUF_FIELD_OFFSET(AESDecryptRequest, senderid_)>(
          reinterpret_cast<char*>(&senderid_),
          reinterpret_cast<char*>(&other->senderid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AESDecryptRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[31]);
}

// ===================================================================

class AESDecryptResponse::_Internal {
 public:
};

AESDecryptResponse::AESDecryptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:crypto.AESDecryptResponse)
}
AESDecryptResponse::AESDecryptResponse(const AESDecryptResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  decrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_decrypteddata().empty()) {
    decrypteddata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_decrypteddata(), 
      GetArenaForAllocation());
  }
  decryptedlength_ = from.decryptedlength_;
  // @@protoc_insertion_point(copy_constructor:crypto.AESDecryptResponse)
}

void AESDecryptResponse::SharedCtor() {
decrypteddata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
decryptedlength_ = 0;
}

AESDecryptResponse::~AESDecryptResponse() {
  // @@protoc_insertion_point(destructor:crypto.AESDecryptResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AESDecryptResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  decrypteddata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AESDecryptResponse::ArenaDtor(void* object) {
  AESDecryptResponse* _this = reinterpret_cast< AESDecryptResponse* >(object);
  (void)_this;
}
void AESDecryptResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AESDecryptResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AESDecryptResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:crypto.AESDecryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  decrypteddata_.ClearToEmpty();
  decryptedlength_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AESDecryptResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes decrypteddata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_decrypteddata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 decryptedLength = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          decryptedlength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AESDecryptResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:crypto.AESDecryptResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes decrypteddata = 1;
  if (!this->_internal_decrypteddata().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_decrypteddata(), target);
  }

  // int32 decryptedLength = 2;
  if (this->_internal_decryptedlength() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_decryptedlength(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:crypto.AESDecryptResponse)
  return target;
}

size_t AESDecryptResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:crypto.AESDecryptResponse)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes decrypteddata = 1;
  if (!this->_internal_decrypteddata().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_decrypteddata());
  }

  // int32 decryptedLength = 2;
  if (this->_internal_decryptedlength() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_decryptedlength());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AESDecryptResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AESDecryptResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AESDecryptResponse::GetClassData() const { return &_class_data_; }

void AESDecryptResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AESDecryptResponse *>(to)->MergeFrom(
      static_cast<const AESDecryptResponse &>(from));
}


void AESDecryptResponse::MergeFrom(const AESDecryptResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:crypto.AESDecryptResponse)
  GOOGLE_DCHECK_NE(&from, this);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_decrypteddata().empty()) {
    _internal_set_decrypteddata(from._internal_decrypteddata());
  }
  if (from._internal_decryptedlength() != 0) {
    _internal_set_decryptedlength(from._internal_decryptedlength());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AESDecryptResponse::CopyFrom(const AESDecryptResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:crypto.AESDecryptResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AESDecryptResponse::IsInitialized() const {
  return true;
}

void AESDecryptResponse::InternalSwap(AESDecryptResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &decrypteddata_, lhs_arena,
      &other->decrypteddata_, rhs_arena
  );
  swap(decryptedlength_, other->decryptedlength_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AESDecryptResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_proto_2fencryption_2eproto_getter, &descriptor_table_proto_2fencryption_2eproto_once,
      file_level_metadata_proto_2fencryption_2eproto[32]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace crypto
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::crypto::AsymetricEncryptRequest* Arena::CreateMaybeMessage< ::crypto::AsymetricEncryptRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AsymetricEncryptRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AsymetricEncryptResponse* Arena::CreateMaybeMessage< ::crypto::AsymetricEncryptResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AsymetricEncryptResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AsymetricDecryptRequest* Arena::CreateMaybeMessage< ::crypto::AsymetricDecryptRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AsymetricDecryptRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GetHashLengthRequest* Arena::CreateMaybeMessage< ::crypto::GetHashLengthRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GetHashLengthRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GetAESLengthRequest* Arena::CreateMaybeMessage< ::crypto::GetAESLengthRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GetAESLengthRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AsymetricDecryptResponse* Arena::CreateMaybeMessage< ::crypto::AsymetricDecryptResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AsymetricDecryptResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GetLengthRequest* Arena::CreateMaybeMessage< ::crypto::GetLengthRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GetLengthRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GetLengthResponse* Arena::CreateMaybeMessage< ::crypto::GetLengthResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GetLengthResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GetWholeLength* Arena::CreateMaybeMessage< ::crypto::GetWholeLength >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GetWholeLength >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GenerateAESKeyRequest* Arena::CreateMaybeMessage< ::crypto::GenerateAESKeyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GenerateAESKeyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GenerateAESKeyResponse* Arena::CreateMaybeMessage< ::crypto::GenerateAESKeyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GenerateAESKeyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GenerateKeyPairRequest* Arena::CreateMaybeMessage< ::crypto::GenerateKeyPairRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GenerateKeyPairRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::GenerateKeyPairResponse* Arena::CreateMaybeMessage< ::crypto::GenerateKeyPairResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::GenerateKeyPairResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::SignRequest* Arena::CreateMaybeMessage< ::crypto::SignRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::SignRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::SignResponse* Arena::CreateMaybeMessage< ::crypto::SignResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::SignResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::VerifyRequest* Arena::CreateMaybeMessage< ::crypto::VerifyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::VerifyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::VerifyResponse* Arena::CreateMaybeMessage< ::crypto::VerifyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::VerifyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::KeyRequest* Arena::CreateMaybeMessage< ::crypto::KeyRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::KeyRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::KeyResponse* Arena::CreateMaybeMessage< ::crypto::KeyResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::KeyResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::UserKeyPermissions* Arena::CreateMaybeMessage< ::crypto::UserKeyPermissions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::UserKeyPermissions >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::BootSystemRequest* Arena::CreateMaybeMessage< ::crypto::BootSystemRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::BootSystemRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::Empty* Arena::CreateMaybeMessage< ::crypto::Empty >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::Empty >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::CryptoConfig* Arena::CreateMaybeMessage< ::crypto::CryptoConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::CryptoConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::ConfigureRequest* Arena::CreateMaybeMessage< ::crypto::ConfigureRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::ConfigureRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AddProcessRequest* Arena::CreateMaybeMessage< ::crypto::AddProcessRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AddProcessRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::EncryptRequest* Arena::CreateMaybeMessage< ::crypto::EncryptRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::EncryptRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::EncryptResponse* Arena::CreateMaybeMessage< ::crypto::EncryptResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::EncryptResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::DecryptRequest* Arena::CreateMaybeMessage< ::crypto::DecryptRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::DecryptRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::DecryptResponse* Arena::CreateMaybeMessage< ::crypto::DecryptResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::DecryptResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AESEncryptRequest* Arena::CreateMaybeMessage< ::crypto::AESEncryptRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AESEncryptRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AESEncryptResponse* Arena::CreateMaybeMessage< ::crypto::AESEncryptResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AESEncryptResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AESDecryptRequest* Arena::CreateMaybeMessage< ::crypto::AESDecryptRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AESDecryptRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::crypto::AESDecryptResponse* Arena::CreateMaybeMessage< ::crypto::AESDecryptResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::crypto::AESDecryptResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
